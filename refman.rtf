{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s6\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info 
{\title {\comment My Project  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}My Project}
{\comment Gerado por doxygen 1.12.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt My Project}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Vers\'E3o 1.0\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Sum\'E1rio\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos Componentes\par \pard\plain 
{\tc \v \'CDndice dos Componentes}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de Classes\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Aqui est\'E3o as classes, estruturas, uni\'F5es e interfaces e suas respectivas descri\'E7\'F5es:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b dado} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LISTA} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b no} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nos} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Quantidade_Palavras} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos Arquivos\par \pard\plain 
{\tc \v \'CDndice dos Arquivos}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de Arquivos\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Esta \'E9 a lista de todos os arquivos e suas respectivas descri\'E7\'F5es:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b apaga.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b apaga.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b Consulta_Base_Arquivos.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b Consulta_Base_Arquivos.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b consulta_palavra.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b consulta_palavra.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b escreve.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b escreve.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b Forma_da_Busca.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b Forma_da_Busca.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b main.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b teste.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b teste.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Classes{\tc \v Classes}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura dado\par \pard\plain 
{\tc\tcl2 \v dado}
{\xe \v dado}
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\par
{
{\f2 #include <teste.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b nome_arquivo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b quantidade_palavras}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b quantidade_palavras_nao_repetidas}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char ** {\b Palavras_organizadas}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b numero_do_arquivo}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v nome_arquivo\:dado}
{\xe \v dado\:nome_arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* dado::nome_arquivo}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v numero_do_arquivo\:dado}
{\xe \v dado\:numero_do_arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int dado::numero_do_arquivo}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Palavras_organizadas\:dado}
{\xe \v dado\:Palavras_organizadas}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char** dado::Palavras_organizadas}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v quantidade_palavras\:dado}
{\xe \v dado\:quantidade_palavras}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int dado::quantidade_palavras}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v quantidade_palavras_nao_repetidas\:dado}
{\xe \v dado\:quantidade_palavras_nao_repetidas}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int dado::quantidade_palavras_nao_repetidas}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b teste.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura LISTA\par \pard\plain 
{\tc\tcl2 \v LISTA}
{\xe \v LISTA}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\par
{
{\f2 #include <teste.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b no} * {\b ini}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b no} * {\b fim}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Quantidade_de_Arquivos}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v fim\:LISTA}
{\xe \v LISTA\:fim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b no}* LISTA::fim}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ini\:LISTA}
{\xe \v LISTA\:ini}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b no}* LISTA::ini}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Quantidade_de_Arquivos\:LISTA}
{\xe \v LISTA\:Quantidade_de_Arquivos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int LISTA::Quantidade_de_Arquivos}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b teste.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura no\par \pard\plain 
{\tc\tcl2 \v no}
{\xe \v no}
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
\par
{
{\f2 #include <teste.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b no} * {\b prox}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b no} * {\b ant}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ARQUIVO} * {\b arquivo}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v ant\:no}
{\xe \v no\:ant}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b no}* no::ant}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v arquivo\:no}
{\xe \v no\:arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ARQUIVO}* no::arquivo}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v prox\:no}
{\xe \v no\:prox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b no}* no::prox}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b teste.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura nos\par \pard\plain 
{\tc\tcl2 \v nos}
{\xe \v nos}
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
\par
{
{\f2 #include <teste.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b Palavra} [{\b TAMANHO_DA_PALAVRA}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b Arquivo} [{\b TAMANHO_DA_PALAVRA}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b quantidade}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b linha} [{\b QUANTIDADE_DE_LINHAS}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b total_de_vezes_palavra}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b livre}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nos} * {\b prox}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nos} * {\b ant}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v ant\:nos}
{\xe \v nos\:ant}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b nos}* nos::ant}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Arquivo\:nos}
{\xe \v nos\:Arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char nos::Arquivo[{\b TAMANHO_DA_PALAVRA}]}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v linha\:nos}
{\xe \v nos\:linha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nos::linha[{\b QUANTIDADE_DE_LINHAS}]}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v livre\:nos}
{\xe \v nos\:livre}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool nos::livre}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Palavra\:nos}
{\xe \v nos\:Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char nos::Palavra[{\b TAMANHO_DA_PALAVRA}]}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v prox\:nos}
{\xe \v nos\:prox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b nos}* nos::prox}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v quantidade\:nos}
{\xe \v nos\:quantidade}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nos::quantidade}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v total_de_vezes_palavra\:nos}
{\xe \v nos\:total_de_vezes_palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nos::total_de_vezes_palavra}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b teste.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Quantidade_Palavras\par \pard\plain 
{\tc\tcl2 \v Quantidade_Palavras}
{\xe \v Quantidade_Palavras}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
\par
{
{\f2 #include <Consulta_Base_Arquivos.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b nome} [{\b TAMANHO_DA_PALAVRA}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b quant}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de consulta de palavras em rela\'E7\'E3o ao sistema de arquivos \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v nome\:Quantidade_Palavras}
{\xe \v Quantidade_Palavras\:nome}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char Quantidade_Palavras::nome[{\b TAMANHO_DA_PALAVRA}]}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v quant\:Quantidade_Palavras}
{\xe \v Quantidade_Palavras\:quant}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Quantidade_Palavras::quant}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b Consulta_Base_Arquivos.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Arquivos{\tc \v Arquivos}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.cpp}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.cpp}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "teste.h"}\par
{\f2 #include "apaga.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Remove_Log_Palavra} (char *nome_entrada)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Remove_Log_Arquivo} (char *nome_entrada)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Remove_Log_Controle} (char *nome_entrada)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Remove_Log_Arquivo\:apaga.cpp}
{\xe \v apaga.cpp\:Remove_Log_Arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Remove_Log_Arquivo (char * nome_entrada)}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27 \{\par
28     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
29     strcpy(nome, nome_entrada);\par
30     strcat(nome, {\cf22 "LogPal.txt"});\par
31     cout << nome << endl;\par
32     remove({\cf22 "LISTA.TXTLog_Arquivo.txt"});\par
33 \par
34 \}\par
}
}
{\xe \v Remove_Log_Controle\:apaga.cpp}
{\xe \v apaga.cpp\:Remove_Log_Controle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Remove_Log_Controle (char * nome_entrada)}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 38 \{\par
39 \par
40 \par
41 \par
42     {\cf18 int} i =0; {\cf18 int} confirma = 0;\par
43 \par
44     {\cf18 char} nome[TAMANHO_DO_CONTROLE][TAMANHO_DA_PALAVRA];\par
45     {\cf19 for}( {\cf18 int} j = 0; j < TAMANHO_DO_CONTROLE; j++)\par
46     \{\par
47     strcpy(nome[j], {\cf22 " "});\par
48     \}\par
49 \par
50     {\cf18 char} nomes[TAMANHO_DA_PALAVRA];\par
51     strcpy(nomes, nome_entrada);\par
52     strupr(nomes);\par
53 \par
54     ifstream arquivo_ler;\par
55     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
56     {\cf19 if}(!arquivo_ler.is_open())\par
57     \{\par
58        cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que remover."} << endl;\par
59        arquivo_ler.clear();\par
60        {\cf19 return} 0;\par
61     \}\par
62 \par
63     {\cf19 if}(is_empty(arquivo_ler))\par
64     \{\par
65         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que remover."} << endl;\par
66         {\cf20 //system("PAUSE > null");}\par
67         {\cf19 return} 0;\par
68     \}\par
69     {\cf19 else}\par
70     \{\par
71 \par
72         {\cf19 while}(! arquivo_ler.eof())      {\cf20 //BUSCA SEQUENCIAL ITERATIVA DENTRO DO ARQUIVO PELO NOME - SE FOR IGUAL REMOVE SE N\'C3O, MANT\'C9M O ARQUIVO COMO O ORIGINAL}\par
73         \{\par
74 \par
75 \par
76                 arquivo_ler >> nome[i];\par
77                 {\cf20 /*cout << nome[i] << endl;}\par
78 {\cf20                 cout << nomes << endl;}\par
79 {\cf20                 cout << "cfscasmdksa" <<endl;}\par
80 {\cf20                 system("PAUSE > null");}\par
81 {\cf20                 */}\par
82 \par
83 \par
84                 {\cf19 if}(strcmp(nome[i], nomes) == 0)\par
85                 \{\par
86                     {\cf19 for}({\cf18 int} t = 0; t < 2; t++)\par
87                     \{\par
88                         {\cf20 /*}\par
89 {\cf20 }\par
90 {\cf20                         if(remove(nomes) == 0)}\par
91 {\cf20                         \{}\par
92 {\cf20                             cout << "Arquivo removido com sucesso." << endl;}\par
93 {\cf20                         \}}\par
94 {\cf20 }\par
95 {\cf20                         if(remove(strcat(nomes, "LogArq.txt")) == 0)}\par
96 {\cf20                         \{}\par
97 {\cf20                             cout << "swfeqmksd" << endl;}\par
98 {\cf20                         \}}\par
99 {\cf20                         if(remove(strcat(nomes, "LOGPAL.TXT")) == 0)}\par
100 {\cf20                         \{}\par
101 {\cf20                               cout << "tergeksd" << endl;}\par
102 {\cf20                         \}}\par
103 {\cf20                     */}\par
104                     \}\par
105 \par
106 \par
107 \par
108                     {\cf20 //Remove_Log_Palavra(nome_entrada);}\par
109                     {\cf20 //Remove_Log_Arquivo(nome_entrada);}\par
110                     confirma = 1;\par
111                 \}\par
112                 i++;\par
113 \par
114         \}\par
115     \}\par
116 \par
117 arquivo_ler.close();\par
118 \par
119 {\cf20 //cout << i <<endl;}\par
120 {\cf20 //system("PAUSE > null");}\par
121 \par
122 \par
123 {\cf19 if}(confirma == 1)\par
124     \{\par
125 \par
126         {\cf19 if}( i == 1)\par
127         \{\par
128             remove({\cf22 "Log_Controle.txt"});\par
129         \}\par
130         {\cf19 else}\par
131         \{\par
132             ofstream arquivo_escrever;\par
133             arquivo_escrever.open({\cf22 "Log_Controle.txt"});\par
134             {\cf19 if}(!arquivo_escrever.is_open())\par
135             \{\par
136                 cout << {\cf22 "N\'E3o foi encontrado o arquivo:"} << endl;\par
137                 arquivo_escrever.clear();\par
138                 {\cf19 return} 0;\par
139             \}\par
140             {\cf19 else}\par
141             \{\par
142                 {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
143                 \{\par
144                     {\cf19 if}(strcmp(nome[j], nomes) == 0)\par
145                     \{\par
146 \par
147                     \}\par
148                     {\cf19 else}\par
149                     \{\par
150                         arquivo_escrever << nome[j] << {\cf22 " "};\par
151                     \}\par
152 \par
153                 \}\par
154 \par
155             \}\par
156         arquivo_ler.close();\par
157         \}\par
158     \}\par
159     {\cf19 else}\par
160     \{\par
161     ifstream arquivo_ler_tentativa;\par
162     arquivo_ler_tentativa.open(nome_entrada);\par
163     {\cf19 if}(!arquivo_ler_tentativa.is_open())\par
164     \{\par
165        cout << {\cf22 "N\'E3o foi encontrado o arquivo: adicione-o a pasta atual e insira-o."} << endl;\par
166        arquivo_ler.clear();\par
167        {\cf19 return} 0;\par
168     \}\par
169     {\cf19 else}\par
170     \{\par
171         cout << {\cf22 "O arquivo est\'E1 na pasta mais ainda n\'E3o foi adicionado ao banco de arquivos."} << endl;\par
172         {\cf19 return} 0;\par
173     \}\par
174 \par
175 \par
176     \}\par
177 \par
178 \par
179 \par
180 \}\par
}
}
{\xe \v Remove_Log_Palavra\:apaga.cpp}
{\xe \v apaga.cpp\:Remove_Log_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Remove_Log_Palavra (char * nome_entrada)}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de remo\'E7\'E3o de palavras do sistema de arquivos \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17 \{\par
18     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
19     strcpy(nome, nome_entrada);\par
20     strcat(nome, {\cf22 "LogPal.txt"});\par
21     cout << nome << endl;\par
22     remove({\cf22 "lista.txtlog_palavra.txt /0"});\par
23 \par
24 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.h}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Remove_Log_Palavra} (char *nome_entrada)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Remove_Log_Arquivo} (char *nome_entrada)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Remove_Log_Controle} (char *nome)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Remove_Log_Arquivo\:apaga.h}
{\xe \v apaga.h\:Remove_Log_Arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Remove_Log_Arquivo (char * nome_entrada)}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27 \{\par
28     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
29     strcpy(nome, nome_entrada);\par
30     strcat(nome, {\cf22 "LogPal.txt"});\par
31     cout << nome << endl;\par
32     remove({\cf22 "LISTA.TXTLog_Arquivo.txt"});\par
33 \par
34 \}\par
}
}
{\xe \v Remove_Log_Controle\:apaga.h}
{\xe \v apaga.h\:Remove_Log_Controle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Remove_Log_Controle (char * nome)}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 38 \{\par
39 \par
40 \par
41 \par
42     {\cf18 int} i =0; {\cf18 int} confirma = 0;\par
43 \par
44     {\cf18 char} nome[TAMANHO_DO_CONTROLE][TAMANHO_DA_PALAVRA];\par
45     {\cf19 for}( {\cf18 int} j = 0; j < TAMANHO_DO_CONTROLE; j++)\par
46     \{\par
47     strcpy(nome[j], {\cf22 " "});\par
48     \}\par
49 \par
50     {\cf18 char} nomes[TAMANHO_DA_PALAVRA];\par
51     strcpy(nomes, nome_entrada);\par
52     strupr(nomes);\par
53 \par
54     ifstream arquivo_ler;\par
55     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
56     {\cf19 if}(!arquivo_ler.is_open())\par
57     \{\par
58        cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que remover."} << endl;\par
59        arquivo_ler.clear();\par
60        {\cf19 return} 0;\par
61     \}\par
62 \par
63     {\cf19 if}(is_empty(arquivo_ler))\par
64     \{\par
65         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que remover."} << endl;\par
66         {\cf20 //system("PAUSE > null");}\par
67         {\cf19 return} 0;\par
68     \}\par
69     {\cf19 else}\par
70     \{\par
71 \par
72         {\cf19 while}(! arquivo_ler.eof())      {\cf20 //BUSCA SEQUENCIAL ITERATIVA DENTRO DO ARQUIVO PELO NOME - SE FOR IGUAL REMOVE SE N\'C3O, MANT\'C9M O ARQUIVO COMO O ORIGINAL}\par
73         \{\par
74 \par
75 \par
76                 arquivo_ler >> nome[i];\par
77                 {\cf20 /*cout << nome[i] << endl;}\par
78 {\cf20                 cout << nomes << endl;}\par
79 {\cf20                 cout << "cfscasmdksa" <<endl;}\par
80 {\cf20                 system("PAUSE > null");}\par
81 {\cf20                 */}\par
82 \par
83 \par
84                 {\cf19 if}(strcmp(nome[i], nomes) == 0)\par
85                 \{\par
86                     {\cf19 for}({\cf18 int} t = 0; t < 2; t++)\par
87                     \{\par
88                         {\cf20 /*}\par
89 {\cf20 }\par
90 {\cf20                         if(remove(nomes) == 0)}\par
91 {\cf20                         \{}\par
92 {\cf20                             cout << "Arquivo removido com sucesso." << endl;}\par
93 {\cf20                         \}}\par
94 {\cf20 }\par
95 {\cf20                         if(remove(strcat(nomes, "LogArq.txt")) == 0)}\par
96 {\cf20                         \{}\par
97 {\cf20                             cout << "swfeqmksd" << endl;}\par
98 {\cf20                         \}}\par
99 {\cf20                         if(remove(strcat(nomes, "LOGPAL.TXT")) == 0)}\par
100 {\cf20                         \{}\par
101 {\cf20                               cout << "tergeksd" << endl;}\par
102 {\cf20                         \}}\par
103 {\cf20                     */}\par
104                     \}\par
105 \par
106 \par
107 \par
108                     {\cf20 //Remove_Log_Palavra(nome_entrada);}\par
109                     {\cf20 //Remove_Log_Arquivo(nome_entrada);}\par
110                     confirma = 1;\par
111                 \}\par
112                 i++;\par
113 \par
114         \}\par
115     \}\par
116 \par
117 arquivo_ler.close();\par
118 \par
119 {\cf20 //cout << i <<endl;}\par
120 {\cf20 //system("PAUSE > null");}\par
121 \par
122 \par
123 {\cf19 if}(confirma == 1)\par
124     \{\par
125 \par
126         {\cf19 if}( i == 1)\par
127         \{\par
128             remove({\cf22 "Log_Controle.txt"});\par
129         \}\par
130         {\cf19 else}\par
131         \{\par
132             ofstream arquivo_escrever;\par
133             arquivo_escrever.open({\cf22 "Log_Controle.txt"});\par
134             {\cf19 if}(!arquivo_escrever.is_open())\par
135             \{\par
136                 cout << {\cf22 "N\'E3o foi encontrado o arquivo:"} << endl;\par
137                 arquivo_escrever.clear();\par
138                 {\cf19 return} 0;\par
139             \}\par
140             {\cf19 else}\par
141             \{\par
142                 {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
143                 \{\par
144                     {\cf19 if}(strcmp(nome[j], nomes) == 0)\par
145                     \{\par
146 \par
147                     \}\par
148                     {\cf19 else}\par
149                     \{\par
150                         arquivo_escrever << nome[j] << {\cf22 " "};\par
151                     \}\par
152 \par
153                 \}\par
154 \par
155             \}\par
156         arquivo_ler.close();\par
157         \}\par
158     \}\par
159     {\cf19 else}\par
160     \{\par
161     ifstream arquivo_ler_tentativa;\par
162     arquivo_ler_tentativa.open(nome_entrada);\par
163     {\cf19 if}(!arquivo_ler_tentativa.is_open())\par
164     \{\par
165        cout << {\cf22 "N\'E3o foi encontrado o arquivo: adicione-o a pasta atual e insira-o."} << endl;\par
166        arquivo_ler.clear();\par
167        {\cf19 return} 0;\par
168     \}\par
169     {\cf19 else}\par
170     \{\par
171         cout << {\cf22 "O arquivo est\'E1 na pasta mais ainda n\'E3o foi adicionado ao banco de arquivos."} << endl;\par
172         {\cf19 return} 0;\par
173     \}\par
174 \par
175 \par
176     \}\par
177 \par
178 \par
179 \par
180 \}\par
}
}
{\xe \v Remove_Log_Palavra\:apaga.h}
{\xe \v apaga.h\:Remove_Log_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Remove_Log_Palavra (char * nome_entrada)}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de remo\'E7\'E3o de palavras do sistema de arquivos \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17 \{\par
18     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
19     strcpy(nome, nome_entrada);\par
20     strcat(nome, {\cf22 "LogPal.txt"});\par
21     cout << nome << endl;\par
22     remove({\cf22 "lista.txtlog_palavra.txt /0"});\par
23 \par
24 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
apaga.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef _APAGA_H_}\par
2 {\cf21 #define _APAGA_H_}\par
3 \par
8 {\cf18 void} Remove_Log_Palavra({\cf18 char} *nome_entrada);\par
9 {\cf18 void} Remove_Log_Arquivo({\cf18 char} *nome_entrada);\par
10 {\cf18 bool} Remove_Log_Controle({\cf18 char} *nome);\par
11 \par
12 \par
13 {\cf21 #endif}\par
14 \par
15 \par
16 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.cpp}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.cpp}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "teste.h"}\par
{\f2 #include "Consulta_Base_Arquivos.h"}\par
{\f2 #include "consulta_palavra.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b func}) ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Insercao} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Alfabetica} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Alfabetica} ({\b Hash} tabela, char *nome)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b recupera_numero_Palavras} ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Ordena_Vetor_Quantidade_Palavra} ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Apresenta_Vetor_Quantidade_Palavra} ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Quantidade_Palavras} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es dos tipos\par
\pard\plain 
{\xe \v func\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:func}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* func) ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Apresenta_Vetor_Quantidade_Palavra\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:Apresenta_Vetor_Quantidade_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apresenta_Vetor_Quantidade_Palavra ({\b Ordena_Quant_Palavra} * vetor, int Numero_Palavra_Arquivo_Log)}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 396 \{\par
397 \par
398 \par
399 \par
400     {\cf19 for}({\cf18 int} j = Numero_Palavra_Arquivo_Log - 1; j >= 0; j--)\par
401     \{\par
402         cout << {\cf22 "-"} << vetor[j].nome << {\cf22 " "} << vetor[j].quant << endl;\par
403 \par
404     \}\par
405 \par
406 \par
407 \par
408 \}\par
}
}
{\xe \v Consulta_Base_Alfabetica\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:Consulta_Base_Alfabetica}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Alfabetica ()}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 56 \{\par
57     {\cf18 char} nome[TAMANHO_DA_PALAVRA][TAMANHO_DO_CONTROLE];\par
58     {\cf18 int} i = 0;\par
59     ifstream arquivo_ler;\par
60     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
61     {\cf19 if}(!arquivo_ler.is_open())\par
62     \{\par
63        cout << {\cf22 "O banco de arquivo est\'E1 vazio, n\'E3o h\'E1 o que apresentar."} << endl;\par
64        {\cf20 //arquivo_ler.clear();}\par
65        {\cf19 return} 0;\par
66     \}\par
67     {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
68     \{\par
69         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 arquivos no banco de arquivos para ser apresentado."} << endl;\par
70         {\cf19 return} 0;\par
71         {\cf20 //system("PAUSE > null");}\par
72     \}\par
73     {\cf19 else}\par
74     \{\par
75         {\cf19 while}(! arquivo_ler.eof())\par
76         \{\par
77             arquivo_ler >> nome[i];\par
78             i++;\par
79         \}\par
80 \par
81         arquivo_ler.close();\par
82 \par
83         {\cf18 char} aux[TAMANHO_DA_PALAVRA];\par
84 \par
85         {\cf19 for}({\cf18 int} r = 0; r < i; r++)              {\cf20 // ordenando os arquivos tendo como base a ordem alfab\'E9tica}\par
86         \{\par
87             {\cf19 for}({\cf18 int} s = r+1; s < i; s++)\par
88             \{\par
89                 {\cf19 if} (strcmp(nome[r],nome[s])>0)\par
90                     \{\par
91                        strcpy(aux,nome[s]);\par
92                        strcpy(nome[s],nome[r]);\par
93                        strcpy(nome[r], aux);\par
94                     \}\par
95             \}\par
96 \par
97         \}\par
98 \par
99 \par
100         {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
101         \{\par
102                 cout << {\cf22 "-"} << nome[j] << endl;\par
103         \}\par
104 \par
105     \}\par
106 \par
107 \par
108 \}\par
}
}
{\xe \v Consulta_Base_Alfabetica\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:Consulta_Base_Alfabetica}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Alfabetica ({\b Hash} tabela, char * nome)}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 112 \{\par
113 \par
114 \par
115     {\cf18 int} contador_linhas = 0, linha_correta_atual = 0;\par
116 \par
117     {\cf18 char} nome_palavra[TAMANHO_DA_PALAVRA];\par
118     strcpy(nome_palavra, nome);\par
119     strupr(nome_palavra);\par
120 \par
121     {\cf18 int} pos = hash_funcao(nome_palavra);\par
122     {\cf18 char} linha[TAMANHO_DA_FRASE];\par
123     Dados *aux1, *aux2, *aux3, *aux4, *aux5, *aux6;\par
124     aux1 = tabela[pos];\par
125     aux2 = tabela[pos]->prox;\par
126 \par
127     cout << tabela[pos]->Arquivo << endl;\par
128     cout << tabela[pos]->prox->Arquivo << endl;\par
129     cout << tabela[pos]->prox->prox->Arquivo << endl <<endl;\par
130     cout << aux1->Arquivo << endl;\par
131     cout << aux2->Arquivo << endl <<endl;\par
132 \par
133     system({\cf22 "PAUSE > null"});\par
134     {\cf19 while}(aux1->prox != NULL)\par
135     \{\par
136 \par
137 \par
138         {\cf19 while}(aux2 != NULL)\par
139         \{\par
140 \par
141             cout << tabela[pos]->Arquivo << endl;\par
142             cout << tabela[pos]->prox->Arquivo << endl;\par
143             cout << tabela[pos]->prox->prox->Arquivo << endl <<endl;\par
144             cout << aux1->Arquivo << endl;\par
145             cout << aux2->Arquivo << endl <<endl;\par
146 \par
147 \par
148 \par
149             {\cf19 if}(strcmp(aux1->Arquivo, aux2->Arquivo) > 0)\par
150             \{\par
151 \par
152 \par
153                 {\cf19 if}(aux1->prox == aux2)\par
154                 \{\par
155                     {\cf19 if}(aux1->ant == NULL && aux2->prox == NULL)\par
156                     \{\par
157 \par
158                         cout<< {\cf22 "kl\'E7sda"} << endl;\par
159                         system({\cf22 "PAUSE > null"});\par
160                         aux3->prox = aux2;\par
161 \par
162 \par
163 \par
164 \par
165                     \}\par
166                     {\cf19 else} {\cf19 if}(aux1->ant == NULL && aux2->prox != NULL)\par
167                     \{\par
168 \par
169 \par
170 \par
171                         {\cf20 //aux3 = aux1->ant; = \'E9 NULL;}\par
172                         aux3 = aux2->prox;\par
173                         aux3->ant = aux1;\par
174                         aux1->prox  = aux3;\par
175                         aux2->prox = aux1;\par
176                         aux2->ant = NULL;\par
177 \par
178 \par
179                     \}\par
180                     {\cf19 else} {\cf19 if}(aux1->ant != NULL && aux2->prox == NULL)\par
181                     \{\par
182 \par
183 \par
184                         aux3 = aux1->prox;\par
185                         aux4 = aux1->ant;\par
186 \par
187                         aux5 = aux2->prox;     {\cf20 //NULL}\par
188                         aux6 = aux2->ant;\par
189 \par
190                         aux6->prox = aux1;\par
191                         aux1->prox = NULL;\par
192                         aux1->ant = aux6;\par
193 \par
194                         aux3->ant = aux2;\par
195                         aux4->prox = aux2;\par
196                         aux2->prox = aux3;\par
197                         aux2->ant = aux4;\par
198 \par
199                     \}\par
200                     {\cf19 else}\par
201                     \{\par
202 \par
203                         aux3 = aux1->prox;\par
204                         aux4 = aux1->ant;\par
205 \par
206                         aux5 = aux2->prox;     {\cf20 //NULL}\par
207                         aux6 = aux2->ant;\par
208 \par
209 \par
210                         aux6->prox = aux1;\par
211                         aux5->ant  = aux1;\par
212                         aux1->prox = aux5;\par
213                         aux2->ant  = aux6;\par
214 \par
215                         aux3->ant = aux2;\par
216                         aux4->prox = aux2;\par
217                         aux2->prox = aux3;\par
218                         aux2->ant = aux4;\par
219                     \}\par
220 \par
221                 \}\par
222                 {\cf19 else}\par
223                 \{\par
224                     {\cf19 if}(aux1->ant == NULL && aux2->prox == NULL)\par
225                     \{\par
226 \par
227                         cout<< {\cf22 "kl\'E7sda"} << endl;\par
228                         system({\cf22 "PAUSE > null"});\par
229 \par
230                         aux3 = aux1->prox;\par
231                         aux4 = aux1->ant;   {\cf20 //NULL}\par
232 \par
233                         aux5 = aux2->prox;  {\cf20 //NULL}\par
234                         aux6 = aux2->ant;\par
235 \par
236                         aux6->prox = aux1;\par
237                         aux1->ant = aux6;\par
238                         aux1->prox = NULL;\par
239 \par
240                         aux3->ant = aux2;\par
241                         aux2->prox = aux3;\par
242                         aux2->ant = NULL;\par
243                     \}\par
244                     {\cf19 else} {\cf19 if}(aux1->ant == NULL && aux2->prox != NULL)\par
245                     \{\par
246 \par
247 \par
248 \par
249                         aux3 = aux1->prox;\par
250                         aux4 = aux1->ant;   {\cf20 //NULL}\par
251 \par
252                         aux5 = aux2->prox;\par
253                         aux6 = aux2->ant;\par
254 \par
255                         aux3->ant = aux2;\par
256                         aux2->ant = NULL;\par
257                         aux2->prox = aux3;\par
258 \par
259 \par
260 \par
261 \par
262 \par
263                         aux1->prox = aux5;\par
264                         aux1->ant  = aux6;\par
265                         aux6->prox = aux1;\par
266                         aux5->ant  = aux1;\par
267 \par
268 \par
269                     \}\par
270                     {\cf19 else} {\cf19 if}(aux1->ant != NULL && aux2->prox == NULL)\par
271                     \{\par
272 \par
273 \par
274                         aux3 = aux1->prox;\par
275                         aux4 = aux1->ant;\par
276 \par
277                         aux5 = aux2->prox;     {\cf20 //NULL}\par
278                         aux6 = aux2->ant;\par
279 \par
280                         aux6->prox = aux1;\par
281                         aux1->prox = NULL;\par
282                         aux1->ant = aux6;\par
283 \par
284                         aux3->ant = aux2;\par
285                         aux4->prox = aux2;\par
286                         aux2->prox = aux3;\par
287                         aux2->ant = aux4;\par
288 \par
289                     \}\par
290                     {\cf19 else}\par
291                     \{\par
292 \par
293                         aux3 = aux1->prox;\par
294                         aux4 = aux1->ant;\par
295 \par
296                         aux5 = aux2->prox;     {\cf20 //NULL}\par
297                         aux6 = aux2->ant;\par
298 \par
299 \par
300                         aux6->prox = aux1;\par
301                         aux5->ant  = aux1;\par
302                         aux1->prox = aux5;\par
303                         aux2->ant  = aux6;\par
304 \par
305                         aux3->ant = aux2;\par
306                         aux4->prox = aux2;\par
307                         aux2->prox = aux3;\par
308                         aux2->ant = aux4;\par
309                     \}\par
310 \par
311             cout << tabela[pos]->Arquivo << endl;\par
312             cout << tabela[pos]->prox->Arquivo << endl;\par
313             cout << tabela[pos]->prox->prox->Arquivo << endl <<endl;\par
314             cout << aux1->Arquivo << endl;\par
315             cout << aux2->Arquivo << endl <<endl;\par
316 \par
317 \par
318                 \}\par
319 \par
320             \}\par
321 \par
322 \par
323             aux2 = aux2->prox;\par
324 \par
325         \}\par
326 \par
327         aux1 = aux1->prox;\par
328         aux2 = aux1->prox;\par
329 \par
330 \par
331     \}\par
332 \par
333 \}\par
}
}
{\xe \v Consulta_Base_Insercao\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:Consulta_Base_Insercao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Insercao ()}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de consulta de palavras em rela\'E7\'E3o ao sistema de arquivos \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19 \{\par
20     {\cf18 char} nome[TAMANHO_DA_PALAVRA][TAMANHO_DO_CONTROLE];\par
21     {\cf18 int} i = 0;\par
22     ifstream arquivo_ler;\par
23     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
24     {\cf19 if}(!arquivo_ler.is_open())\par
25     \{\par
26        cout << {\cf22 "O banco de arquivo est\'E1 vazio, n\'E3o h\'E1 o que apresentar."} << endl;\par
27        arquivo_ler.clear();\par
28        {\cf19 return} 0;\par
29     \}\par
30     {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
31     \{\par
32         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 arquivos no banco de arquivos para ser apresentado."} << endl;\par
33         {\cf19 return} 0;\par
34     \}\par
35     {\cf19 else}\par
36     \{\par
37         {\cf19 while}(! arquivo_ler.eof())\par
38         \{\par
39             arquivo_ler >> nome[i];\par
40             i++;\par
41         \}\par
42 \par
43     arquivo_ler.close();\par
44 \par
45     {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
46     \{\par
47         cout << {\cf22 "-"} << nome[j] << endl;\par
48     \}\par
49 \par
50     \}\par
51 \par
52 \par
53 \}\par
}
}
{\xe \v Consulta_Base_Quantidade_Palavras\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:Consulta_Base_Quantidade_Palavras}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Quantidade_Palavras ()}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 411 \{\par
412 \par
413 \par
414     Ordena_Quant_Palavra vetor[TAMANHO_DO_CONTROLE];\par
415     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
416 \par
417     {\cf18 int} i = 0;\par
418     ifstream arquivo_ler;\par
419     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
420     {\cf19 if}(!arquivo_ler.is_open())\par
421     \{\par
422         cout << {\cf22 "O banco de arquivo est\'E1 vazio, n\'E3o h\'E1 o que apresentar."} << endl;\par
423         arquivo_ler.clear();\par
424         {\cf19 return} 0;\par
425     \}\par
426     {\cf20 /*}\par
427 {\cf20     else if(is_empty(arquivo_ler))}\par
428 {\cf20     \{}\par
429 {\cf20         cout << "arquivo vazio, n\'E3o h\'E1 o que remover." << endl;}\par
430 {\cf20         system("PAUSE > null");}\par
431 {\cf20     \}}\par
432 {\cf20     */}\par
433     {\cf19 else}\par
434     \{\par
435 \par
436         {\cf19 while}(! arquivo_ler.eof())\par
437         \{\par
438             arquivo_ler >> nome;{\cf20 // abrindo arquivo  com dados do arquivo}\par
439             strcpy(vetor[i].nome, nome);\par
440             {\cf20 //cout << i << endl;}\par
441             i++;\par
442 \par
443         \}\par
444     \}\par
445 \par
446 \par
447 \par
448 arquivo_ler.close();\par
449 \par
450 \par
451 \par
452 \par
453 {\cf20 //cout << "nijlads" << endl;}\par
454 {\cf20 //system("PAUSE > null");}\par
455 \par
456 func funcoes;           {\cf20 // exemplo de ponteiro de fun\'E7\'E3o - usado para facilitar o manuseio das etapas necess\'E1rias a apresenta\'E7\'E3o dos arquivos ordenados por quantidade de palavras}\par
457 \par
458 funcoes = recupera_numero_Palavras;\par
459 funcoes(vetor, i);\par
460 \par
461 funcoes = Ordena_Vetor_Quantidade_Palavra;\par
462 funcoes(vetor, i);\par
463 \par
464 funcoes = Apresenta_Vetor_Quantidade_Palavra;\par
465 funcoes(vetor, i);\par
466 \par
467 \par
468 \par
469 \par
470 \par
471 \par
472 \par
473 \par
474 \par
475 \}\par
}
}
{\xe \v Ordena_Vetor_Quantidade_Palavra\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:Ordena_Vetor_Quantidade_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Ordena_Vetor_Quantidade_Palavra ({\b Ordena_Quant_Palavra} * vetor, int Numero_Palavra_Arquivo_Log)}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 374 \{\par
375     Ordena_Quant_Palavra aux[1];\par
376 \par
377     {\cf20 //cout << i<< "dasds" << endl;}\par
378     {\cf20 //system("PAUSE > null");}\par
379 \par
380     {\cf19 for}({\cf18 int} r = 0; r < Numero_Palavra_Arquivo_Log; r++)          {\cf20 //ordenando tendo como base a quantidade de  palavras (descescente}\par
381     \{\par
382         {\cf19 for}({\cf18 int} s = r+1; s < Numero_Palavra_Arquivo_Log; s++)\par
383         \{\par
384             {\cf19 if} (vetor[r].quant > vetor[s].quant)\par
385                 \{\par
386                     aux[0] = vetor[r];\par
387                     vetor[r]= vetor[s];\par
388                     vetor[s] = aux[0];\par
389                 \}\par
390         \}\par
391 \par
392     \}\par
393 \par
394 \}\par
}
}
{\xe \v recupera_numero_Palavras\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:recupera_numero_Palavras}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void recupera_numero_Palavras ({\b Ordena_Quant_Palavra} * vetor, int Numero_Palavra_Arquivo_Log)}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 338 \{\par
339 \par
340     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
341     {\cf19 for}({\cf18 int} j = 0; j < Numero_Palavra_Arquivo_Log; j++)\par
342     \{\par
343 \par
344 \par
345 \par
346         ifstream arquivo_ler_log;\par
347         strcpy(nome, vetor[j].nome);\par
348 \par
349         strcat(nome, {\cf22 "LogArq.txt"});\par
350         strupr(nome);\par
351         arquivo_ler_log.open(nome);\par
352 \par
353 \par
354         {\cf19 if}(!arquivo_ler_log.is_open())\par
355         \{\par
356             cout << {\cf22 "N\'E3o foi encontrado o arquivo de log: a base est\'E1 vazia"} << endl;\par
357             arquivo_ler_log.clear();\par
358 \par
359         \}\par
360 \par
361         arquivo_ler_log >> vetor[j].quant;\par
362 \par
363         {\cf20 //cout << vetor[j].quant << endl;}\par
364         {\cf20 //cout << vetor[j].nome << endl;}\par
365         {\cf20 //system("PAUSE > null");}\par
366         arquivo_ler_log.close();\par
367     \}\par
368 \par
369 \par
370 \par
371 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.h}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Quantidade_Palavras}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b Quantidade_Palavras} {\b Ordena_Quant_Palavra}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Insercao} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Alfabetica} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Alfabetica} ({\b Hash} tabela, char *nome_palavra)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Quantidade_Palavras} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b recupera_numero_Palavras} ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Ordena_Vetor_Quantidade_Palavra} ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Apresenta_Vetor_Quantidade_Palavra} ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es dos tipos\par
\pard\plain 
{\xe \v Ordena_Quant_Palavra\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:Ordena_Quant_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b Quantidade_Palavras} {\b Ordena_Quant_Palavra}}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de consulta de palavras em rela\'E7\'E3o ao sistema de arquivos \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Apresenta_Vetor_Quantidade_Palavra\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:Apresenta_Vetor_Quantidade_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apresenta_Vetor_Quantidade_Palavra ({\b Ordena_Quant_Palavra} * vetor, int Numero_Palavra_Arquivo_Log)}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 396 \{\par
397 \par
398 \par
399 \par
400     {\cf19 for}({\cf18 int} j = Numero_Palavra_Arquivo_Log - 1; j >= 0; j--)\par
401     \{\par
402         cout << {\cf22 "-"} << vetor[j].nome << {\cf22 " "} << vetor[j].quant << endl;\par
403 \par
404     \}\par
405 \par
406 \par
407 \par
408 \}\par
}
}
{\xe \v Consulta_Base_Alfabetica\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:Consulta_Base_Alfabetica}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Alfabetica ()}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 56 \{\par
57     {\cf18 char} nome[TAMANHO_DA_PALAVRA][TAMANHO_DO_CONTROLE];\par
58     {\cf18 int} i = 0;\par
59     ifstream arquivo_ler;\par
60     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
61     {\cf19 if}(!arquivo_ler.is_open())\par
62     \{\par
63        cout << {\cf22 "O banco de arquivo est\'E1 vazio, n\'E3o h\'E1 o que apresentar."} << endl;\par
64        {\cf20 //arquivo_ler.clear();}\par
65        {\cf19 return} 0;\par
66     \}\par
67     {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
68     \{\par
69         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 arquivos no banco de arquivos para ser apresentado."} << endl;\par
70         {\cf19 return} 0;\par
71         {\cf20 //system("PAUSE > null");}\par
72     \}\par
73     {\cf19 else}\par
74     \{\par
75         {\cf19 while}(! arquivo_ler.eof())\par
76         \{\par
77             arquivo_ler >> nome[i];\par
78             i++;\par
79         \}\par
80 \par
81         arquivo_ler.close();\par
82 \par
83         {\cf18 char} aux[TAMANHO_DA_PALAVRA];\par
84 \par
85         {\cf19 for}({\cf18 int} r = 0; r < i; r++)              {\cf20 // ordenando os arquivos tendo como base a ordem alfab\'E9tica}\par
86         \{\par
87             {\cf19 for}({\cf18 int} s = r+1; s < i; s++)\par
88             \{\par
89                 {\cf19 if} (strcmp(nome[r],nome[s])>0)\par
90                     \{\par
91                        strcpy(aux,nome[s]);\par
92                        strcpy(nome[s],nome[r]);\par
93                        strcpy(nome[r], aux);\par
94                     \}\par
95             \}\par
96 \par
97         \}\par
98 \par
99 \par
100         {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
101         \{\par
102                 cout << {\cf22 "-"} << nome[j] << endl;\par
103         \}\par
104 \par
105     \}\par
106 \par
107 \par
108 \}\par
}
}
{\xe \v Consulta_Base_Alfabetica\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:Consulta_Base_Alfabetica}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Alfabetica ({\b Hash} tabela, char * nome_palavra)}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 112 \{\par
113 \par
114 \par
115     {\cf18 int} contador_linhas = 0, linha_correta_atual = 0;\par
116 \par
117     {\cf18 char} nome_palavra[TAMANHO_DA_PALAVRA];\par
118     strcpy(nome_palavra, nome);\par
119     strupr(nome_palavra);\par
120 \par
121     {\cf18 int} pos = hash_funcao(nome_palavra);\par
122     {\cf18 char} linha[TAMANHO_DA_FRASE];\par
123     Dados *aux1, *aux2, *aux3, *aux4, *aux5, *aux6;\par
124     aux1 = tabela[pos];\par
125     aux2 = tabela[pos]->prox;\par
126 \par
127     cout << tabela[pos]->Arquivo << endl;\par
128     cout << tabela[pos]->prox->Arquivo << endl;\par
129     cout << tabela[pos]->prox->prox->Arquivo << endl <<endl;\par
130     cout << aux1->Arquivo << endl;\par
131     cout << aux2->Arquivo << endl <<endl;\par
132 \par
133     system({\cf22 "PAUSE > null"});\par
134     {\cf19 while}(aux1->prox != NULL)\par
135     \{\par
136 \par
137 \par
138         {\cf19 while}(aux2 != NULL)\par
139         \{\par
140 \par
141             cout << tabela[pos]->Arquivo << endl;\par
142             cout << tabela[pos]->prox->Arquivo << endl;\par
143             cout << tabela[pos]->prox->prox->Arquivo << endl <<endl;\par
144             cout << aux1->Arquivo << endl;\par
145             cout << aux2->Arquivo << endl <<endl;\par
146 \par
147 \par
148 \par
149             {\cf19 if}(strcmp(aux1->Arquivo, aux2->Arquivo) > 0)\par
150             \{\par
151 \par
152 \par
153                 {\cf19 if}(aux1->prox == aux2)\par
154                 \{\par
155                     {\cf19 if}(aux1->ant == NULL && aux2->prox == NULL)\par
156                     \{\par
157 \par
158                         cout<< {\cf22 "kl\'E7sda"} << endl;\par
159                         system({\cf22 "PAUSE > null"});\par
160                         aux3->prox = aux2;\par
161 \par
162 \par
163 \par
164 \par
165                     \}\par
166                     {\cf19 else} {\cf19 if}(aux1->ant == NULL && aux2->prox != NULL)\par
167                     \{\par
168 \par
169 \par
170 \par
171                         {\cf20 //aux3 = aux1->ant; = \'E9 NULL;}\par
172                         aux3 = aux2->prox;\par
173                         aux3->ant = aux1;\par
174                         aux1->prox  = aux3;\par
175                         aux2->prox = aux1;\par
176                         aux2->ant = NULL;\par
177 \par
178 \par
179                     \}\par
180                     {\cf19 else} {\cf19 if}(aux1->ant != NULL && aux2->prox == NULL)\par
181                     \{\par
182 \par
183 \par
184                         aux3 = aux1->prox;\par
185                         aux4 = aux1->ant;\par
186 \par
187                         aux5 = aux2->prox;     {\cf20 //NULL}\par
188                         aux6 = aux2->ant;\par
189 \par
190                         aux6->prox = aux1;\par
191                         aux1->prox = NULL;\par
192                         aux1->ant = aux6;\par
193 \par
194                         aux3->ant = aux2;\par
195                         aux4->prox = aux2;\par
196                         aux2->prox = aux3;\par
197                         aux2->ant = aux4;\par
198 \par
199                     \}\par
200                     {\cf19 else}\par
201                     \{\par
202 \par
203                         aux3 = aux1->prox;\par
204                         aux4 = aux1->ant;\par
205 \par
206                         aux5 = aux2->prox;     {\cf20 //NULL}\par
207                         aux6 = aux2->ant;\par
208 \par
209 \par
210                         aux6->prox = aux1;\par
211                         aux5->ant  = aux1;\par
212                         aux1->prox = aux5;\par
213                         aux2->ant  = aux6;\par
214 \par
215                         aux3->ant = aux2;\par
216                         aux4->prox = aux2;\par
217                         aux2->prox = aux3;\par
218                         aux2->ant = aux4;\par
219                     \}\par
220 \par
221                 \}\par
222                 {\cf19 else}\par
223                 \{\par
224                     {\cf19 if}(aux1->ant == NULL && aux2->prox == NULL)\par
225                     \{\par
226 \par
227                         cout<< {\cf22 "kl\'E7sda"} << endl;\par
228                         system({\cf22 "PAUSE > null"});\par
229 \par
230                         aux3 = aux1->prox;\par
231                         aux4 = aux1->ant;   {\cf20 //NULL}\par
232 \par
233                         aux5 = aux2->prox;  {\cf20 //NULL}\par
234                         aux6 = aux2->ant;\par
235 \par
236                         aux6->prox = aux1;\par
237                         aux1->ant = aux6;\par
238                         aux1->prox = NULL;\par
239 \par
240                         aux3->ant = aux2;\par
241                         aux2->prox = aux3;\par
242                         aux2->ant = NULL;\par
243                     \}\par
244                     {\cf19 else} {\cf19 if}(aux1->ant == NULL && aux2->prox != NULL)\par
245                     \{\par
246 \par
247 \par
248 \par
249                         aux3 = aux1->prox;\par
250                         aux4 = aux1->ant;   {\cf20 //NULL}\par
251 \par
252                         aux5 = aux2->prox;\par
253                         aux6 = aux2->ant;\par
254 \par
255                         aux3->ant = aux2;\par
256                         aux2->ant = NULL;\par
257                         aux2->prox = aux3;\par
258 \par
259 \par
260 \par
261 \par
262 \par
263                         aux1->prox = aux5;\par
264                         aux1->ant  = aux6;\par
265                         aux6->prox = aux1;\par
266                         aux5->ant  = aux1;\par
267 \par
268 \par
269                     \}\par
270                     {\cf19 else} {\cf19 if}(aux1->ant != NULL && aux2->prox == NULL)\par
271                     \{\par
272 \par
273 \par
274                         aux3 = aux1->prox;\par
275                         aux4 = aux1->ant;\par
276 \par
277                         aux5 = aux2->prox;     {\cf20 //NULL}\par
278                         aux6 = aux2->ant;\par
279 \par
280                         aux6->prox = aux1;\par
281                         aux1->prox = NULL;\par
282                         aux1->ant = aux6;\par
283 \par
284                         aux3->ant = aux2;\par
285                         aux4->prox = aux2;\par
286                         aux2->prox = aux3;\par
287                         aux2->ant = aux4;\par
288 \par
289                     \}\par
290                     {\cf19 else}\par
291                     \{\par
292 \par
293                         aux3 = aux1->prox;\par
294                         aux4 = aux1->ant;\par
295 \par
296                         aux5 = aux2->prox;     {\cf20 //NULL}\par
297                         aux6 = aux2->ant;\par
298 \par
299 \par
300                         aux6->prox = aux1;\par
301                         aux5->ant  = aux1;\par
302                         aux1->prox = aux5;\par
303                         aux2->ant  = aux6;\par
304 \par
305                         aux3->ant = aux2;\par
306                         aux4->prox = aux2;\par
307                         aux2->prox = aux3;\par
308                         aux2->ant = aux4;\par
309                     \}\par
310 \par
311             cout << tabela[pos]->Arquivo << endl;\par
312             cout << tabela[pos]->prox->Arquivo << endl;\par
313             cout << tabela[pos]->prox->prox->Arquivo << endl <<endl;\par
314             cout << aux1->Arquivo << endl;\par
315             cout << aux2->Arquivo << endl <<endl;\par
316 \par
317 \par
318                 \}\par
319 \par
320             \}\par
321 \par
322 \par
323             aux2 = aux2->prox;\par
324 \par
325         \}\par
326 \par
327         aux1 = aux1->prox;\par
328         aux2 = aux1->prox;\par
329 \par
330 \par
331     \}\par
332 \par
333 \}\par
}
}
{\xe \v Consulta_Base_Insercao\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:Consulta_Base_Insercao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Insercao ()}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de consulta de palavras em rela\'E7\'E3o ao sistema de arquivos \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19 \{\par
20     {\cf18 char} nome[TAMANHO_DA_PALAVRA][TAMANHO_DO_CONTROLE];\par
21     {\cf18 int} i = 0;\par
22     ifstream arquivo_ler;\par
23     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
24     {\cf19 if}(!arquivo_ler.is_open())\par
25     \{\par
26        cout << {\cf22 "O banco de arquivo est\'E1 vazio, n\'E3o h\'E1 o que apresentar."} << endl;\par
27        arquivo_ler.clear();\par
28        {\cf19 return} 0;\par
29     \}\par
30     {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
31     \{\par
32         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 arquivos no banco de arquivos para ser apresentado."} << endl;\par
33         {\cf19 return} 0;\par
34     \}\par
35     {\cf19 else}\par
36     \{\par
37         {\cf19 while}(! arquivo_ler.eof())\par
38         \{\par
39             arquivo_ler >> nome[i];\par
40             i++;\par
41         \}\par
42 \par
43     arquivo_ler.close();\par
44 \par
45     {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
46     \{\par
47         cout << {\cf22 "-"} << nome[j] << endl;\par
48     \}\par
49 \par
50     \}\par
51 \par
52 \par
53 \}\par
}
}
{\xe \v Consulta_Base_Quantidade_Palavras\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:Consulta_Base_Quantidade_Palavras}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Quantidade_Palavras ()}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 411 \{\par
412 \par
413 \par
414     Ordena_Quant_Palavra vetor[TAMANHO_DO_CONTROLE];\par
415     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
416 \par
417     {\cf18 int} i = 0;\par
418     ifstream arquivo_ler;\par
419     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
420     {\cf19 if}(!arquivo_ler.is_open())\par
421     \{\par
422         cout << {\cf22 "O banco de arquivo est\'E1 vazio, n\'E3o h\'E1 o que apresentar."} << endl;\par
423         arquivo_ler.clear();\par
424         {\cf19 return} 0;\par
425     \}\par
426     {\cf20 /*}\par
427 {\cf20     else if(is_empty(arquivo_ler))}\par
428 {\cf20     \{}\par
429 {\cf20         cout << "arquivo vazio, n\'E3o h\'E1 o que remover." << endl;}\par
430 {\cf20         system("PAUSE > null");}\par
431 {\cf20     \}}\par
432 {\cf20     */}\par
433     {\cf19 else}\par
434     \{\par
435 \par
436         {\cf19 while}(! arquivo_ler.eof())\par
437         \{\par
438             arquivo_ler >> nome;{\cf20 // abrindo arquivo  com dados do arquivo}\par
439             strcpy(vetor[i].nome, nome);\par
440             {\cf20 //cout << i << endl;}\par
441             i++;\par
442 \par
443         \}\par
444     \}\par
445 \par
446 \par
447 \par
448 arquivo_ler.close();\par
449 \par
450 \par
451 \par
452 \par
453 {\cf20 //cout << "nijlads" << endl;}\par
454 {\cf20 //system("PAUSE > null");}\par
455 \par
456 func funcoes;           {\cf20 // exemplo de ponteiro de fun\'E7\'E3o - usado para facilitar o manuseio das etapas necess\'E1rias a apresenta\'E7\'E3o dos arquivos ordenados por quantidade de palavras}\par
457 \par
458 funcoes = recupera_numero_Palavras;\par
459 funcoes(vetor, i);\par
460 \par
461 funcoes = Ordena_Vetor_Quantidade_Palavra;\par
462 funcoes(vetor, i);\par
463 \par
464 funcoes = Apresenta_Vetor_Quantidade_Palavra;\par
465 funcoes(vetor, i);\par
466 \par
467 \par
468 \par
469 \par
470 \par
471 \par
472 \par
473 \par
474 \par
475 \}\par
}
}
{\xe \v Ordena_Vetor_Quantidade_Palavra\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:Ordena_Vetor_Quantidade_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Ordena_Vetor_Quantidade_Palavra ({\b Ordena_Quant_Palavra} * vetor, int Numero_Palavra_Arquivo_Log)}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 374 \{\par
375     Ordena_Quant_Palavra aux[1];\par
376 \par
377     {\cf20 //cout << i<< "dasds" << endl;}\par
378     {\cf20 //system("PAUSE > null");}\par
379 \par
380     {\cf19 for}({\cf18 int} r = 0; r < Numero_Palavra_Arquivo_Log; r++)          {\cf20 //ordenando tendo como base a quantidade de  palavras (descescente}\par
381     \{\par
382         {\cf19 for}({\cf18 int} s = r+1; s < Numero_Palavra_Arquivo_Log; s++)\par
383         \{\par
384             {\cf19 if} (vetor[r].quant > vetor[s].quant)\par
385                 \{\par
386                     aux[0] = vetor[r];\par
387                     vetor[r]= vetor[s];\par
388                     vetor[s] = aux[0];\par
389                 \}\par
390         \}\par
391 \par
392     \}\par
393 \par
394 \}\par
}
}
{\xe \v recupera_numero_Palavras\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:recupera_numero_Palavras}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void recupera_numero_Palavras ({\b Ordena_Quant_Palavra} * vetor, int Numero_Palavra_Arquivo_Log)}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 338 \{\par
339 \par
340     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
341     {\cf19 for}({\cf18 int} j = 0; j < Numero_Palavra_Arquivo_Log; j++)\par
342     \{\par
343 \par
344 \par
345 \par
346         ifstream arquivo_ler_log;\par
347         strcpy(nome, vetor[j].nome);\par
348 \par
349         strcat(nome, {\cf22 "LogArq.txt"});\par
350         strupr(nome);\par
351         arquivo_ler_log.open(nome);\par
352 \par
353 \par
354         {\cf19 if}(!arquivo_ler_log.is_open())\par
355         \{\par
356             cout << {\cf22 "N\'E3o foi encontrado o arquivo de log: a base est\'E1 vazia"} << endl;\par
357             arquivo_ler_log.clear();\par
358 \par
359         \}\par
360 \par
361         arquivo_ler_log >> vetor[j].quant;\par
362 \par
363         {\cf20 //cout << vetor[j].quant << endl;}\par
364         {\cf20 //cout << vetor[j].nome << endl;}\par
365         {\cf20 //system("PAUSE > null");}\par
366         arquivo_ler_log.close();\par
367     \}\par
368 \par
369 \par
370 \par
371 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Consulta_Base_Arquivos.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef _CONSULTA_BASE_ARQUIVO_}\par
2 {\cf21 #define _CONSULTA_BASE_ARQUIVO_}\par
3 \par
8 {\cf17 typedef} {\cf17 struct }Quantidade_Palavras\par
9 \{\par
10     {\cf18 char} nome[TAMANHO_DA_PALAVRA];  {\cf20 // nome do arquivo}\par
11     {\cf18 int}  quant; {\cf20 // quantidade de palavras}\par
12 \par
13 \}Ordena_Quant_Palavra;\par
14 \par
15 {\cf18 bool} Consulta_Base_Insercao();\par
16 {\cf20 //void Consulta_Base_Insercao(); j\'E1 \'E9 o padr\'E3o}\par
17 \par
18 {\cf18 bool} Consulta_Base_Alfabetica();\par
19 {\cf18 bool} Consulta_Base_Alfabetica(Hash tabela,{\cf18 char} *nome_palavra );\par
20 {\cf18 bool} Consulta_Base_Quantidade_Palavras();\par
21 {\cf18 void} recupera_numero_Palavras(Ordena_Quant_Palavra *vetor, {\cf18 int} Numero_Palavra_Arquivo_Log);     {\cf20 // exemplo ponteiro de fun\'E7\'E3o}\par
22 {\cf18 void} Ordena_Vetor_Quantidade_Palavra(Ordena_Quant_Palavra *vetor, {\cf18 int} Numero_Palavra_Arquivo_Log);\par
23 {\cf18 void} Apresenta_Vetor_Quantidade_Palavra(Ordena_Quant_Palavra *vetor, {\cf18 int} Numero_Palavra_Arquivo_Log);\par
24 \par
25 \par
26 {\cf21 #endif }{\cf20 // _TESTE_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.cpp}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.cpp}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "teste.h"}\par
{\f2 #include "consulta_palavra.h"}\par
{\f2 #include "Consulta_Base_Arquivos.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Hash_Recupera} ({\b Hash} tab)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Apresentar_Lista_Frase} ({\b Hash} tabela, char *nome)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Apresentar_Lista_Frase} ({\b Hash} tabela, int pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inserir_Lista_Palavra} ({\b Hash} tabela, int pos, char nome[{\b TAMANHO_DA_PALAVRA}], char palavra[{\b TAMANHO_DA_PALAVRA}], int quant, int total_com_repeticao, int vetor[])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b recupera_palavras_arquivo} (char nome[{\b TAMANHO_DA_PALAVRA}], char palavra[{\b TAMANHO_DA_PALAVRA}], {\b Hash} tabela)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Consulta_Palavra} (char *nome_palavra, {\b Hash} tab)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Apresentar_Lista_Frase\:consulta_palavra.cpp}
{\xe \v consulta_palavra.cpp\:Apresentar_Lista_Frase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apresentar_Lista_Frase ({\b Hash} tabela, char * nome)}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31 \{\par
32 \par
33     {\cf18 int} contador_linhas = 0, linha_correta_atual = 0;\par
34 \par
35     {\cf18 char} nome_palavra[TAMANHO_DA_PALAVRA];\par
36     strcpy(nome_palavra, nome);\par
37     strupr(nome_palavra);\par
38 \par
39     {\cf18 int} pos = hash_funcao(nome_palavra);\par
40     {\cf18 char} linha[TAMANHO_DA_FRASE];\par
41     Dados *aux;\par
42     aux = tabela[pos];\par
43 \par
44 \par
45     {\cf20 /*}\par
46 {\cf20     cout << aux->prox->quantidade << endl;}\par
47 {\cf20     cout << aux->prox->prox->quantidade << endl;}\par
48 {\cf20     cout << aux->prox->prox->prox->quantidade << endl;}\par
49 {\cf20     */}\par
50     {\cf19 while}(aux != NULL)\par
51     \{\par
52 \par
53         ifstream arquivo_ler;\par
54         arquivo_ler.open(aux->Arquivo);\par
55         {\cf19 if}(!arquivo_ler.is_open())\par
56         \{\par
57            cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que consultar."} << endl;\par
58            arquivo_ler.clear();\par
59            {\cf20 //return 0;}\par
60         \}\par
61         {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
62         \{\par
63             cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que consulta."} << endl;\par
64             {\cf20 //system("PAUSE > null");}\par
65             {\cf20 //return 0;}\par
66         \}\par
67         {\cf19 else}\par
68         \{\par
69                 cout << {\cf22 "Foram encontrados "} << aux->quantidade << {\cf22 " linhas no arquivo "} << aux->Arquivo << endl;\par
70                 {\cf19 while}(! arquivo_ler.eof())\par
71                 \{\par
72                    arquivo_ler.getline(linha, TAMANHO_DA_FRASE);\par
73                     {\cf19 if}(contador_linhas == aux->linha[linha_correta_atual])\par
74                     \{\par
75 \par
76                         cout << {\cf22 "-"} << linha << endl;\par
77 \par
78                         linha_correta_atual++;\par
79 \par
80                     \}\par
81                     {\cf19 else} {\cf19 if}(linha_correta_atual == aux->quantidade)\par
82                     \{\par
83                     {\cf19 break};\par
84                     \}\par
85                     contador_linhas++;\par
86                     arquivo_ler.clear();\par
87                     {\cf20 //cout << linha_correta_atual << endl;}\par
88                     {\cf20 //cout << contador_linhas << endl;}\par
89                     {\cf20 //cout << aux[pos]->Arquivo << endl;}\par
90                     {\cf20 //cout << aux->quantidade << endl;}\par
91                     {\cf20 //system("PAUSE > null");}\par
92 \par
93 \par
94                 \}\par
95         \}\par
96 \par
97         contador_linhas = 0;\par
98         linha_correta_atual = 0;\par
99 \par
100         arquivo_ler.close();\par
101         aux = aux->prox;\par
102         cout << endl;\par
103     \}\par
104 \par
105 \par
106 \}\par
}
}
{\xe \v Apresentar_Lista_Frase\:consulta_palavra.cpp}
{\xe \v consulta_palavra.cpp\:Apresentar_Lista_Frase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apresentar_Lista_Frase ({\b Hash} tabela, int pos)}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 110 \{\par
111 \par
112     {\cf18 int} contador_linhas = 0, linha_correta_atual = 0;\par
113 \par
114     {\cf18 char} linha[TAMANHO_DA_FRASE];\par
115     Dados *aux;\par
116     aux = tabela[pos];\par
117 \par
118 cout << tabela[0]->quantidade << {\cf22 "kmsa\'E7"} << endl;\par
119 cout << tabela[0]->Arquivo << {\cf22 "kmsa\'E7"} << endl;\par
120 cout << tabela[0]->linha[tabela[0]->quantidade - 1] << {\cf22 "kmsa\'E7"} << endl;\par
121 \par
122     {\cf20 /*}\par
123 {\cf20     cout << aux->prox->quantidade << endl;}\par
124 {\cf20     cout << aux->prox->prox->quantidade << endl;}\par
125 {\cf20     cout << aux->prox->prox->prox->quantidade << endl;}\par
126 {\cf20     */}\par
127     {\cf19 while}(aux != NULL)\par
128     \{\par
129 \par
130         ifstream arquivo_ler;\par
131         arquivo_ler.open(aux->Arquivo);\par
132         {\cf19 if}(!arquivo_ler.is_open())\par
133         \{\par
134            cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que consultar."} << endl;\par
135            arquivo_ler.clear();\par
136            {\cf20 //return 0;}\par
137         \}\par
138         {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
139         \{\par
140             cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que consulta."} << endl;\par
141             {\cf20 //system("PAUSE > null");}\par
142             {\cf20 //return 0;}\par
143         \}\par
144         {\cf19 else}\par
145         \{\par
146                 cout << {\cf22 "Foram encontrados "} << aux->quantidade << {\cf22 " linhas no arquivo "} << aux->Arquivo << endl;\par
147                 {\cf19 while}(! arquivo_ler.eof())\par
148                 \{\par
149                    arquivo_ler.getline(linha, TAMANHO_DA_FRASE);\par
150                     {\cf19 if}(contador_linhas == aux->linha[linha_correta_atual])\par
151                     \{\par
152 \par
153                         cout << {\cf22 "-"} << linha << endl;\par
154 \par
155                         linha_correta_atual++;\par
156 \par
157                     \}\par
158                     {\cf19 else} {\cf19 if}(linha_correta_atual == aux->quantidade)\par
159                     \{\par
160                     {\cf19 break};\par
161                     \}\par
162                     contador_linhas++;\par
163                     arquivo_ler.clear();\par
164                     {\cf20 //cout << linha_correta_atual << endl;}\par
165                     {\cf20 //cout << contador_linhas << endl;}\par
166                     {\cf20 //cout << aux[pos]->Arquivo << endl;}\par
167                     {\cf20 //cout << aux->quantidade << endl;}\par
168                     {\cf20 //system("PAUSE > null");}\par
169 \par
170 \par
171                 \}\par
172         \}\par
173 \par
174         contador_linhas = 0;\par
175         linha_correta_atual = 0;\par
176 \par
177         arquivo_ler.close();\par
178         aux = aux->prox;\par
179         cout << endl;\par
180     \}\par
181 \par
182 \par
183 \}\par
}
}
{\xe \v Consulta_Palavra\:consulta_palavra.cpp}
{\xe \v consulta_palavra.cpp\:Consulta_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Consulta_Palavra (char * nome_palavra, {\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de apresenta\'E7\'E3o das frases em que se encontram as palavras do sistema de arquivos \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 355 \{\par
356     {\cf20 //Hash tab;}\par
357     {\cf18 int} i = 0;\par
358     {\cf18 char} nome[TAMANHO_DO_CONTROLE][TAMANHO_DA_PALAVRA];\par
359     {\cf18 char} nomeses[TAMANHO_DA_PALAVRA];\par
360     {\cf20 //Inicializar_Hash_Recupera(tab);}\par
361 \par
362     ifstream arquivo_ler;\par
363     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
364     {\cf19 if}(!arquivo_ler.is_open())\par
365     \{\par
366        cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que consultar."} << endl;\par
367        arquivo_ler.clear();\par
368        {\cf20 //return 0;}\par
369     \}\par
370 \par
371     {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
372     \{\par
373         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que consultar."} << endl;\par
374         {\cf20 //system("PAUSE > null");}\par
375         {\cf20 //return 0;}\par
376     \}\par
377     {\cf19 else}\par
378     \{\par
379 \par
380         {\cf19 while}(! arquivo_ler.eof())      {\cf20 //Armazena os nomes do arquivo num vetor tempor\'E1rio}\par
381         \{\par
382 \par
383 \par
384                 arquivo_ler >> nome[i];\par
385                 {\cf20 /*cout << nome[i] << endl;}\par
386 {\cf20                 cout << "cfscasmdksa" <<endl;}\par
387 {\cf20                 system("PAUSE > null");}\par
388 {\cf20                 */}\par
389                 i++;\par
390         \}\par
391         arquivo_ler.close();\par
392 \par
393         {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
394         \{\par
395 \par
396             recupera_palavras_arquivo(nome[j], nome_palavra, tab);\par
397             {\cf20 //cout << "cfscasmdksa" <<endl;}\par
398             {\cf20 //system("PAUSE > null");}\par
399         \}\par
400         strcpy(nomeses, nome_palavra);\par
401         {\cf18 int} pos = hash_funcao(nomeses);\par
402         {\cf20 //cout << tab[pos]->quantidade << endl;}\par
403         {\cf20 //Consulta_Base_Alfabetica(tab, nome_palavra);}\par
404         {\cf20 //Apresentar_Lista_Frase(tab, nome_palavra);}\par
405 \par
406 \par
407 \par
408 \par
409     \}\par
410 \par
411 \par
412 \par
413 \par
414 \par
415 \par
416 \par
417 \}\par
}
}
{\xe \v Inicializar_Hash_Recupera\:consulta_palavra.cpp}
{\xe \v consulta_palavra.cpp\:Inicializar_Hash_Recupera}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Hash_Recupera ({\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de apresenta\'E7\'E3o das frases em que se encontram as palavras do sistema de arquivos \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18 \{\par
19     {\cf20 //tab[40]->quantidade = 100;}\par
20     {\cf20 //cout << tab[40]->quantidade << endl;}\par
21 \par
22 {\cf18 int} i;\par
23 {\cf19 for}(i = 0; i < TAMANHO; i++)\par
24 \{\par
25 tab[i] = NULL;\par
26 \}\par
27 \par
28 \}\par
}
}
{\xe \v Inserir_Lista_Palavra\:consulta_palavra.cpp}
{\xe \v consulta_palavra.cpp\:Inserir_Lista_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inserir_Lista_Palavra ({\b Hash} tabela, int pos, char nome[TAMANHO_DA_PALAVRA], char palavra[TAMANHO_DA_PALAVRA], int quant, int total_com_repeticao, int vetor[])}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 186 \{\par
187 \par
188     {\cf20 //cout << "kls\'E7da" << quant << endl;}\par
189     Dados *novo = (Dados*) {\cf17 new} Dados;\par
190     Dados *aux2, *aux;\par
191 \par
192     {\cf19 if}(tabela[pos] == NULL)\par
193     \{\par
194     strcpy(novo->Arquivo, nome);\par
195     strcpy(novo->Palavra, palavra);\par
196     novo->quantidade = quant;\par
197     novo->prox = NULL;\par
198     novo->ant = NULL;\par
199     novo->quantidade = quant;\par
200     novo->total_de_vezes_palavra = total_com_repeticao;\par
201     {\cf19 for}({\cf18 int} i = 0; i < quant; i++)\par
202     \{\par
203         novo->linha[i] = vetor[i];\par
204     \}\par
205     tabela[pos] = novo;\par
206     \}\par
207     {\cf19 else}\par
208     \{\par
209     {\cf20 //cout << tabela[pos]->quantidade << endl;}\par
210     {\cf20 //system("PAUSE > null");}\par
211 \par
212 \par
213         aux = tabela[pos];\par
214         aux2 = NULL;\par
215         {\cf19 while}(aux != NULL)\par
216         \{\par
217             aux2 = aux;\par
218             aux = aux->prox;\par
219         \}\par
220 \par
221         novo->total_de_vezes_palavra = total_com_repeticao;\par
222         novo->quantidade = quant;\par
223         {\cf19 for}({\cf18 int} i = 0; i < quant; i++)\par
224         \{\par
225             novo->linha[i] = vetor[i];\par
226         \}\par
227         strcpy(novo->Arquivo, nome);\par
228         strcpy(novo->Palavra, palavra);\par
229 \par
230         aux2->prox = novo;\par
231         novo->ant = aux2;\par
232         novo->prox = NULL;\par
233     \}\par
234 \par
235 \}\par
}
}
{\xe \v recupera_palavras_arquivo\:consulta_palavra.cpp}
{\xe \v consulta_palavra.cpp\:recupera_palavras_arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool recupera_palavras_arquivo (char nome[TAMANHO_DA_PALAVRA], char palavra[TAMANHO_DA_PALAVRA], {\b Hash} tabela)}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 240 \{\par
241 \par
242 \par
243     {\cf18 char}  v[TAMANHO_VETOR_TEMPORARIO], ve[TAMANHO_DA_PALAVRA];      {\cf20 // ver se o arquivo est\'E1 no banco}\par
244     {\cf18 int} i =0, r = 0, j = 0;\par
245 \par
246     ifstream arquivo_ler_principal;\par
247 \par
248     arquivo_ler_principal.open(nome);\par
249 \par
250     {\cf19 if}(!arquivo_ler_principal.is_open())\par
251     \{\par
252         cout << {\cf22 "N\'E3o foi encontrado o arquivo: cjhgfcft"} << endl;\par
253         arquivo_ler_principal.clear();\par
254         {\cf19 return} 0;\par
255     \}\par
256 \par
257     arquivo_ler_principal.close();\par
258 \par
259 \par
260     {\cf18 char} nome_arquivo[TAMANHO_DA_PALAVRA];\par
261     strcpy(nome_arquivo, nome);\par
262     strcat(nome_arquivo,{\cf22 "LogPal.txt"});\par
263 \par
264     {\cf18 char} nome_palavra[TAMANHO_DA_PALAVRA];\par
265     strcpy(nome_palavra, palavra);\par
266     strupr(nome_palavra);\par
267 \par
268 \par
269     ifstream arquivo_ler;\par
270 \par
271     arquivo_ler.open(nome_arquivo);\par
272 \par
273 \par
274 \par
275     {\cf19 if}(!arquivo_ler.is_open())\par
276     \{\par
277         cout << {\cf22 "N\'E3o foi encontrado o arquivo:"} << endl;\par
278         arquivo_ler.clear();\par
279         {\cf19 return} 0;\par
280     \}\par
281     {\cf19 else}\par
282     \{\par
283         {\cf19 while}(! arquivo_ler.eof())\par
284         \{\par
285 \par
286             v[i]  = arquivo_ler.get();\par
287             ve[r] = v[i];\par
288             r++;\par
289 \par
290 \par
291 \par
292             {\cf19 if}(v[i] == {\cf23 ' '} || v[i] == {\cf23 '\\n'})\par
293             \{\par
294 \par
295 \par
296                 ve[r] = {\cf23 '\\0'};\par
297                 ve[r - 1] = {\cf23 '\\0'};\par
298                 {\cf18 int} j = 0;\par
299 \par
300 \par
301                 {\cf19 if}(strcmp(nome_palavra, ve) == 0)       {\cf20 //BUSCA SEQUENCIAL DENTRO DO ARQUIVO NA QUAL SE PROCURA  A PALAVRA. ENCONTRANDO ARMAZENA-SE OS VALORES DE QUANTIDADE DE LINHAS E POSI\'C7\'D5ES DA MESMA}\par
302                 \{\par
303 \par
304                 {\cf18 int} pos = hash_funcao(nome_palavra);\par
305                 {\cf20 /*if(strcmp(tabela[pos]->Palavra, palavra) != 0 && tabela[pos]->livre == false)}\par
306 {\cf20                 \{}\par
307 {\cf20                    //pos = colisao_funcao(tabela, pos);}\par
308 {\cf20                 \}}\par
309 {\cf20                 */}\par
310                 {\cf20 //cout << "palavra encontrada" <<endl;}\par
311                 {\cf18 int} c, d;\par
312 \par
313                 arquivo_ler >> c;\par
314                 d = c;\par
315                 {\cf18 int} vetor[c];\par
316 \par
317                 {\cf19 for}({\cf18 int} j = 0; j < c; j++)\par
318                 \{\par
319                     arquivo_ler >> vetor[j];\par
320                     {\cf19 if}(vetor[j] == vetor[j-1])\par
321                     \{\par
322                         j--;\par
323                         c--;\par
324 \par
325                     \}\par
326                 \}\par
327 \par
328                 Inserir_Lista_Palavra(tabela, pos, nome, palavra, c, d, vetor);\par
329                 arquivo_ler.close();\par
330                 {\cf20 //cout << c << "quantidade de linhas" << endl;}\par
331                 {\cf19 return} {\cf17 true};\par
332                 \}\par
333                 {\cf19 else} {\cf19 if} (strcmp(nome_palavra, ve) < 0)\par
334                 \{\par
335                 cout << {\cf22 "palavra n\'E3o encontrada no arquivo: "}<< nome << endl;\par
336                 arquivo_ler.close();\par
337                 {\cf19 return} {\cf17 false};\par
338                 \}\par
339 \par
340             r = 0;\par
341 \par
342             \}\par
343 \par
344     \}\par
345 \}\par
346 \par
347 \par
348 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.h}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Consulta_Palavra} (char *nome_palavra, {\b Hash} tab)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Hash_Recupera} ({\b Hash} tabela)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b recupera_palavras_arquivo} (char *nome, char *palavra, {\b Hash} tabela)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inserir_Lista_Palavra} ({\b Hash} tabela, int pos, char nome[{\b TAMANHO_DA_PALAVRA}], char palavra[{\b TAMANHO_DA_PALAVRA}], int quant, int total_com_repeticao, int vetor[])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Apresentar_Lista_Frase} ({\b Hash} tabela, char *nome)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Apresentar_Lista_Frase} ({\b Hash} tabela, int pos)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Apresentar_Lista_Frase\:consulta_palavra.h}
{\xe \v consulta_palavra.h\:Apresentar_Lista_Frase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apresentar_Lista_Frase ({\b Hash} tabela, char * nome)}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31 \{\par
32 \par
33     {\cf18 int} contador_linhas = 0, linha_correta_atual = 0;\par
34 \par
35     {\cf18 char} nome_palavra[TAMANHO_DA_PALAVRA];\par
36     strcpy(nome_palavra, nome);\par
37     strupr(nome_palavra);\par
38 \par
39     {\cf18 int} pos = hash_funcao(nome_palavra);\par
40     {\cf18 char} linha[TAMANHO_DA_FRASE];\par
41     Dados *aux;\par
42     aux = tabela[pos];\par
43 \par
44 \par
45     {\cf20 /*}\par
46 {\cf20     cout << aux->prox->quantidade << endl;}\par
47 {\cf20     cout << aux->prox->prox->quantidade << endl;}\par
48 {\cf20     cout << aux->prox->prox->prox->quantidade << endl;}\par
49 {\cf20     */}\par
50     {\cf19 while}(aux != NULL)\par
51     \{\par
52 \par
53         ifstream arquivo_ler;\par
54         arquivo_ler.open(aux->Arquivo);\par
55         {\cf19 if}(!arquivo_ler.is_open())\par
56         \{\par
57            cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que consultar."} << endl;\par
58            arquivo_ler.clear();\par
59            {\cf20 //return 0;}\par
60         \}\par
61         {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
62         \{\par
63             cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que consulta."} << endl;\par
64             {\cf20 //system("PAUSE > null");}\par
65             {\cf20 //return 0;}\par
66         \}\par
67         {\cf19 else}\par
68         \{\par
69                 cout << {\cf22 "Foram encontrados "} << aux->quantidade << {\cf22 " linhas no arquivo "} << aux->Arquivo << endl;\par
70                 {\cf19 while}(! arquivo_ler.eof())\par
71                 \{\par
72                    arquivo_ler.getline(linha, TAMANHO_DA_FRASE);\par
73                     {\cf19 if}(contador_linhas == aux->linha[linha_correta_atual])\par
74                     \{\par
75 \par
76                         cout << {\cf22 "-"} << linha << endl;\par
77 \par
78                         linha_correta_atual++;\par
79 \par
80                     \}\par
81                     {\cf19 else} {\cf19 if}(linha_correta_atual == aux->quantidade)\par
82                     \{\par
83                     {\cf19 break};\par
84                     \}\par
85                     contador_linhas++;\par
86                     arquivo_ler.clear();\par
87                     {\cf20 //cout << linha_correta_atual << endl;}\par
88                     {\cf20 //cout << contador_linhas << endl;}\par
89                     {\cf20 //cout << aux[pos]->Arquivo << endl;}\par
90                     {\cf20 //cout << aux->quantidade << endl;}\par
91                     {\cf20 //system("PAUSE > null");}\par
92 \par
93 \par
94                 \}\par
95         \}\par
96 \par
97         contador_linhas = 0;\par
98         linha_correta_atual = 0;\par
99 \par
100         arquivo_ler.close();\par
101         aux = aux->prox;\par
102         cout << endl;\par
103     \}\par
104 \par
105 \par
106 \}\par
}
}
{\xe \v Apresentar_Lista_Frase\:consulta_palavra.h}
{\xe \v consulta_palavra.h\:Apresentar_Lista_Frase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apresentar_Lista_Frase ({\b Hash} tabela, int pos)}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 110 \{\par
111 \par
112     {\cf18 int} contador_linhas = 0, linha_correta_atual = 0;\par
113 \par
114     {\cf18 char} linha[TAMANHO_DA_FRASE];\par
115     Dados *aux;\par
116     aux = tabela[pos];\par
117 \par
118 cout << tabela[0]->quantidade << {\cf22 "kmsa\'E7"} << endl;\par
119 cout << tabela[0]->Arquivo << {\cf22 "kmsa\'E7"} << endl;\par
120 cout << tabela[0]->linha[tabela[0]->quantidade - 1] << {\cf22 "kmsa\'E7"} << endl;\par
121 \par
122     {\cf20 /*}\par
123 {\cf20     cout << aux->prox->quantidade << endl;}\par
124 {\cf20     cout << aux->prox->prox->quantidade << endl;}\par
125 {\cf20     cout << aux->prox->prox->prox->quantidade << endl;}\par
126 {\cf20     */}\par
127     {\cf19 while}(aux != NULL)\par
128     \{\par
129 \par
130         ifstream arquivo_ler;\par
131         arquivo_ler.open(aux->Arquivo);\par
132         {\cf19 if}(!arquivo_ler.is_open())\par
133         \{\par
134            cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que consultar."} << endl;\par
135            arquivo_ler.clear();\par
136            {\cf20 //return 0;}\par
137         \}\par
138         {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
139         \{\par
140             cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que consulta."} << endl;\par
141             {\cf20 //system("PAUSE > null");}\par
142             {\cf20 //return 0;}\par
143         \}\par
144         {\cf19 else}\par
145         \{\par
146                 cout << {\cf22 "Foram encontrados "} << aux->quantidade << {\cf22 " linhas no arquivo "} << aux->Arquivo << endl;\par
147                 {\cf19 while}(! arquivo_ler.eof())\par
148                 \{\par
149                    arquivo_ler.getline(linha, TAMANHO_DA_FRASE);\par
150                     {\cf19 if}(contador_linhas == aux->linha[linha_correta_atual])\par
151                     \{\par
152 \par
153                         cout << {\cf22 "-"} << linha << endl;\par
154 \par
155                         linha_correta_atual++;\par
156 \par
157                     \}\par
158                     {\cf19 else} {\cf19 if}(linha_correta_atual == aux->quantidade)\par
159                     \{\par
160                     {\cf19 break};\par
161                     \}\par
162                     contador_linhas++;\par
163                     arquivo_ler.clear();\par
164                     {\cf20 //cout << linha_correta_atual << endl;}\par
165                     {\cf20 //cout << contador_linhas << endl;}\par
166                     {\cf20 //cout << aux[pos]->Arquivo << endl;}\par
167                     {\cf20 //cout << aux->quantidade << endl;}\par
168                     {\cf20 //system("PAUSE > null");}\par
169 \par
170 \par
171                 \}\par
172         \}\par
173 \par
174         contador_linhas = 0;\par
175         linha_correta_atual = 0;\par
176 \par
177         arquivo_ler.close();\par
178         aux = aux->prox;\par
179         cout << endl;\par
180     \}\par
181 \par
182 \par
183 \}\par
}
}
{\xe \v Consulta_Palavra\:consulta_palavra.h}
{\xe \v consulta_palavra.h\:Consulta_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Consulta_Palavra (char * nome_palavra, {\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de apresenta\'E7\'E3o das frases em que se encontram as palavras do sistema de arquivos \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 355 \{\par
356     {\cf20 //Hash tab;}\par
357     {\cf18 int} i = 0;\par
358     {\cf18 char} nome[TAMANHO_DO_CONTROLE][TAMANHO_DA_PALAVRA];\par
359     {\cf18 char} nomeses[TAMANHO_DA_PALAVRA];\par
360     {\cf20 //Inicializar_Hash_Recupera(tab);}\par
361 \par
362     ifstream arquivo_ler;\par
363     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
364     {\cf19 if}(!arquivo_ler.is_open())\par
365     \{\par
366        cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que consultar."} << endl;\par
367        arquivo_ler.clear();\par
368        {\cf20 //return 0;}\par
369     \}\par
370 \par
371     {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
372     \{\par
373         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que consultar."} << endl;\par
374         {\cf20 //system("PAUSE > null");}\par
375         {\cf20 //return 0;}\par
376     \}\par
377     {\cf19 else}\par
378     \{\par
379 \par
380         {\cf19 while}(! arquivo_ler.eof())      {\cf20 //Armazena os nomes do arquivo num vetor tempor\'E1rio}\par
381         \{\par
382 \par
383 \par
384                 arquivo_ler >> nome[i];\par
385                 {\cf20 /*cout << nome[i] << endl;}\par
386 {\cf20                 cout << "cfscasmdksa" <<endl;}\par
387 {\cf20                 system("PAUSE > null");}\par
388 {\cf20                 */}\par
389                 i++;\par
390         \}\par
391         arquivo_ler.close();\par
392 \par
393         {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
394         \{\par
395 \par
396             recupera_palavras_arquivo(nome[j], nome_palavra, tab);\par
397             {\cf20 //cout << "cfscasmdksa" <<endl;}\par
398             {\cf20 //system("PAUSE > null");}\par
399         \}\par
400         strcpy(nomeses, nome_palavra);\par
401         {\cf18 int} pos = hash_funcao(nomeses);\par
402         {\cf20 //cout << tab[pos]->quantidade << endl;}\par
403         {\cf20 //Consulta_Base_Alfabetica(tab, nome_palavra);}\par
404         {\cf20 //Apresentar_Lista_Frase(tab, nome_palavra);}\par
405 \par
406 \par
407 \par
408 \par
409     \}\par
410 \par
411 \par
412 \par
413 \par
414 \par
415 \par
416 \par
417 \}\par
}
}
{\xe \v Inicializar_Hash_Recupera\:consulta_palavra.h}
{\xe \v consulta_palavra.h\:Inicializar_Hash_Recupera}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Hash_Recupera ({\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de apresenta\'E7\'E3o das frases em que se encontram as palavras do sistema de arquivos \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18 \{\par
19     {\cf20 //tab[40]->quantidade = 100;}\par
20     {\cf20 //cout << tab[40]->quantidade << endl;}\par
21 \par
22 {\cf18 int} i;\par
23 {\cf19 for}(i = 0; i < TAMANHO; i++)\par
24 \{\par
25 tab[i] = NULL;\par
26 \}\par
27 \par
28 \}\par
}
}
{\xe \v Inserir_Lista_Palavra\:consulta_palavra.h}
{\xe \v consulta_palavra.h\:Inserir_Lista_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inserir_Lista_Palavra ({\b Hash} tabela, int pos, char nome[TAMANHO_DA_PALAVRA], char palavra[TAMANHO_DA_PALAVRA], int quant, int total_com_repeticao, int vetor[])}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 186 \{\par
187 \par
188     {\cf20 //cout << "kls\'E7da" << quant << endl;}\par
189     Dados *novo = (Dados*) {\cf17 new} Dados;\par
190     Dados *aux2, *aux;\par
191 \par
192     {\cf19 if}(tabela[pos] == NULL)\par
193     \{\par
194     strcpy(novo->Arquivo, nome);\par
195     strcpy(novo->Palavra, palavra);\par
196     novo->quantidade = quant;\par
197     novo->prox = NULL;\par
198     novo->ant = NULL;\par
199     novo->quantidade = quant;\par
200     novo->total_de_vezes_palavra = total_com_repeticao;\par
201     {\cf19 for}({\cf18 int} i = 0; i < quant; i++)\par
202     \{\par
203         novo->linha[i] = vetor[i];\par
204     \}\par
205     tabela[pos] = novo;\par
206     \}\par
207     {\cf19 else}\par
208     \{\par
209     {\cf20 //cout << tabela[pos]->quantidade << endl;}\par
210     {\cf20 //system("PAUSE > null");}\par
211 \par
212 \par
213         aux = tabela[pos];\par
214         aux2 = NULL;\par
215         {\cf19 while}(aux != NULL)\par
216         \{\par
217             aux2 = aux;\par
218             aux = aux->prox;\par
219         \}\par
220 \par
221         novo->total_de_vezes_palavra = total_com_repeticao;\par
222         novo->quantidade = quant;\par
223         {\cf19 for}({\cf18 int} i = 0; i < quant; i++)\par
224         \{\par
225             novo->linha[i] = vetor[i];\par
226         \}\par
227         strcpy(novo->Arquivo, nome);\par
228         strcpy(novo->Palavra, palavra);\par
229 \par
230         aux2->prox = novo;\par
231         novo->ant = aux2;\par
232         novo->prox = NULL;\par
233     \}\par
234 \par
235 \}\par
}
}
{\xe \v recupera_palavras_arquivo\:consulta_palavra.h}
{\xe \v consulta_palavra.h\:recupera_palavras_arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool recupera_palavras_arquivo (char * nome, char * palavra, {\b Hash} tabela)}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
consulta_palavra.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef _CONSULTA_PALAVRA_H}\par
2 {\cf21 #define _CONSULTA_PALAVRA_H}\par
3 \par
9 {\cf18 void} Consulta_Palavra({\cf18 char} *nome_palavra, Hash tab);\par
10 {\cf18 void} Inicializar_Hash_Recupera(Hash tabela);                                          {\cf20 // procedimento para consultar se determinada palavra faz parte de um arquivo}\par
11 {\cf18 bool} recupera_palavras_arquivo({\cf18 char} *nome, {\cf18 char} *palavra, Hash tabela);             {\cf20 //varre o arquivo para ver se encontra a pa\'E7avra (true se sim e false se n\'E3o)}\par
12 {\cf18 void} Inserir_Lista_Palavra(Hash tabela, {\cf18 int} pos, {\cf18 char} nome[TAMANHO_DA_PALAVRA], {\cf18 char} palavra[TAMANHO_DA_PALAVRA], {\cf18 int} quant, {\cf18 int} total_com_repeticao, {\cf18 int} vetor[]);\par
13     {\cf20 //caso encontre coloca valores na lista usando a fun\'E7\'E3o como base}\par
14 \par
15 {\cf18 void}  Apresentar_Lista_Frase(Hash tabela,{\cf18 char} *nome );\par
16 {\cf18 void}  Apresentar_Lista_Frase(Hash tabela, {\cf18 int} pos);\par
17 \par
18 \par
19 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.cpp}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.cpp}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "teste.h"}\par
{\f2 #include "escreve.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Escreve_No_Log_Controle} ({\b ARQUIVO} *arquivo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Escreve_No_Log_Arquivo} ({\b ARQUIVO} *arquivo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Escreve_No_Log_Palavra} ({\b ARQUIVO} *arquivo, {\b Tabela_Hash} tabela)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Escreve_No_Log_Arquivo\:escreve.cpp}
{\xe \v escreve.cpp\:Escreve_No_Log_Arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Escreve_No_Log_Arquivo ({\b ARQUIVO} * arquivo)}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de escrita nos logs de controle \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 108 \{\par
109     {\cf20 //cout << "scmdksa" <<endl;}\par
110     {\cf20 //system("PAUSE > null");}\par
111 \par
112     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
113 \par
114     strcpy(nome, arquivo->nome_arquivo);\par
115     strcat(nome, {\cf22 "LogArq.txt"});\par
116     strupr(nome);\par
117 \par
118     ofstream arquivo_escrever;\par
119     arquivo_escrever.open(nome);\par
120 \par
121     {\cf19 if}(!arquivo_escrever.is_open())\par
122     \{\par
123         cout << {\cf22 "N\'E3o foi encontrado o arquivo:  novo log de palavra ('nome do arquivo'LogArq.txt) para esse arquivo ser\'E1 criado."} << endl;\par
124         arquivo_escrever.clear();\par
125     \}\par
126     arquivo_escrever << arquivo->quantidade_palavras <<  {\cf22 " "};\par
127     arquivo_escrever << arquivo->quantidade_palavras_nao_repetidas <<  {\cf22 " "};\par
128     arquivo_escrever << arquivo->numero_do_arquivo <<  {\cf22 " "};\par
129     {\cf20 //cout << arquivo->quantidade_palavras << endl;}\par
130     {\cf20 //cout << "scmdksa" <<endl;}\par
131     {\cf20 //system("PAUSE > null");}\par
132 \}\par
}
}
{\xe \v Escreve_No_Log_Controle\:escreve.cpp}
{\xe \v escreve.cpp\:Escreve_No_Log_Controle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Escreve_No_Log_Controle ({\b ARQUIVO} * arquivo)}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de escrita nos logs de controle \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17 \{\par
18     {\cf18 char} nome[TAMANHO_DO_CONTROLE][TAMANHO_DA_PALAVRA];\par
19     {\cf18 int} i = 0;\par
20 \par
21 \par
22     {\cf19 for}( {\cf18 int} j = 0; j < TAMANHO_DO_CONTROLE; j++)\par
23     \{\par
24     strcpy(nome[j], {\cf22 " "});\par
25     \}\par
26 \par
27     {\cf20 /*}\par
28 {\cf20     ofstream arquivo_es;}\par
29 {\cf20     arquivo_es.open("Log_Controle.txt");}\par
30 {\cf20 }\par
31 {\cf20     if(!arquivo_es.is_open())}\par
32 {\cf20     \{}\par
33 {\cf20         cout << "N\'E3o foi encontrado o arquivo:" << endl;}\par
34 {\cf20         arquivo_es.clear();}\par
35 {\cf20         arquivo_es.open("Log_Controle.txt");}\par
36 {\cf20         arquivo_es << "       uihul " << endl;}\par
37 {\cf20     //arquivo_es.close();}\par
38 {\cf20     //return 0;}\par
39 {\cf20     \}}\par
40 {\cf20     */}\par
41 \par
42     {\cf20 //system("PAUSE > null");}\par
43     ifstream arquivo_ler;\par
44     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
45     {\cf19 if}(!arquivo_ler.is_open())\par
46     \{\par
47         cout << {\cf22 "N\'E3o foi encontrado o arquivo de controle: novo arquivo 'Log_controle.txt' ser\'E1 criado e primeiro nome de arquivo armazenado."} << endl;\par
48         arquivo_ler.close();\par
49     \}\par
50     {\cf19 if}(is_empty(arquivo_ler))\par
51     \{\par
52         arquivo_ler.close();\par
53         ofstream arquivo_escrever;\par
54         arquivo_escrever.open({\cf22 "Log_Controle.txt"});\par
55         arquivo_escrever << strupr(arquivo->nome_arquivo);\par
56 \par
57         cout << {\cf22 "arquivo inserido ao banco de arquivos com sucesso."} << endl;\par
58         {\cf20 //system("PAUSE > null");}\par
59         {\cf19 return} 0;\par
60     \}\par
61     {\cf19 else}\par
62     \{\par
63         {\cf19 while}(! arquivo_ler.eof())\par
64         \{\par
65                 arquivo_ler >> nome[i];\par
66                 {\cf20 //cout << nome[i] << endl;}\par
67                 {\cf20 //cout << arquivo->nome_arquivo<< endl;}\par
68                 {\cf20 //cout << "ljk\'E7wmafk\'E7l" << endl;}\par
69                 {\cf20 //system("PAUSE > null");}\par
70 \par
71                 {\cf19 if}(strcmp(nome[i], strupr(arquivo->nome_arquivo)) == 0)\par
72                 \{\par
73                     cout << {\cf22 "Existe um arquivo com mesmo nome no banco. Renomeie para inser\'E7\'E3o."} << endl;\par
74                     {\cf19 return} 0;\par
75                 \}\par
76                 i++;\par
77         \}\par
78     \}\par
79 \par
80     arquivo_ler.close();\par
81 \par
82     strcpy(nome[i],arquivo->nome_arquivo);\par
83     i++;\par
84     ofstream arquivo_escrever;\par
85     arquivo_escrever.open({\cf22 "Log_Controle.txt"});\par
86 \par
87     {\cf19 for}( {\cf18 int} j = 0; j < i; j++)\par
88     \{\par
89     {\cf19 if}( j == i - 1)\par
90     \{\par
91         arquivo_escrever << strupr(nome[j]) << {\cf23 '\\0'};\par
92     \}\par
93     {\cf19 else}\par
94     \{\par
95     {\cf20 //cout << nome[i] << endl;}\par
96     arquivo_escrever << strupr(nome[j]) << {\cf22 " "};\par
97     \}\par
98     \}\par
99 \par
100     cout << {\cf22 "arquivo inserido ao banco de arquivos com sucesso."} << endl;\par
101     {\cf20 //cout << "scmdksa" <<endl;}\par
102     {\cf20 //system("PAUSE > null");}\par
103 {\cf19 return} 0;\par
104 \par
105 \}\par
}
}
{\xe \v Escreve_No_Log_Palavra\:escreve.cpp}
{\xe \v escreve.cpp\:Escreve_No_Log_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Escreve_No_Log_Palavra ({\b ARQUIVO} * arquivo, {\b Tabela_Hash} tabela)}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 135 \{\par
136 \par
137     {\cf20 //system("PAUSE > null");}\par
138 \par
139     {\cf18 char} nome[30];\par
140     ofstream arquivo_escrever;\par
141     strcpy(nome, arquivo->nome_arquivo);\par
142     strcat(nome, {\cf22 "LogPal.txt"});\par
143     strupr(nome);\par
144     {\cf20 //cout << arquivo->nome_arquivo << endl;}\par
145     {\cf20 //cout << nome << endl;}\par
146 \par
147     arquivo_escrever.open(nome);\par
148 \par
149     {\cf19 if}(!arquivo_escrever.is_open())\par
150     \{\par
151         cout << {\cf22 "N\'E3o foi encontrado o arquivo: novo log de palavra ('nome do arquivo'LogPal.txt) para esse arquivo ser\'E1 criado."} << endl;\par
152         arquivo_escrever.clear();\par
153     \}\par
154 \par
155 \par
156     {\cf19 for}({\cf18 int} i = 0; i < arquivo->quantidade_palavras_nao_repetidas; i++)\par
157     \{\par
158         {\cf18 int} pos = hash_funcao(arquivo->Palavras_organizadas[i]);\par
159         {\cf19 if}(pos < 0)\par
160         \{\par
161             pos = pos * (-1);\par
162         \}\par
163         arquivo_escrever << tabela[pos].Palavra <<  {\cf22 " "};\par
164         arquivo_escrever << tabela[pos].quantidade << {\cf22 " "};\par
165         {\cf19 for}({\cf18 int}  j = 0; j < tabela[pos].quantidade; j++)\par
166         \{\par
167         {\cf19 if}(j == 0)\par
168         \{\par
169         arquivo_escrever <<  tabela[pos].linha[j];\par
170         \}\par
171         {\cf19 else}\par
172         \{\par
173         arquivo_escrever << {\cf22 " "} <<  tabela[pos].linha[j];\par
174         \}\par
175 \par
176         \}\par
177         arquivo_escrever << endl;\par
178 \par
179     \}\par
180 \par
181 arquivo_escrever.close();\par
182 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.h}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Escreve_No_Log_Arquivo} ({\b ARQUIVO} *arquivo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Escreve_No_Log_Palavra} ({\b ARQUIVO} *arquivo, {\b Tabela_Hash} tabela)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Escreve_No_Log_Controle} ({\b ARQUIVO} *arquivo)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Escreve_No_Log_Arquivo\:escreve.h}
{\xe \v escreve.h\:Escreve_No_Log_Arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Escreve_No_Log_Arquivo ({\b ARQUIVO} * arquivo)}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de escrita nos logs de controle \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 108 \{\par
109     {\cf20 //cout << "scmdksa" <<endl;}\par
110     {\cf20 //system("PAUSE > null");}\par
111 \par
112     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
113 \par
114     strcpy(nome, arquivo->nome_arquivo);\par
115     strcat(nome, {\cf22 "LogArq.txt"});\par
116     strupr(nome);\par
117 \par
118     ofstream arquivo_escrever;\par
119     arquivo_escrever.open(nome);\par
120 \par
121     {\cf19 if}(!arquivo_escrever.is_open())\par
122     \{\par
123         cout << {\cf22 "N\'E3o foi encontrado o arquivo:  novo log de palavra ('nome do arquivo'LogArq.txt) para esse arquivo ser\'E1 criado."} << endl;\par
124         arquivo_escrever.clear();\par
125     \}\par
126     arquivo_escrever << arquivo->quantidade_palavras <<  {\cf22 " "};\par
127     arquivo_escrever << arquivo->quantidade_palavras_nao_repetidas <<  {\cf22 " "};\par
128     arquivo_escrever << arquivo->numero_do_arquivo <<  {\cf22 " "};\par
129     {\cf20 //cout << arquivo->quantidade_palavras << endl;}\par
130     {\cf20 //cout << "scmdksa" <<endl;}\par
131     {\cf20 //system("PAUSE > null");}\par
132 \}\par
}
}
{\xe \v Escreve_No_Log_Controle\:escreve.h}
{\xe \v escreve.h\:Escreve_No_Log_Controle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Escreve_No_Log_Controle ({\b ARQUIVO} * arquivo)}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de escrita nos logs de controle \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17 \{\par
18     {\cf18 char} nome[TAMANHO_DO_CONTROLE][TAMANHO_DA_PALAVRA];\par
19     {\cf18 int} i = 0;\par
20 \par
21 \par
22     {\cf19 for}( {\cf18 int} j = 0; j < TAMANHO_DO_CONTROLE; j++)\par
23     \{\par
24     strcpy(nome[j], {\cf22 " "});\par
25     \}\par
26 \par
27     {\cf20 /*}\par
28 {\cf20     ofstream arquivo_es;}\par
29 {\cf20     arquivo_es.open("Log_Controle.txt");}\par
30 {\cf20 }\par
31 {\cf20     if(!arquivo_es.is_open())}\par
32 {\cf20     \{}\par
33 {\cf20         cout << "N\'E3o foi encontrado o arquivo:" << endl;}\par
34 {\cf20         arquivo_es.clear();}\par
35 {\cf20         arquivo_es.open("Log_Controle.txt");}\par
36 {\cf20         arquivo_es << "       uihul " << endl;}\par
37 {\cf20     //arquivo_es.close();}\par
38 {\cf20     //return 0;}\par
39 {\cf20     \}}\par
40 {\cf20     */}\par
41 \par
42     {\cf20 //system("PAUSE > null");}\par
43     ifstream arquivo_ler;\par
44     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
45     {\cf19 if}(!arquivo_ler.is_open())\par
46     \{\par
47         cout << {\cf22 "N\'E3o foi encontrado o arquivo de controle: novo arquivo 'Log_controle.txt' ser\'E1 criado e primeiro nome de arquivo armazenado."} << endl;\par
48         arquivo_ler.close();\par
49     \}\par
50     {\cf19 if}(is_empty(arquivo_ler))\par
51     \{\par
52         arquivo_ler.close();\par
53         ofstream arquivo_escrever;\par
54         arquivo_escrever.open({\cf22 "Log_Controle.txt"});\par
55         arquivo_escrever << strupr(arquivo->nome_arquivo);\par
56 \par
57         cout << {\cf22 "arquivo inserido ao banco de arquivos com sucesso."} << endl;\par
58         {\cf20 //system("PAUSE > null");}\par
59         {\cf19 return} 0;\par
60     \}\par
61     {\cf19 else}\par
62     \{\par
63         {\cf19 while}(! arquivo_ler.eof())\par
64         \{\par
65                 arquivo_ler >> nome[i];\par
66                 {\cf20 //cout << nome[i] << endl;}\par
67                 {\cf20 //cout << arquivo->nome_arquivo<< endl;}\par
68                 {\cf20 //cout << "ljk\'E7wmafk\'E7l" << endl;}\par
69                 {\cf20 //system("PAUSE > null");}\par
70 \par
71                 {\cf19 if}(strcmp(nome[i], strupr(arquivo->nome_arquivo)) == 0)\par
72                 \{\par
73                     cout << {\cf22 "Existe um arquivo com mesmo nome no banco. Renomeie para inser\'E7\'E3o."} << endl;\par
74                     {\cf19 return} 0;\par
75                 \}\par
76                 i++;\par
77         \}\par
78     \}\par
79 \par
80     arquivo_ler.close();\par
81 \par
82     strcpy(nome[i],arquivo->nome_arquivo);\par
83     i++;\par
84     ofstream arquivo_escrever;\par
85     arquivo_escrever.open({\cf22 "Log_Controle.txt"});\par
86 \par
87     {\cf19 for}( {\cf18 int} j = 0; j < i; j++)\par
88     \{\par
89     {\cf19 if}( j == i - 1)\par
90     \{\par
91         arquivo_escrever << strupr(nome[j]) << {\cf23 '\\0'};\par
92     \}\par
93     {\cf19 else}\par
94     \{\par
95     {\cf20 //cout << nome[i] << endl;}\par
96     arquivo_escrever << strupr(nome[j]) << {\cf22 " "};\par
97     \}\par
98     \}\par
99 \par
100     cout << {\cf22 "arquivo inserido ao banco de arquivos com sucesso."} << endl;\par
101     {\cf20 //cout << "scmdksa" <<endl;}\par
102     {\cf20 //system("PAUSE > null");}\par
103 {\cf19 return} 0;\par
104 \par
105 \}\par
}
}
{\xe \v Escreve_No_Log_Palavra\:escreve.h}
{\xe \v escreve.h\:Escreve_No_Log_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Escreve_No_Log_Palavra ({\b ARQUIVO} * arquivo, {\b Tabela_Hash} tabela)}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 135 \{\par
136 \par
137     {\cf20 //system("PAUSE > null");}\par
138 \par
139     {\cf18 char} nome[30];\par
140     ofstream arquivo_escrever;\par
141     strcpy(nome, arquivo->nome_arquivo);\par
142     strcat(nome, {\cf22 "LogPal.txt"});\par
143     strupr(nome);\par
144     {\cf20 //cout << arquivo->nome_arquivo << endl;}\par
145     {\cf20 //cout << nome << endl;}\par
146 \par
147     arquivo_escrever.open(nome);\par
148 \par
149     {\cf19 if}(!arquivo_escrever.is_open())\par
150     \{\par
151         cout << {\cf22 "N\'E3o foi encontrado o arquivo: novo log de palavra ('nome do arquivo'LogPal.txt) para esse arquivo ser\'E1 criado."} << endl;\par
152         arquivo_escrever.clear();\par
153     \}\par
154 \par
155 \par
156     {\cf19 for}({\cf18 int} i = 0; i < arquivo->quantidade_palavras_nao_repetidas; i++)\par
157     \{\par
158         {\cf18 int} pos = hash_funcao(arquivo->Palavras_organizadas[i]);\par
159         {\cf19 if}(pos < 0)\par
160         \{\par
161             pos = pos * (-1);\par
162         \}\par
163         arquivo_escrever << tabela[pos].Palavra <<  {\cf22 " "};\par
164         arquivo_escrever << tabela[pos].quantidade << {\cf22 " "};\par
165         {\cf19 for}({\cf18 int}  j = 0; j < tabela[pos].quantidade; j++)\par
166         \{\par
167         {\cf19 if}(j == 0)\par
168         \{\par
169         arquivo_escrever <<  tabela[pos].linha[j];\par
170         \}\par
171         {\cf19 else}\par
172         \{\par
173         arquivo_escrever << {\cf22 " "} <<  tabela[pos].linha[j];\par
174         \}\par
175 \par
176         \}\par
177         arquivo_escrever << endl;\par
178 \par
179     \}\par
180 \par
181 arquivo_escrever.close();\par
182 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
escreve.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef _ESCREVE_H_}\par
2 {\cf21 #define _ESCREVE_H_}\par
3 \par
9 {\cf18 void} Escreve_No_Log_Arquivo(ARQUIVO *arquivo);\par
10 {\cf18 void} Escreve_No_Log_Palavra(ARQUIVO *arquivo, Tabela_Hash tabela);\par
11 {\cf18 bool} Escreve_No_Log_Controle(ARQUIVO *arquivo);\par
12 \par
13 \par
14 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.cpp}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.cpp}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "teste.h"}\par
{\f2 #include "consulta_palavra.h"}\par
{\f2 #include "Forma_da_Busca.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bor} (int pos, int pos1, {\b Hash} tab)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b band} (int pos, int pos1, {\b Hash} tab)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v band\:Forma_da_Busca.cpp}
{\xe \v Forma_da_Busca.cpp\:band}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void band (int pos, int pos1, {\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 108 \{\par
109     Hash tabela;\par
110     Dados *novo = (Dados*) {\cf17 new} Dados;\par
111     novo = tabela[0];\par
112     Dados *aux1, *aux2, *aux3, *aux4;\par
113     aux1 = tab[pos];\par
114     aux2 = tab[pos1];\par
115     aux3 = tabela[0];\par
116     aux4 = NULL;\par
117 \par
118 \par
119 \par
120     {\cf19 while}(aux1 != NULL)\par
121     \{\par
122         {\cf19 while}(aux2 != NULL)\par
123         \{\par
124             {\cf19 if}(strcmp(aux1->Arquivo, aux2->Arquivo) == 0)\par
125             \{\par
126                 Dados *novo = (Dados*) {\cf17 new} Dados;\par
127                 novo->quantidade = 0;\par
128                 cout << aux1->Arquivo << endl;\par
129                 {\cf19 for}( {\cf18 int} i = 0; i < aux1->quantidade; i++)\par
130                 \{\par
131 \par
132                     {\cf19 for}( {\cf18 int} j = 0; j < aux2->quantidade; j++)\par
133                     \{\par
134                         {\cf19 if}(aux1->linha[i] == aux2->linha[j])\par
135                         \{\par
136                              cout << aux1->linha[i] << {\cf22 "dk\'E7wa"} << endl;\par
137 \par
138                                 strcpy(novo->Arquivo, aux1->Arquivo);\par
139                                 strcpy(novo->Palavra, aux1->Palavra);\par
140                                 novo->linha[novo->quantidade] = aux1->linha[i];\par
141                                 novo->quantidade++;\par
142 \par
143                         \}\par
144 \par
145 \par
146 \par
147                     \}\par
148 \par
149                 \}\par
150 \par
151                 {\cf19 if}(novo->quantidade != 0 && tabela[0] == NULL)\par
152                 \{\par
153                     novo->ant = NULL;\par
154                     novo->prox = NULL;\par
155                     cout << novo->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
156                     tabela[0] = novo;\par
157                      cout << tabela[0]->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
158 \par
159 \par
160                 \}\par
161                 {\cf19 else} {\cf19 if} (novo->quantidade != 0 && tabela[0] != NULL)\par
162                 \{\par
163 \par
164                     {\cf19 while}(aux3 != NULL)\par
165                     \{\par
166                         aux4 = aux3;\par
167                         aux3 = aux3->prox;\par
168                     \}\par
169                     aux4->prox = novo;\par
170                     novo->ant = aux4;\par
171                     novo->prox = NULL;\par
172                 \}\par
173 \par
174                 aux3 = tabela[0];\par
175                 aux4 = NULL;\par
176             \}\par
177         aux2 = aux2->prox;\par
178         \}\par
179     aux1 = aux1->prox;\par
180     aux2 = tab[pos1];\par
181     \}\par
182 \par
183 \par
184 cout << tabela[0]->quantidade << {\cf22 "kmsa\'E7"} << endl;\par
185 cout << tabela[0]->Arquivo << {\cf22 "kmsa\'E7"} << endl;\par
186 cout << tabela[0]->linha[tabela[0]->quantidade - 1] << {\cf22 "kmsa\'E7"} << endl;\par
187 \par
188 \par
189 {\cf20 //Apresentar_Lista_Frase(tab, 0);     // faze sobreposi\'E7\'E3o de fun\'E7\'E3o!!}\par
190 \par
191 \par
192 \}\par
}
}
{\xe \v bor\:Forma_da_Busca.cpp}
{\xe \v Forma_da_Busca.cpp\:bor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void bor (int pos, int pos1, {\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de busca de palavras em rela\'E7\'E3o ao sistema de arquivos usando and e or \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18 \{\par
19     Hash tabela;\par
20     Dados *novo = (Dados*) {\cf17 new} Dados;\par
21     novo = tabela[0];\par
22     Dados *aux1, *aux2, *aux3, *aux4;\par
23     aux1 = tab[pos];\par
24     aux2 = tab[pos1];\par
25     aux3 = tabela[0];\par
26     aux4 = NULL;\par
27 \par
28 \par
29 \par
30     {\cf19 while}(aux1 != NULL)\par
31     \{\par
32         {\cf19 while}(aux2 != NULL)\par
33         \{\par
34             {\cf19 if}(strcmp(aux1->Arquivo, aux2->Arquivo) == 0)\par
35             \{\par
36                 Dados *novo = (Dados*) {\cf17 new} Dados;\par
37                 novo->quantidade = 0;\par
38                 cout << aux1->Arquivo << endl;\par
39                 {\cf19 for}( {\cf18 int} i = 0; i < aux1->quantidade; i++)\par
40                 \{\par
41                     cout << aux1->linha[i] << {\cf22 "dk\'E7wa"} << endl;\par
42                     strcpy(novo->Arquivo, aux1->Arquivo);\par
43                     {\cf20 //strcpy(novo->Palavra, aux1->Palavra);}\par
44                     novo->linha[novo->quantidade] = aux1->linha[i];\par
45                     novo->quantidade++;\par
46                 \}\par
47                 {\cf19 for}( {\cf18 int} j = 0; j < aux2->quantidade; j++)\par
48                 \{\par
49                              cout << {\cf22 "hblj"} << aux2->linha[j] << {\cf22 "dk\'E7wa"} << endl;\par
50                           {\cf19 for}( {\cf18 int} k = 0; k < novo->quantidade; k++)\par
51                         \{\par
52                             {\cf19 if}(novo->linha[k] != aux2->linha[j])\par
53                             \{\par
54                                 novo->linha[novo->quantidade] = aux2->linha[j];\par
55                                 novo->quantidade++;\par
56 \par
57                             \}\par
58                         \}\par
59 \par
60 \par
61                     \}\par
62 \par
63 \par
64                 {\cf19 if}(novo->quantidade != 0 && tabela[0] == NULL)\par
65                 \{\par
66                     novo->ant = NULL;\par
67                     novo->prox = NULL;\par
68                     cout << novo->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
69                     tabela[0] = novo;\par
70                      cout << tabela[0]->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
71 \par
72 \par
73                 \}\par
74                 {\cf19 else} {\cf19 if} (novo->quantidade != 0 && tabela[0] != NULL)\par
75                 \{\par
76 \par
77                     {\cf19 while}(aux3 != NULL)\par
78                     \{\par
79                         aux4 = aux3;\par
80                         aux3 = aux3->prox;\par
81                     \}\par
82                     aux4->prox = novo;\par
83                     novo->ant = aux4;\par
84                     novo->prox = NULL;\par
85                 \}\par
86 \par
87                 aux3 = tabela[0];\par
88                 aux4 = NULL;\par
89             \}\par
90         aux2 = aux2->prox;\par
91         \}\par
92     aux1 = aux1->prox;\par
93     aux2 = tab[pos1];\par
94     \}\par
95 \par
96 \par
97 cout << tabela[0]->prox->quantidade << {\cf22 "kmsa\'E7"} << endl;\par
98 cout << tabela[0]->prox->Arquivo << {\cf22 "kmsa\'E7"} << endl;\par
99 cout << tabela[0]->prox->linha[tabela[0]->quantidade - 1] << {\cf22 "kmsa\'E7"} << endl;\par
100 \par
101 \par
102 \par
103 \par
104 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.h}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bor} (int pos, int pos1, {\b Hash} tab)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b band} (int pos, int pos1, {\b Hash} tab)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v band\:Forma_da_Busca.h}
{\xe \v Forma_da_Busca.h\:band}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void band (int pos, int pos1, {\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 108 \{\par
109     Hash tabela;\par
110     Dados *novo = (Dados*) {\cf17 new} Dados;\par
111     novo = tabela[0];\par
112     Dados *aux1, *aux2, *aux3, *aux4;\par
113     aux1 = tab[pos];\par
114     aux2 = tab[pos1];\par
115     aux3 = tabela[0];\par
116     aux4 = NULL;\par
117 \par
118 \par
119 \par
120     {\cf19 while}(aux1 != NULL)\par
121     \{\par
122         {\cf19 while}(aux2 != NULL)\par
123         \{\par
124             {\cf19 if}(strcmp(aux1->Arquivo, aux2->Arquivo) == 0)\par
125             \{\par
126                 Dados *novo = (Dados*) {\cf17 new} Dados;\par
127                 novo->quantidade = 0;\par
128                 cout << aux1->Arquivo << endl;\par
129                 {\cf19 for}( {\cf18 int} i = 0; i < aux1->quantidade; i++)\par
130                 \{\par
131 \par
132                     {\cf19 for}( {\cf18 int} j = 0; j < aux2->quantidade; j++)\par
133                     \{\par
134                         {\cf19 if}(aux1->linha[i] == aux2->linha[j])\par
135                         \{\par
136                              cout << aux1->linha[i] << {\cf22 "dk\'E7wa"} << endl;\par
137 \par
138                                 strcpy(novo->Arquivo, aux1->Arquivo);\par
139                                 strcpy(novo->Palavra, aux1->Palavra);\par
140                                 novo->linha[novo->quantidade] = aux1->linha[i];\par
141                                 novo->quantidade++;\par
142 \par
143                         \}\par
144 \par
145 \par
146 \par
147                     \}\par
148 \par
149                 \}\par
150 \par
151                 {\cf19 if}(novo->quantidade != 0 && tabela[0] == NULL)\par
152                 \{\par
153                     novo->ant = NULL;\par
154                     novo->prox = NULL;\par
155                     cout << novo->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
156                     tabela[0] = novo;\par
157                      cout << tabela[0]->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
158 \par
159 \par
160                 \}\par
161                 {\cf19 else} {\cf19 if} (novo->quantidade != 0 && tabela[0] != NULL)\par
162                 \{\par
163 \par
164                     {\cf19 while}(aux3 != NULL)\par
165                     \{\par
166                         aux4 = aux3;\par
167                         aux3 = aux3->prox;\par
168                     \}\par
169                     aux4->prox = novo;\par
170                     novo->ant = aux4;\par
171                     novo->prox = NULL;\par
172                 \}\par
173 \par
174                 aux3 = tabela[0];\par
175                 aux4 = NULL;\par
176             \}\par
177         aux2 = aux2->prox;\par
178         \}\par
179     aux1 = aux1->prox;\par
180     aux2 = tab[pos1];\par
181     \}\par
182 \par
183 \par
184 cout << tabela[0]->quantidade << {\cf22 "kmsa\'E7"} << endl;\par
185 cout << tabela[0]->Arquivo << {\cf22 "kmsa\'E7"} << endl;\par
186 cout << tabela[0]->linha[tabela[0]->quantidade - 1] << {\cf22 "kmsa\'E7"} << endl;\par
187 \par
188 \par
189 {\cf20 //Apresentar_Lista_Frase(tab, 0);     // faze sobreposi\'E7\'E3o de fun\'E7\'E3o!!}\par
190 \par
191 \par
192 \}\par
}
}
{\xe \v bor\:Forma_da_Busca.h}
{\xe \v Forma_da_Busca.h\:bor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void bor (int pos, int pos1, {\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encontram-se os algoritmos de busca de palavras em rela\'E7\'E3o ao sistema de arquivos usando and e or \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18 \{\par
19     Hash tabela;\par
20     Dados *novo = (Dados*) {\cf17 new} Dados;\par
21     novo = tabela[0];\par
22     Dados *aux1, *aux2, *aux3, *aux4;\par
23     aux1 = tab[pos];\par
24     aux2 = tab[pos1];\par
25     aux3 = tabela[0];\par
26     aux4 = NULL;\par
27 \par
28 \par
29 \par
30     {\cf19 while}(aux1 != NULL)\par
31     \{\par
32         {\cf19 while}(aux2 != NULL)\par
33         \{\par
34             {\cf19 if}(strcmp(aux1->Arquivo, aux2->Arquivo) == 0)\par
35             \{\par
36                 Dados *novo = (Dados*) {\cf17 new} Dados;\par
37                 novo->quantidade = 0;\par
38                 cout << aux1->Arquivo << endl;\par
39                 {\cf19 for}( {\cf18 int} i = 0; i < aux1->quantidade; i++)\par
40                 \{\par
41                     cout << aux1->linha[i] << {\cf22 "dk\'E7wa"} << endl;\par
42                     strcpy(novo->Arquivo, aux1->Arquivo);\par
43                     {\cf20 //strcpy(novo->Palavra, aux1->Palavra);}\par
44                     novo->linha[novo->quantidade] = aux1->linha[i];\par
45                     novo->quantidade++;\par
46                 \}\par
47                 {\cf19 for}( {\cf18 int} j = 0; j < aux2->quantidade; j++)\par
48                 \{\par
49                              cout << {\cf22 "hblj"} << aux2->linha[j] << {\cf22 "dk\'E7wa"} << endl;\par
50                           {\cf19 for}( {\cf18 int} k = 0; k < novo->quantidade; k++)\par
51                         \{\par
52                             {\cf19 if}(novo->linha[k] != aux2->linha[j])\par
53                             \{\par
54                                 novo->linha[novo->quantidade] = aux2->linha[j];\par
55                                 novo->quantidade++;\par
56 \par
57                             \}\par
58                         \}\par
59 \par
60 \par
61                     \}\par
62 \par
63 \par
64                 {\cf19 if}(novo->quantidade != 0 && tabela[0] == NULL)\par
65                 \{\par
66                     novo->ant = NULL;\par
67                     novo->prox = NULL;\par
68                     cout << novo->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
69                     tabela[0] = novo;\par
70                      cout << tabela[0]->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
71 \par
72 \par
73                 \}\par
74                 {\cf19 else} {\cf19 if} (novo->quantidade != 0 && tabela[0] != NULL)\par
75                 \{\par
76 \par
77                     {\cf19 while}(aux3 != NULL)\par
78                     \{\par
79                         aux4 = aux3;\par
80                         aux3 = aux3->prox;\par
81                     \}\par
82                     aux4->prox = novo;\par
83                     novo->ant = aux4;\par
84                     novo->prox = NULL;\par
85                 \}\par
86 \par
87                 aux3 = tabela[0];\par
88                 aux4 = NULL;\par
89             \}\par
90         aux2 = aux2->prox;\par
91         \}\par
92     aux1 = aux1->prox;\par
93     aux2 = tab[pos1];\par
94     \}\par
95 \par
96 \par
97 cout << tabela[0]->prox->quantidade << {\cf22 "kmsa\'E7"} << endl;\par
98 cout << tabela[0]->prox->Arquivo << {\cf22 "kmsa\'E7"} << endl;\par
99 cout << tabela[0]->prox->linha[tabela[0]->quantidade - 1] << {\cf22 "kmsa\'E7"} << endl;\par
100 \par
101 \par
102 \par
103 \par
104 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Forma_da_Busca.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.h}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef _FORMA_DA_BUSCA_H}\par
2 {\cf21 #define _FORMA_DA_BUSCA_H}\par
3 \par
8 {\cf18 void} bor({\cf18 int} pos, {\cf18 int} pos1, Hash tab);\par
9 {\cf18 void} band({\cf18 int} pos, {\cf18 int} pos1, Hash tab);\par
10 \par
11 {\cf21 #endif}\par
12 \par
13 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/main.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/main.cpp}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/main.cpp}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <fstream>}\par
{\f2 #include <string.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include "Apaga.h"}\par
{\f2 #include "teste.h"}\par
{\f2 #include "escreve.h"}\par
{\f2 #include "consulta_palavra.h"}\par
{\f2 #include "Consulta_Base_Arquivos.h"}\par
{\f2 #include "Forma_da_Busca.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VERSION}\~ "scs_1.0"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b no_argument}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b required_argument}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b optional_argument}\~ 2\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e macros\par
\pard\plain 
{\xe \v no_argument\:main.cpp}
{\xe \v main.cpp\:no_argument}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define no_argument\~ 0}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v optional_argument\:main.cpp}
{\xe \v main.cpp\:optional_argument}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define optional_argument\~ 2}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v required_argument\:main.cpp}
{\xe \v main.cpp\:required_argument}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define required_argument\~ 1}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VERSION\:main.cpp}
{\xe \v main.cpp\:VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VERSION\~ "scs_1.0"}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse programa \'E9 um pesquisador de palavras num sistema de arquivos \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v main\:main.cpp}
{\xe \v main.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int argc, char * argv[])}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26                                   \{\par
27     \par
28     Tabela_Hash Tabela_controle_Hash;           {\cf20 //Nomes Claros e Significativos}\par
29     Hash tab;\par
30     ARQUIVO *arquivo = (ARQUIVO*) {\cf17 new} ARQUIVO;\par
31     LISTA *lista_de_arquivos = (LISTA*) {\cf17 new} LISTA;\par
32     lista_de_arquivos->ini->arquivo = (ARQUIVO*) {\cf17 new} ARQUIVO; \par
33 \par
34     Inicializar_Hash(Tabela_controle_Hash);\par
35     Inicializar_Vetor_arquivo(arquivo);\par
36     Inicializar_Lista(lista_de_arquivos);\par
37     \par
38     {\cf18 bool} timer = {\cf17 false};                 \par
39     clock_t tempoInicial, tempoFinal;\par
40     {\cf18 double} tempo_gasto;\par
41     \par
42     {\cf18 int} index;\par
43     {\cf18 int} Controle_do_Menu=0;\par
44     {\cf18 bool} Ajuda_Flag = {\cf17 false};\par
45     \par
46     {\cf17 const} {\cf17 struct }option longopts[] = \{\par
47     \par
48     \{{\cf22 "Exibir_Menu_Ajuda"},       no_argument,        0, {\cf23 'h'}\},\par
49 \par
50     \{{\cf22 "Inserir_Arquivo"},     required_argument,  0, {\cf23 'i'}\},                {\cf20 //modo de gerencialmente}\par
51     \{{\cf22 "Remover_Arquivo"},      required_argument,  0, {\cf23 'r'}\},\par
52     \{{\cf22 "Listar_Base_Arquivo_por_Insercao"},      no_argument,        0, {\cf23 'e'}\},\par
53     \{{\cf22 "Listar_Base_Arquivo_por_Ordem_Alfabetica"},      no_argument,        0, {\cf23 'a'}\},\par
54     \{{\cf22 "Listar_Base_Arquivo_por_Quantidade_Palavras"},    no_argument,  0, {\cf23 'p'}\},\par
55 \par
56     \{{\cf22 "Pesquisa_AND"},      required_argument,        0, {\cf23 'd'}\},          {\cf20 //modo de busca}\par
57     \{{\cf22 "Pesquisa_OR"},       required_argument,        0, {\cf23 'o'}\},\par
58     \{{\cf22 "Exibir_resultados_Por_Ordem_Alfabetica"},      no_argument,        0, {\cf23 'b'}\},\par
59     \{{\cf22 "Exibir_resultados_Por_Quantidade_Palavras"},       no_argument,        0, {\cf23 'q'}\},\par
60     \{{\cf22 "Exibir_resultados_Por_Ordem_Insercao"},    no_argument,  0, {\cf23 'c'}\},\par
61 \par
62     \{{\cf22 "Apresentar_Tempo_De_Busca"},     no_argument,  0, {\cf23 's'}\},\par
63     \{{\cf22 "Nao_Apresentar_Tempo_De_Busca"},      no_argument,  0, {\cf23 'n'}\},\par
64     \{0,0,0,0\},\par
65     \};\par
66 \par
67       {\cf19 if}( argc < 2) \{\par
68             Imprimir_Ajuda();\par
69         \}\par
70 \par
71   {\cf20 //desativa as mensagens de erro do getopt}\par
72     opterr=0;\par
73 \par
74     {\cf19 while}(Controle_do_Menu != -1) \{\par
75       \par
76         Controle_do_Menu = getopt_long(argc, argv, {\cf22 "hi:r:eapd:o:bqcsn"}, longopts, &index);\par
77 \par
78         {\cf19 switch} (Controle_do_Menu) \{\par
79 \par
80             {\cf19 case} {\cf23 '?'}:      {\cf20 // erro - opcao desconhecida}\par
81                 std::cout << {\cf22 "Opcao "} << (char) optopt << {\cf22 " eh invalida."} << std::endl;\par
82                 {\cf19 break};\par
83             \par
84             {\cf19 case} -1:      {\cf20 // erro - opcao desconhecida}\par
85                 std::cout << {\cf22 "Fim da linha de comando."} << std::endl;\par
86                 tempoFinal = clock();\par
87                 {\cf19 break};\par
88 \par
89             {\cf19 case} {\cf23 'h'}:        \par
90                 {\cf19 if} (Ajuda_Flag) \{\par
91                     std::cout << {\cf22 "Flag 'h' repetida"} << std::endl;\par
92                     {\cf19 break};\par
93                 \}\par
94         \par
95                 Ajuda_Flag = {\cf17 true};\par
96                 Imprimir_Ajuda();\par
97                 {\cf19 break};\par
98 \par
99             {\cf19 case} {\cf23 'i'}:     {\cf20 //inserir arquivo}\par
100                 std::cout << {\cf22 "Tentando inserir arquivo no banco de arquivos. "}  << std::endl;\par
101 \par
102                 {\cf19 if}(Dados_Arquivo(Tabela_controle_Hash,arquivo, optarg) != 0) \{\par
103                     \par
104                     cout << {\cf22 "Tentando inserir o arquivo: "} << optarg << endl;\par
105                     \par
106                     Escreve_No_Log_Palavra(arquivo, Tabela_controle_Hash);\par
107                     Escreve_No_Log_Arquivo(arquivo);\par
108                     Escreve_No_Log_Controle(arquivo);\par
109                 \}\par
110               \par
111                 cout << endl;\par
112                 index = optind;\par
113 \par
114                 {\cf19 if} (argv[index] != NULL  && argv[index][0]!={\cf23 '-'}) \{\par
115                     \par
116                     {\cf19 while}(index < argc && argv[index][0]!={\cf23 '-'}) \{\par
117                         \par
118                         cout << {\cf22 "Tentando inserir o arquivo "} << argv[index] << endl;\par
119                         \par
120                         {\cf19 if}(Dados_Arquivo(Tabela_controle_Hash,arquivo, argv[index]) != 0) \{\par
121                             \par
122                               Escreve_No_Log_Palavra(arquivo, Tabela_controle_Hash);\par
123                               Escreve_No_Log_Arquivo(arquivo);\par
124                               Escreve_No_Log_Controle(arquivo);\par
125                         \}\par
126                               \par
127                         cout << endl;\par
128                         index++;\par
129                     \}\par
130                     optind = index-1;\par
131                 \}\par
132                 {\cf19 break};\par
133 \par
134              {\cf19 case} {\cf23 'r'}:       {\cf20 // remover arquivo}\par
135                 cout << {\cf22 "Tentando remover o arquivo "} << optarg << endl;\par
136             \par
137                 Remove_Log_Controle(optarg);\par
138             \par
139                 index = optind;\par
140                 cout << endl;\par
141             \par
142                 {\cf19 if} (argv[index] != NULL  && argv[index][0]!={\cf23 '-'}) \{\par
143         \par
144                     {\cf19 while}(index < argc && argv[index][0]!={\cf23 '-'}) \{\par
145                         \par
146                         cout << {\cf22 "Tentando remover o arquivo "} << argv[index] << endl;\par
147                         Remove_Log_Controle(argv[index]);\par
148                         index++;\par
149                         cout << endl;\par
150                     \}\par
151                     optind = index-1;\par
152                     cout << endl;\par
153                 \}\par
154                 {\cf19 break};\par
155     \par
156             {\cf19 case} {\cf23 'e'}:                                                                           {\cf20 //EVITE COMENT\'C1RIOS DESNECESS\'C1RIOS }\par
157                 std::cout << {\cf22 "Listar banco de arquivos por ordem de insercao: "} << std::endl;\par
158                 Consulta_Base_Insercao();\par
159     \par
160             {\cf19 case} {\cf23 'a'}:         \par
161                 std::cout << {\cf22 "Listar banco de arquivos por ordem alfab\'E9tica"} << std::endl;\par
162                 Consulta_Base_Alfabetica();\par
163                 {\cf19 break};\par
164     \par
165             {\cf19 case} {\cf23 'p'}:         \par
166                 std::cout << {\cf22 "Listar banco de arquivos por ordem de palavras: "} << std::endl;\par
167                 Consulta_Base_Quantidade_Palavras();\par
168                 {\cf19 break};\par
169 \par
170             {\cf19 case} {\cf23 'd'}:         {\cf20 // busca feita com and}\par
171                 std::cout << {\cf22 "Argumento and: "}  << std::endl;\par
172                 \par
173                 Consulta_Palavra(optarg, tab);\par
174                 Apresentar_Lista_Frase(tab, optarg);\par
175                 \par
176                 index = optind;\par
177                 \par
178                 {\cf19 if} (argv[index] != NULL  && argv[index][0]!={\cf23 '-'}) \{\par
179                     {\cf19 while}(index < argc && argv[index][0]!={\cf23 '-'}) \{\par
180             \par
181                         index++;\par
182                     \}\par
183                     optind = index-1;\par
184                 \}\par
185                 {\cf19 break};\par
186 \par
187             {\cf19 case} {\cf23 'o'}:             {\cf20 // busca feita com or}\par
188                 std::cout << {\cf22 "Argumento or"} << std::endl;\par
189                 \par
190                 Consulta_Palavra(optarg, tab);\par
191                 Apresentar_Lista_Frase(tab, optarg);\par
192                 \par
193                 index = optind;\par
194                 \par
195                 {\cf19 if} (argv[index] != NULL  && argv[index][0]!={\cf23 '-'}) \{\par
196                     {\cf19 while}(index < argc && argv[index][0]!={\cf23 '-'}) \{\par
197                         index++;\par
198                     \}\par
199                     optind = index-1;\par
200                 \}\par
201                 {\cf19 break};\par
202 \par
203             {\cf19 case} {\cf23 'b'}:            \par
204                 std::cout << {\cf22 "Imprimir ordem alfabetico: "} << std::endl;\par
205                 {\cf19 break};\par
206             \par
207             {\cf19 case} {\cf23 'q'}:         \par
208                 std::cout << {\cf22 "Imprimir decrescente de vezes que a palavra aparece: "} << std::endl;\par
209                 {\cf19 break};\par
210         \par
211             {\cf19 case} {\cf23 'c'}:         \par
212                 std::cout << {\cf22 "Imprirmir na ordem de inser\'E7\'E3o: "}  << std::endl;\par
213                 {\cf19 break};\par
214         \par
215             {\cf19 case} {\cf23 's'}:           \par
216                 std::cout << {\cf22 "Registra o tempo: "} << std::endl;\par
217                 tempoInicial = clock();\par
218                 timer = {\cf17 true};\par
219                 {\cf19 break};\par
220         \par
221             {\cf19 case} {\cf23 'n'}:           \par
222                 std::cout << {\cf22 " N\'E3o Registra o tempo "} << std::endl;\par
223                 timer = {\cf17 false};\par
224                 {\cf19 break};\par
225         \}   \par
226    \}\par
227 \par
228     {\cf19 if}(timer == {\cf17 true}) \{\par
229     \par
230     tempo_gasto = double (tempoFinal - tempoInicial) /CLOCKS_PER_SEC;\par
231     cout << {\cf22 "O tempo gasto foi de:"} << tempo_gasto  << endl;\par
232     \}\par
233 \par
234   {\cf19 return} 0;\par
235 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.cpp}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.cpp}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "teste.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Imprimir_Ajuda} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Hash} ({\b Tabela_Hash} tabela)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Vetor_arquivo} ({\b ARQUIVO} *arquivo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Lista} ({\b LISTA} *lista)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b colisao_funcao} ({\b Tabela_Hash} tabela, int cont)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hash_funcao} (char *palavra)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_empty} (std::ifstream &pFile)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Atualiza_buffer} ({\b Tabela_Hash} tabela, int pos, int linha, char palavra[])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Dados_Arquivo} ({\b Tabela_Hash} tabela, {\b ARQUIVO} *arquivo, char *nome)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Atualiza_buffer\:teste.cpp}
{\xe \v teste.cpp\:Atualiza_buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Atualiza_buffer ({\b Tabela_Hash} tabela, int pos, int linha, char palavra[])}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 120 \{\par
121 \par
122     strcpy(tabela[pos].Palavra, palavra);\par
123     {\cf20 //tabela[pos].Documento = "lista.txt";}\par
124     tabela[pos].linha[tabela[pos].quantidade] = linha;\par
125     tabela[pos].quantidade++;\par
126     tabela[pos].livre = {\cf17 false};\par
127     {\cf20 //tabela[pos].prox = NULL;}\par
128     {\cf20 //tabela[pos].ant = NULL;}\par
129 \par
130 \}\par
}
}
{\xe \v colisao_funcao\:teste.cpp}
{\xe \v teste.cpp\:colisao_funcao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int colisao_funcao ({\b Tabela_Hash} tabela, int cont)}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 81 \{\par
82 \par
83 \par
84  {\cf19 while}( tabela[cont].livre == {\cf17 false} )\par
85         \{\par
86             cont = cont + 1;\par
87         \}\par
88         {\cf19 return} cont;\par
89 \}\par
}
}
{\xe \v Dados_Arquivo\:teste.cpp}
{\xe \v teste.cpp\:Dados_Arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Dados_Arquivo ({\b Tabela_Hash} tabela, {\b ARQUIVO} * arquivo, char * nome)}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 134 \{\par
135 \par
136         {\cf20 //Tabela_Hash tabela;}\par
137     {\cf18 char} a[TAMANHO_DA_PALAVRA], palavra[TAMANHO_DA_PALAVRA], **vetor_pra_ordenamento;\par
138     {\cf18 int} i  = 0, pos = 0, linha = 0, u = 0;\par
139 \par
140     vetor_pra_ordenamento = {\cf17 new} {\cf18 char}*[TAMANHO_VETOR_TEMPORARIO];\par
141     {\cf19 for}({\cf18 int} i = 0; i < TAMANHO_VETOR_TEMPORARIO; i++)\par
142     \{\par
143     vetor_pra_ordenamento[i] = {\cf17 new} {\cf18 char}[TAMANHO_DA_PALAVRA];\par
144     \}\par
145 \par
146     ifstream arquivoentrada;\par
147     {\cf20 //abre_arquivo(ifstream arquivoentrada);}\par
148 \par
149         arquivoentrada.open(nome);\par
150 \par
151     {\cf19 if}(!arquivoentrada.is_open())\par
152     \{\par
153         cout << {\cf22 "N\'E3o foi encontrado o arquivo: Insera-no na pasta atual."} << endl;\par
154         arquivoentrada.clear();\par
155         {\cf19 return} {\cf17 false};\par
156     \}\par
157 \par
158 \par
159 \par
160 \par
161     {\cf19 while}(arquivoentrada.eof() != 1)\par
162     \{\par
163         a[i] = arquivoentrada.get();\par
164 \par
165         {\cf19 if}((a[i] >= 32 && a[i] <= 64) || (a[i] > 90 && a[i] < 97)  || (a[i] > 122 && a[i] < 128) || a[i] == {\cf23 '\\n'})\par
166         \{\par
167         {\cf19 if}(a[i] == {\cf23 '\\n'})\par
168         \{\par
169             linha++;\par
170         \}\par
171 \par
172         {\cf19 if}((a[0] >= 32 && a[0] <= 64) || (a[0] > 90 && a[0] < 97)  || (a[0] > 122 && a[0] < 128) || a[0] == {\cf23 '\\n'})\par
173         \{\par
174 \par
175         \}\par
176         {\cf19 else}\par
177         \{\par
178 \par
179             a[i] = {\cf23 '\\0'};\par
180             strcpy(palavra, a);\par
181             strcpy(vetor_pra_ordenamento[u], strupr(palavra));\par
182             u++;\par
183 \par
184             {\cf18 int} pos = hash_funcao(a);\par
185 \par
186             {\cf20 //cout << tabela[pos].livre << endl;}\par
187             {\cf19 if}(strcmp(tabela[pos].Palavra, palavra) != 0 && tabela[pos].livre == {\cf17 false})\par
188             \{\par
189                pos = colisao_funcao(tabela, pos);\par
190             \}\par
191 \par
192             Atualiza_buffer(tabela, pos, linha, palavra);\par
193 \par
194 \par
195             {\cf19 for}({\cf18 int} j = 0; j <= i; j++ )\par
196             \{\par
197                {\cf20 //cout << a[j];}\par
198                 a[j] = {\cf23 ' '};\par
199             \}\par
200             i = 0;\par
201            {\cf20 //cout <<endl;}\par
202             \}\par
203         \}\par
204         {\cf19 else}\par
205         \{\par
206          i++;\par
207         \}\par
208 \par
209 \par
210     \}\par
211 \par
212 \par
213 \par
214     {\cf20 //ordenamento das palavras do arquivo}\par
215 {\cf18 int} total = u;\par
216 {\cf20 //system("PAUSE > null");}\par
217 \par
218 \par
219 {\cf18 char} *aux = ({\cf18 char}*) {\cf17 new} {\cf18 char};\par
220 \par
221 {\cf19 for}({\cf18 int} r = 0; r < u; r++)\par
222 \{\par
223     {\cf19 for}({\cf18 int} s = r+1; s < u; s++)\par
224     \{\par
225         {\cf19 if} (strcmp(vetor_pra_ordenamento[r],vetor_pra_ordenamento[s])>0)\par
226             \{\par
227                strcpy(aux,vetor_pra_ordenamento[s]);\par
228                strcpy(vetor_pra_ordenamento[s],vetor_pra_ordenamento[r]);\par
229                strcpy(vetor_pra_ordenamento[r], aux);\par
230             \}\par
231     \}\par
232 \par
233 \}\par
234 \par
235 \par
236 {\cf19 for}({\cf18 int} q = 0; q < u; q++)\par
237 \{\par
238   {\cf20 //   cout << vetor_pra_ordenamento[q] << endl;}\par
239 \par
240 \}\par
241 \par
242 \par
243 \par
244 {\cf19 for}({\cf18 int} p = 0; p < u - 1; p++)\par
245 \{\par
246 \par
247 \par
248     {\cf19 if}(strcmp(vetor_pra_ordenamento[p], vetor_pra_ordenamento[p+1]) == 0)\par
249     \{\par
250     {\cf20 //cout << strcmp(vetor_pra_ordenamento[p], vetor_pra_ordenamento[p+1]) << endl;}\par
251     {\cf20 //cout << u << endl;}\par
252     {\cf20 //cout << vetor_pra_ordenamento[p] << "||" << vetor_pra_ordenamento[p+ 1] << endl;}\par
253 \par
254         {\cf19 for}(i= p ; i < u - 1; i++)\par
255         \{\par
256             {\cf20 //cout << vetor_pra_ordenamento[i] << "||" << vetor_pra_ordenamento[i+ 1] << "SDXSZ" << endl ;}\par
257             strcpy(vetor_pra_ordenamento[i],vetor_pra_ordenamento[i+1]);\par
258             {\cf20 //cout << vetor_pra_ordenamento[i] << "||" << vetor_pra_ordenamento[i+ 1] << endl;}\par
259            {\cf20 // system("PAUSE > null");}\par
260         \}\par
261           u--;\par
262           p--;\par
263 \par
264     \}\par
265 \par
266 \}\par
267 \par
268 {\cf20 /*}\par
269 {\cf20 for(int q = 0; q < u; q++)}\par
270 {\cf20 \{}\par
271 {\cf20     cout << vetor_pra_ordenamento[q] << endl;}\par
272 {\cf20 }\par
273 {\cf20 \}}\par
274 {\cf20 */}\par
275 \par
276   arquivoentrada.close();\par
277 \par
278   {\cf20 //ARQUIVO *arquivo = (ARQUIVO*) new ARQUIVO;}\par
279   strcpy(arquivo->nome_arquivo, nome);\par
280   arquivo->quantidade_palavras = total;\par
281   arquivo->quantidade_palavras_nao_repetidas = u;\par
282   arquivo->Palavras_organizadas = vetor_pra_ordenamento;\par
283   arquivo->numero_do_arquivo++;\par
284 \par
285 \par
286 {\cf19 return} {\cf17 true};\par
287 \par
288 {\cf20 /*}\par
289 {\cf20 cout << tabela[152].Palavra << endl;}\par
290 {\cf20 cout << tabela[152].quantidade << endl << endl;}\par
291 {\cf20 for(int k = 0; k < tabela[152].quantidade; k++)}\par
292 {\cf20 \{}\par
293 {\cf20     cout << tabela[152].linha[k] << endl;}\par
294 {\cf20 }\par
295 {\cf20 \}}\par
296 {\cf20 */}\par
297 \}\par
}
}
{\xe \v hash_funcao\:teste.cpp}
{\xe \v teste.cpp\:hash_funcao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int hash_funcao (char * palavra)}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 92 \{\par
93    {\cf20 // system("PAUSE > null");}\par
94     palavra = strupr(palavra);\par
95     {\cf18 int} cont = 0, r = 0;\par
96     {\cf19 while}(palavra[r] != {\cf23 '\\0'})\par
97     \{\par
98         r++;\par
99     \}\par
100     {\cf19 for}({\cf18 int} j = 0; j < r; j++)\par
101     \{\par
102         cont = cont + palavra[j];\par
103     \}\par
104     {\cf19 if}(cont < 0)\par
105     \{\par
106     cont = (-1) * cont;\par
107     \}\par
108     {\cf20 //cout<< cont<< endl;}\par
109     {\cf19 return} ({\cf18 unsigned} {\cf18 int})  cont;\par
110 \par
111 \}\par
}
}
{\xe \v Imprimir_Ajuda\:teste.cpp}
{\xe \v teste.cpp\:Imprimir_Ajuda}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Imprimir_Ajuda ()}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15 \par
16     cout << {\cf22 "op\'E7\'F5es:"} << endl;\par
17     cout << {\cf22 " ##Modo de Gerenciamento de Busca:"} << endl << endl;\par
18     cout <<{\cf22 "-h ou --ajuda: mostra essa tela e sai."} << endl\par
19      << {\cf22 "-i ou --Inserir: Inserir novo arquivo na base de dados."} << endl\par
20      << {\cf22 "-r ou --Remover: Remover arquivo na base de dados."} << endl << endl;\par
21 \par
22      cout << {\cf22 "Exibi\'E7\'E3o da base de arquivo:"} << endl << endl\par
23      << {\cf22 "-e ou --List_Insercao: Listar todos os arquivos da base tendo como base a ordem de Insercao."} << endl\par
24      << {\cf22 "-a ou --List_Alfabetico: Listar todos os arquivos da base tendo como base a ordem alfab\'E9tica."} << endl\par
25      << {\cf22 "-p ou --List_Quant_Palavras: Listar todos os arquivos da base tendo como base A ordem decrescente da quantidade de palavras do arquivo."} << endl << endl;\par
26 \par
27     cout << {\cf22 " ##Modo de Buscas:"} << endl << endl;\par
28 \par
29     cout << {\cf22 "Argumento de Busca:"} << endl << endl\par
30     << {\cf22 "-d ou --bAND _And:A busca \'E9 feita por linhas dos arquivos texto que cont\'E9m todas as palavras chave passadas como argumento de entrada."} << endl\par
31     << {\cf22 "-o ou --bOR : A busca \'E9 feita por linhas dos arquivos texto que cont\'E9m ao menos uma das palavras chave passadas como argumento de entrada."} << endl;\par
32 \par
33     cout << {\cf22 "Exibi\'E7\'E3o do resultado da busca:"} << endl << endl\par
34     << {\cf22 "-b ou --Impress_Alfabetica: A impress\'E3o \'E9 feita exibindo os resultados em ordem alfab\'E9tica do nome do arquivo."} << endl\par
35     << {\cf22 "-q ou --Impress_Quant_Palavras: A impress\'E3o \'E9 feita exibindo os resultados em ordem decrescente do n\'FAmero de vezes que as palavraschave ocorreram em cada arquivo."} << endl\par
36     << {\cf22 "-c ou --Impress_Insercao: A impress\'E3o \'E9 feita exibindo os resultados na ordem em que cada arquivo foi inserido na base."} << endl;\par
37 \par
38     cout << {\cf22 "Contabiliza\'E7\'E3o do tempo:"} << endl << endl\par
39     << {\cf22 "-s ou --Temp_S: O programa deve registrar e exibir o tempo total de execu\'E7\'E3o de da busca."} << endl\par
40     << {\cf22 "-n ou --Temp_N: O programa n\'E3o deve registrar nem exibir o tempo total de execu\'E7\'E3o da busca."} << endl;\par
41 \}\par
}
}
{\xe \v Inicializar_Hash\:teste.cpp}
{\xe \v teste.cpp\:Inicializar_Hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Hash ({\b Tabela_Hash} tabela)}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 47 \{\par
48 \par
49 \par
50     {\cf19 for}({\cf18 int} i = 0; i < TAMANHO; i++)\par
51       \{\par
52        tabela[i].quantidade = 0;\par
53        tabela[i].livre = {\cf17 true};\par
54        tabela[i].prox = NULL;\par
55        tabela[i].ant = NULL;\par
56        {\cf19 for}({\cf18 int} j = 0; j < QUANTIDADE_DE_LINHAS; j++)\par
57        \{\par
58            tabela[i].linha[j] = 0;\par
59        \}\par
60        \}\par
61 \par
62 \}\par
}
}
{\xe \v Inicializar_Lista\:teste.cpp}
{\xe \v teste.cpp\:Inicializar_Lista}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Lista ({\b LISTA} * lista)}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 75 \{\par
76     lista->ini = NULL;\par
77     lista->fim = NULL;\par
78     lista->Quantidade_de_Arquivos = 0;\par
79 \}\par
}
}
{\xe \v Inicializar_Vetor_arquivo\:teste.cpp}
{\xe \v teste.cpp\:Inicializar_Vetor_arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Vetor_arquivo ({\b ARQUIVO} * arquivo)}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 66 \{\par
67 \par
68     arquivo->numero_do_arquivo = 0;\par
69     arquivo->quantidade_palavras = 0;\par
70     arquivo->quantidade_palavras_nao_repetidas = 0;\par
71 \}\par
}
}
{\xe \v is_empty\:teste.cpp}
{\xe \v teste.cpp\:is_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool is_empty (std::ifstream & pFile)}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 114 \{\par
115 {\cf19 return} pFile.peek() == std::ifstream::traits_type::eof();\par
116 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.h}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nos}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dado}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b no}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b LISTA}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TESTE_H_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TAMANHO}\~ 2000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b QUANTIDADE_DE_LINHAS}\~ 200\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TAMANHO_DA_PALAVRA}\~ 35\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TAMANHO_DO_CONTROLE}\~ 100\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TAMANHO_VETOR_TEMPORARIO}\~ 500\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TAMANHO_DA_FRASE}\~ 200\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b nos} {\b Dados}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b Dados} {\b Tabela_Hash}[{\b TAMANHO}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b Dados} * {\b Hash}[{\b TAMANHO}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b dado} {\b ARQUIVO}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b no} {\b NoLISTA}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Imprimir_Ajuda} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Hash} ({\b Tabela_Hash} tabela)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Vetor_arquivo} ({\b ARQUIVO} *arquivo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Lista} ({\b LISTA} *lista)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_empty} (std::ifstream &pFile)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Dados_Arquivo} ({\b Tabela_Hash} tabela, {\b ARQUIVO} *arquivo, char *nome)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Atualiza_buffer} ({\b Tabela_Hash} tabela, int pos, int linha, char palavra[], char *nome)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hash_funcao} (char *palavra)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b colisao_funcao} ({\b Tabela_Hash} tabela, int cont)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e macros\par
\pard\plain 
{\xe \v QUANTIDADE_DE_LINHAS\:teste.h}
{\xe \v teste.h\:QUANTIDADE_DE_LINHAS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define QUANTIDADE_DE_LINHAS\~ 200}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TAMANHO\:teste.h}
{\xe \v teste.h\:TAMANHO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TAMANHO\~ 2000}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TAMANHO_DA_FRASE\:teste.h}
{\xe \v teste.h\:TAMANHO_DA_FRASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TAMANHO_DA_FRASE\~ 200}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TAMANHO_DA_PALAVRA\:teste.h}
{\xe \v teste.h\:TAMANHO_DA_PALAVRA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TAMANHO_DA_PALAVRA\~ 35}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TAMANHO_DO_CONTROLE\:teste.h}
{\xe \v teste.h\:TAMANHO_DO_CONTROLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TAMANHO_DO_CONTROLE\~ 100}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TAMANHO_VETOR_TEMPORARIO\:teste.h}
{\xe \v teste.h\:TAMANHO_VETOR_TEMPORARIO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TAMANHO_VETOR_TEMPORARIO\~ 500}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TESTE_H_\:teste.h}
{\xe \v teste.h\:TESTE_H_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TESTE_H_}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es dos tipos\par
\pard\plain 
{\xe \v ARQUIVO\:teste.h}
{\xe \v teste.h\:ARQUIVO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b dado} {\b ARQUIVO}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Dados\:teste.h}
{\xe \v teste.h\:Dados}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b nos} {\b Dados}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Hash\:teste.h}
{\xe \v teste.h\:Hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b Dados}* Hash[{\b TAMANHO}]}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v NoLISTA\:teste.h}
{\xe \v teste.h\:NoLISTA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b no} {\b NoLISTA}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Tabela_Hash\:teste.h}
{\xe \v teste.h\:Tabela_Hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b Dados} Tabela_Hash[{\b TAMANHO}]}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Atualiza_buffer\:teste.h}
{\xe \v teste.h\:Atualiza_buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Atualiza_buffer ({\b Tabela_Hash} tabela, int pos, int linha, char palavra[], char * nome)}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v colisao_funcao\:teste.h}
{\xe \v teste.h\:colisao_funcao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int colisao_funcao ({\b Tabela_Hash} tabela, int cont)}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 81 \{\par
82 \par
83 \par
84  {\cf19 while}( tabela[cont].livre == {\cf17 false} )\par
85         \{\par
86             cont = cont + 1;\par
87         \}\par
88         {\cf19 return} cont;\par
89 \}\par
}
}
{\xe \v Dados_Arquivo\:teste.h}
{\xe \v teste.h\:Dados_Arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Dados_Arquivo ({\b Tabela_Hash} tabela, {\b ARQUIVO} * arquivo, char * nome)}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 134 \{\par
135 \par
136         {\cf20 //Tabela_Hash tabela;}\par
137     {\cf18 char} a[TAMANHO_DA_PALAVRA], palavra[TAMANHO_DA_PALAVRA], **vetor_pra_ordenamento;\par
138     {\cf18 int} i  = 0, pos = 0, linha = 0, u = 0;\par
139 \par
140     vetor_pra_ordenamento = {\cf17 new} {\cf18 char}*[TAMANHO_VETOR_TEMPORARIO];\par
141     {\cf19 for}({\cf18 int} i = 0; i < TAMANHO_VETOR_TEMPORARIO; i++)\par
142     \{\par
143     vetor_pra_ordenamento[i] = {\cf17 new} {\cf18 char}[TAMANHO_DA_PALAVRA];\par
144     \}\par
145 \par
146     ifstream arquivoentrada;\par
147     {\cf20 //abre_arquivo(ifstream arquivoentrada);}\par
148 \par
149         arquivoentrada.open(nome);\par
150 \par
151     {\cf19 if}(!arquivoentrada.is_open())\par
152     \{\par
153         cout << {\cf22 "N\'E3o foi encontrado o arquivo: Insera-no na pasta atual."} << endl;\par
154         arquivoentrada.clear();\par
155         {\cf19 return} {\cf17 false};\par
156     \}\par
157 \par
158 \par
159 \par
160 \par
161     {\cf19 while}(arquivoentrada.eof() != 1)\par
162     \{\par
163         a[i] = arquivoentrada.get();\par
164 \par
165         {\cf19 if}((a[i] >= 32 && a[i] <= 64) || (a[i] > 90 && a[i] < 97)  || (a[i] > 122 && a[i] < 128) || a[i] == {\cf23 '\\n'})\par
166         \{\par
167         {\cf19 if}(a[i] == {\cf23 '\\n'})\par
168         \{\par
169             linha++;\par
170         \}\par
171 \par
172         {\cf19 if}((a[0] >= 32 && a[0] <= 64) || (a[0] > 90 && a[0] < 97)  || (a[0] > 122 && a[0] < 128) || a[0] == {\cf23 '\\n'})\par
173         \{\par
174 \par
175         \}\par
176         {\cf19 else}\par
177         \{\par
178 \par
179             a[i] = {\cf23 '\\0'};\par
180             strcpy(palavra, a);\par
181             strcpy(vetor_pra_ordenamento[u], strupr(palavra));\par
182             u++;\par
183 \par
184             {\cf18 int} pos = hash_funcao(a);\par
185 \par
186             {\cf20 //cout << tabela[pos].livre << endl;}\par
187             {\cf19 if}(strcmp(tabela[pos].Palavra, palavra) != 0 && tabela[pos].livre == {\cf17 false})\par
188             \{\par
189                pos = colisao_funcao(tabela, pos);\par
190             \}\par
191 \par
192             Atualiza_buffer(tabela, pos, linha, palavra);\par
193 \par
194 \par
195             {\cf19 for}({\cf18 int} j = 0; j <= i; j++ )\par
196             \{\par
197                {\cf20 //cout << a[j];}\par
198                 a[j] = {\cf23 ' '};\par
199             \}\par
200             i = 0;\par
201            {\cf20 //cout <<endl;}\par
202             \}\par
203         \}\par
204         {\cf19 else}\par
205         \{\par
206          i++;\par
207         \}\par
208 \par
209 \par
210     \}\par
211 \par
212 \par
213 \par
214     {\cf20 //ordenamento das palavras do arquivo}\par
215 {\cf18 int} total = u;\par
216 {\cf20 //system("PAUSE > null");}\par
217 \par
218 \par
219 {\cf18 char} *aux = ({\cf18 char}*) {\cf17 new} {\cf18 char};\par
220 \par
221 {\cf19 for}({\cf18 int} r = 0; r < u; r++)\par
222 \{\par
223     {\cf19 for}({\cf18 int} s = r+1; s < u; s++)\par
224     \{\par
225         {\cf19 if} (strcmp(vetor_pra_ordenamento[r],vetor_pra_ordenamento[s])>0)\par
226             \{\par
227                strcpy(aux,vetor_pra_ordenamento[s]);\par
228                strcpy(vetor_pra_ordenamento[s],vetor_pra_ordenamento[r]);\par
229                strcpy(vetor_pra_ordenamento[r], aux);\par
230             \}\par
231     \}\par
232 \par
233 \}\par
234 \par
235 \par
236 {\cf19 for}({\cf18 int} q = 0; q < u; q++)\par
237 \{\par
238   {\cf20 //   cout << vetor_pra_ordenamento[q] << endl;}\par
239 \par
240 \}\par
241 \par
242 \par
243 \par
244 {\cf19 for}({\cf18 int} p = 0; p < u - 1; p++)\par
245 \{\par
246 \par
247 \par
248     {\cf19 if}(strcmp(vetor_pra_ordenamento[p], vetor_pra_ordenamento[p+1]) == 0)\par
249     \{\par
250     {\cf20 //cout << strcmp(vetor_pra_ordenamento[p], vetor_pra_ordenamento[p+1]) << endl;}\par
251     {\cf20 //cout << u << endl;}\par
252     {\cf20 //cout << vetor_pra_ordenamento[p] << "||" << vetor_pra_ordenamento[p+ 1] << endl;}\par
253 \par
254         {\cf19 for}(i= p ; i < u - 1; i++)\par
255         \{\par
256             {\cf20 //cout << vetor_pra_ordenamento[i] << "||" << vetor_pra_ordenamento[i+ 1] << "SDXSZ" << endl ;}\par
257             strcpy(vetor_pra_ordenamento[i],vetor_pra_ordenamento[i+1]);\par
258             {\cf20 //cout << vetor_pra_ordenamento[i] << "||" << vetor_pra_ordenamento[i+ 1] << endl;}\par
259            {\cf20 // system("PAUSE > null");}\par
260         \}\par
261           u--;\par
262           p--;\par
263 \par
264     \}\par
265 \par
266 \}\par
267 \par
268 {\cf20 /*}\par
269 {\cf20 for(int q = 0; q < u; q++)}\par
270 {\cf20 \{}\par
271 {\cf20     cout << vetor_pra_ordenamento[q] << endl;}\par
272 {\cf20 }\par
273 {\cf20 \}}\par
274 {\cf20 */}\par
275 \par
276   arquivoentrada.close();\par
277 \par
278   {\cf20 //ARQUIVO *arquivo = (ARQUIVO*) new ARQUIVO;}\par
279   strcpy(arquivo->nome_arquivo, nome);\par
280   arquivo->quantidade_palavras = total;\par
281   arquivo->quantidade_palavras_nao_repetidas = u;\par
282   arquivo->Palavras_organizadas = vetor_pra_ordenamento;\par
283   arquivo->numero_do_arquivo++;\par
284 \par
285 \par
286 {\cf19 return} {\cf17 true};\par
287 \par
288 {\cf20 /*}\par
289 {\cf20 cout << tabela[152].Palavra << endl;}\par
290 {\cf20 cout << tabela[152].quantidade << endl << endl;}\par
291 {\cf20 for(int k = 0; k < tabela[152].quantidade; k++)}\par
292 {\cf20 \{}\par
293 {\cf20     cout << tabela[152].linha[k] << endl;}\par
294 {\cf20 }\par
295 {\cf20 \}}\par
296 {\cf20 */}\par
297 \}\par
}
}
{\xe \v hash_funcao\:teste.h}
{\xe \v teste.h\:hash_funcao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int hash_funcao (char * palavra)}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 92 \{\par
93    {\cf20 // system("PAUSE > null");}\par
94     palavra = strupr(palavra);\par
95     {\cf18 int} cont = 0, r = 0;\par
96     {\cf19 while}(palavra[r] != {\cf23 '\\0'})\par
97     \{\par
98         r++;\par
99     \}\par
100     {\cf19 for}({\cf18 int} j = 0; j < r; j++)\par
101     \{\par
102         cont = cont + palavra[j];\par
103     \}\par
104     {\cf19 if}(cont < 0)\par
105     \{\par
106     cont = (-1) * cont;\par
107     \}\par
108     {\cf20 //cout<< cont<< endl;}\par
109     {\cf19 return} ({\cf18 unsigned} {\cf18 int})  cont;\par
110 \par
111 \}\par
}
}
{\xe \v Imprimir_Ajuda\:teste.h}
{\xe \v teste.h\:Imprimir_Ajuda}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Imprimir_Ajuda ()}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15 \par
16     cout << {\cf22 "op\'E7\'F5es:"} << endl;\par
17     cout << {\cf22 " ##Modo de Gerenciamento de Busca:"} << endl << endl;\par
18     cout <<{\cf22 "-h ou --ajuda: mostra essa tela e sai."} << endl\par
19      << {\cf22 "-i ou --Inserir: Inserir novo arquivo na base de dados."} << endl\par
20      << {\cf22 "-r ou --Remover: Remover arquivo na base de dados."} << endl << endl;\par
21 \par
22      cout << {\cf22 "Exibi\'E7\'E3o da base de arquivo:"} << endl << endl\par
23      << {\cf22 "-e ou --List_Insercao: Listar todos os arquivos da base tendo como base a ordem de Insercao."} << endl\par
24      << {\cf22 "-a ou --List_Alfabetico: Listar todos os arquivos da base tendo como base a ordem alfab\'E9tica."} << endl\par
25      << {\cf22 "-p ou --List_Quant_Palavras: Listar todos os arquivos da base tendo como base A ordem decrescente da quantidade de palavras do arquivo."} << endl << endl;\par
26 \par
27     cout << {\cf22 " ##Modo de Buscas:"} << endl << endl;\par
28 \par
29     cout << {\cf22 "Argumento de Busca:"} << endl << endl\par
30     << {\cf22 "-d ou --bAND _And:A busca \'E9 feita por linhas dos arquivos texto que cont\'E9m todas as palavras chave passadas como argumento de entrada."} << endl\par
31     << {\cf22 "-o ou --bOR : A busca \'E9 feita por linhas dos arquivos texto que cont\'E9m ao menos uma das palavras chave passadas como argumento de entrada."} << endl;\par
32 \par
33     cout << {\cf22 "Exibi\'E7\'E3o do resultado da busca:"} << endl << endl\par
34     << {\cf22 "-b ou --Impress_Alfabetica: A impress\'E3o \'E9 feita exibindo os resultados em ordem alfab\'E9tica do nome do arquivo."} << endl\par
35     << {\cf22 "-q ou --Impress_Quant_Palavras: A impress\'E3o \'E9 feita exibindo os resultados em ordem decrescente do n\'FAmero de vezes que as palavraschave ocorreram em cada arquivo."} << endl\par
36     << {\cf22 "-c ou --Impress_Insercao: A impress\'E3o \'E9 feita exibindo os resultados na ordem em que cada arquivo foi inserido na base."} << endl;\par
37 \par
38     cout << {\cf22 "Contabiliza\'E7\'E3o do tempo:"} << endl << endl\par
39     << {\cf22 "-s ou --Temp_S: O programa deve registrar e exibir o tempo total de execu\'E7\'E3o de da busca."} << endl\par
40     << {\cf22 "-n ou --Temp_N: O programa n\'E3o deve registrar nem exibir o tempo total de execu\'E7\'E3o da busca."} << endl;\par
41 \}\par
}
}
{\xe \v Inicializar_Hash\:teste.h}
{\xe \v teste.h\:Inicializar_Hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Hash ({\b Tabela_Hash} tabela)}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 47 \{\par
48 \par
49 \par
50     {\cf19 for}({\cf18 int} i = 0; i < TAMANHO; i++)\par
51       \{\par
52        tabela[i].quantidade = 0;\par
53        tabela[i].livre = {\cf17 true};\par
54        tabela[i].prox = NULL;\par
55        tabela[i].ant = NULL;\par
56        {\cf19 for}({\cf18 int} j = 0; j < QUANTIDADE_DE_LINHAS; j++)\par
57        \{\par
58            tabela[i].linha[j] = 0;\par
59        \}\par
60        \}\par
61 \par
62 \}\par
}
}
{\xe \v Inicializar_Lista\:teste.h}
{\xe \v teste.h\:Inicializar_Lista}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Lista ({\b LISTA} * lista)}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 75 \{\par
76     lista->ini = NULL;\par
77     lista->fim = NULL;\par
78     lista->Quantidade_de_Arquivos = 0;\par
79 \}\par
}
}
{\xe \v Inicializar_Vetor_arquivo\:teste.h}
{\xe \v teste.h\:Inicializar_Vetor_arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Vetor_arquivo ({\b ARQUIVO} * arquivo)}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 66 \{\par
67 \par
68     arquivo->numero_do_arquivo = 0;\par
69     arquivo->quantidade_palavras = 0;\par
70     arquivo->quantidade_palavras_nao_repetidas = 0;\par
71 \}\par
}
}
{\xe \v is_empty\:teste.h}
{\xe \v teste.h\:is_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool is_empty (std::ifstream & pFile)}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 114 \{\par
115 {\cf19 return} pFile.peek() == std::ifstream::traits_type::eof();\par
116 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
teste.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef _TESTE_H_}\par
2 {\cf21 #define TESTE_H_}\par
3 {\cf21 #define TAMANHO 2000                }{\cf20 // TABELA HASH INICIAL - PARA PR\'C9-PROCESSAMENTO}\par
4 {\cf21 #define QUANTIDADE_DE_LINHAS 200    }{\cf20 // POR ARQUIVO}\par
5 {\cf21 #define TAMANHO_DA_PALAVRA 35}\par
6 {\cf21 #define TAMANHO_DO_CONTROLE 100}\par
7 {\cf21 #define TAMANHO_VETOR_TEMPORARIO  500}\par
8 {\cf21 #define TAMANHO_DA_FRASE    200}\par
9 \par
10 \par
11 {\cf17 typedef} {\cf17 struct }nos\par
12 \{\par
13     {\cf18 char} Palavra[TAMANHO_DA_PALAVRA];\par
14     {\cf18 char} Arquivo[TAMANHO_DA_PALAVRA];\par
15     {\cf18 int}  quantidade;\par
16     {\cf18 int} linha[QUANTIDADE_DE_LINHAS];\par
17     {\cf18 int} total_de_vezes_palavra;            {\cf20 //quant \'E9 sem repeti\'E7\'E3o e total \'E9 com repeti\'E7\'E3o;}\par
18     {\cf18 bool} livre;\par
19     nos *prox;\par
20     nos *ant;\par
21 \par
22 \}Dados;\par
23 \par
24 {\cf17 typedef} Dados Tabela_Hash[TAMANHO];\par
25 {\cf17 typedef} Dados *Hash[TAMANHO];\par
26 \par
27 \par
28 {\cf17 typedef} {\cf17 struct }dado\par
29 \{\par
30     {\cf18 char} *nome_arquivo;\par
31     {\cf18 int} quantidade_palavras;\par
32     {\cf18 int} quantidade_palavras_nao_repetidas;\par
33     {\cf18 char} **Palavras_organizadas;\par
34     {\cf18 int} numero_do_arquivo;\par
35     {\cf20 //int numero_de_arquivos;}\par
36     {\cf20 //Dados *dados;}\par
37 \par
38 \}ARQUIVO;\par
39 \par
40 {\cf17 typedef} {\cf17 struct }no\par
41 \{\par
42     no *prox;\par
43     no *ant;\par
44     ARQUIVO *arquivo;\par
45 \}NoLISTA;\par
46 \par
47 {\cf17 typedef} {\cf17 struct}\par
48 \{\par
49     no *ini;\par
50     no *fim;\par
51     {\cf18 int} Quantidade_de_Arquivos;\par
52 \}LISTA;\par
53 \par
54 {\cf20 /*}\par
55 {\cf20 typedef struct no}\par
56 {\cf20 \{}\par
57 {\cf20 }\par
58 {\cf20     int quantidade_palavras}\par
59 {\cf20     Dados *palavra;}\par
60 {\cf20     no *prox;}\par
61 {\cf20     no *ant;}\par
62 {\cf20 \}PALAVRAS;}\par
63 {\cf20 }\par
64 {\cf20 */}\par
65 \par
66 {\cf18 void} Imprimir_Ajuda();\par
67 \par
68 {\cf18 void} Inicializar_Hash(Tabela_Hash tabela);\par
69 {\cf18 void} Inicializar_Vetor_arquivo(ARQUIVO *arquivo);\par
70 {\cf18 void} Inicializar_Lista(LISTA * lista);\par
71 \par
72 {\cf18 bool} is_empty(std::ifstream& pFile);\par
73 \par
74 {\cf20 //procedimento de pre processamento de um arquivo na entrada:  como saida temos as struturas tabela e arquivo atualizadas e prontas para serem impressas}\par
75 {\cf18 bool} Dados_Arquivo(Tabela_Hash tabela, ARQUIVO *arquivo, {\cf18 char} *nome);\par
76 {\cf18 void} Atualiza_buffer(Tabela_Hash tabela, {\cf18 int} pos, {\cf18 int} linha, {\cf18 char} palavra[], {\cf18 char} *nome );\par
77 \par
78 \par
79 {\cf20 // tabela hash}\par
80 {\cf18 int} hash_funcao({\cf18 char} *palavra);\par
81 {\cf18 int} colisao_funcao(Tabela_Hash tabela, {\cf18 int} cont);\par
82 \par
83 \par
84 \par
85 {\cf20 //void Remover_Arquivo(char *nome, LISTA *lista);}\par
86 \par
87 {\cf21 #endif }{\cf20 // _TESTE_H_}\par
88 \par
89 \par
90 \par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Sum\'E1rio\par 
\pard\plain 
{\tc \v Sum\'E1rio}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
