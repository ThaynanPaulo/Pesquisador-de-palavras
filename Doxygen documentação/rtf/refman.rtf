{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s6\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info 
{\title {\comment My Project  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}My Project}
{\comment Gerado por doxygen 1.12.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt My Project}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Vers\'E3o 1.0\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Sum\'E1rio\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos Componentes\par \pard\plain 
{\tc \v \'CDndice dos Componentes}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de Classes\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Aqui est\'E3o as classes, estruturas, uni\'F5es e interfaces e suas respectivas descri\'E7\'F5es:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b dado} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LISTA} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b no} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nos} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Quantidade_Palavras} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos Arquivos\par \pard\plain 
{\tc \v \'CDndice dos Arquivos}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de Arquivos\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Esta \'E9 a lista de todos os arquivos e suas respectivas descri\'E7\'F5es:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b apaga.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b apaga.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b Consulta_Base_Arquivos.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b Consulta_Base_Arquivos.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b consulta_palavra.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b consulta_palavra.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b escreve.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b escreve.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b Forma_da_Busca.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b Forma_da_Busca.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b main.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b teste.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b teste.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Classes{\tc \v Classes}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura dado\par \pard\plain 
{\tc\tcl2 \v dado}
{\xe \v dado}
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\par
{
{\f2 #include <teste.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b nome_arquivo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b quantidade_palavras}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b quantidade_palavras_nao_repetidas}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char ** {\b Palavras_organizadas}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b numero_do_arquivo}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v nome_arquivo\:dado}
{\xe \v dado\:nome_arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* dado::nome_arquivo}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v numero_do_arquivo\:dado}
{\xe \v dado\:numero_do_arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int dado::numero_do_arquivo}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Palavras_organizadas\:dado}
{\xe \v dado\:Palavras_organizadas}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char** dado::Palavras_organizadas}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v quantidade_palavras\:dado}
{\xe \v dado\:quantidade_palavras}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int dado::quantidade_palavras}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v quantidade_palavras_nao_repetidas\:dado}
{\xe \v dado\:quantidade_palavras_nao_repetidas}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int dado::quantidade_palavras_nao_repetidas}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b teste.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura LISTA\par \pard\plain 
{\tc\tcl2 \v LISTA}
{\xe \v LISTA}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\par
{
{\f2 #include <teste.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b no} * {\b ini}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b no} * {\b fim}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Quantidade_de_Arquivos}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v fim\:LISTA}
{\xe \v LISTA\:fim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b no}* LISTA::fim}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ini\:LISTA}
{\xe \v LISTA\:ini}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b no}* LISTA::ini}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Quantidade_de_Arquivos\:LISTA}
{\xe \v LISTA\:Quantidade_de_Arquivos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int LISTA::Quantidade_de_Arquivos}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b teste.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura no\par \pard\plain 
{\tc\tcl2 \v no}
{\xe \v no}
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
\par
{
{\f2 #include <teste.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b no} * {\b prox}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b no} * {\b ant}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ARQUIVO} * {\b arquivo}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v ant\:no}
{\xe \v no\:ant}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b no}* no::ant}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v arquivo\:no}
{\xe \v no\:arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ARQUIVO}* no::arquivo}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v prox\:no}
{\xe \v no\:prox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b no}* no::prox}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b teste.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura nos\par \pard\plain 
{\tc\tcl2 \v nos}
{\xe \v nos}
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
\par
{
{\f2 #include <teste.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b Palavra} [{\b TAMANHO_DA_PALAVRA}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b Arquivo} [{\b TAMANHO_DA_PALAVRA}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b quantidade}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b linha} [{\b QUANTIDADE_DE_LINHAS}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b total_de_vezes_palavra}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b livre}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nos} * {\b prox}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nos} * {\b ant}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v ant\:nos}
{\xe \v nos\:ant}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b nos}* nos::ant}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Arquivo\:nos}
{\xe \v nos\:Arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char nos::Arquivo[{\b TAMANHO_DA_PALAVRA}]}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v linha\:nos}
{\xe \v nos\:linha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nos::linha[{\b QUANTIDADE_DE_LINHAS}]}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v livre\:nos}
{\xe \v nos\:livre}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool nos::livre}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Palavra\:nos}
{\xe \v nos\:Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char nos::Palavra[{\b TAMANHO_DA_PALAVRA}]}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v prox\:nos}
{\xe \v nos\:prox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b nos}* nos::prox}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v quantidade\:nos}
{\xe \v nos\:quantidade}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nos::quantidade}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v total_de_vezes_palavra\:nos}
{\xe \v nos\:total_de_vezes_palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nos::total_de_vezes_palavra}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b teste.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Quantidade_Palavras\par \pard\plain 
{\tc\tcl2 \v Quantidade_Palavras}
{\xe \v Quantidade_Palavras}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
\par
{
{\f2 #include <Consulta_Base_Arquivos.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b nome} [{\b TAMANHO_DA_PALAVRA}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b quant}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v nome\:Quantidade_Palavras}
{\xe \v Quantidade_Palavras\:nome}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char Quantidade_Palavras::nome[{\b TAMANHO_DA_PALAVRA}]}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v quant\:Quantidade_Palavras}
{\xe \v Quantidade_Palavras\:quant}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Quantidade_Palavras::quant}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/{\b Consulta_Base_Arquivos.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Arquivos{\tc \v Arquivos}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.cpp}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.cpp}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "teste.h"}\par
{\f2 #include "apaga.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Remove_Log_Palavra} (char *nome_entrada)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Remove_Log_Arquivo} (char *nome_entrada)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Remove_Log_Controle} (char *nome_entrada)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Remove_Log_Arquivo\:apaga.cpp}
{\xe \v apaga.cpp\:Remove_Log_Arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Remove_Log_Arquivo (char * nome_entrada)}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24 \{\par
25     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
26     strcpy(nome, nome_entrada);\par
27     strcat(nome, {\cf22 "LogPal.txt"});\par
28     cout << nome << endl;\par
29     remove({\cf22 "LISTA.TXTLog_Arquivo.txt"});\par
30 \par
31 \}\par
}
}
{\xe \v Remove_Log_Controle\:apaga.cpp}
{\xe \v apaga.cpp\:Remove_Log_Controle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Remove_Log_Controle (char * nome_entrada)}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 35 \{\par
36 \par
37 \par
38 \par
39     {\cf18 int} i =0; {\cf18 int} confirma = 0;\par
40 \par
41     {\cf18 char} nome[TAMANHO_DO_CONTROLE][TAMANHO_DA_PALAVRA];\par
42     {\cf19 for}( {\cf18 int} j = 0; j < TAMANHO_DO_CONTROLE; j++)\par
43     \{\par
44     strcpy(nome[j], {\cf22 " "});\par
45     \}\par
46 \par
47     {\cf18 char} nomes[TAMANHO_DA_PALAVRA];\par
48     strcpy(nomes, nome_entrada);\par
49     strupr(nomes);\par
50 \par
51     ifstream arquivo_ler;\par
52     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
53     {\cf19 if}(!arquivo_ler.is_open())\par
54     \{\par
55        cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que remover."} << endl;\par
56        arquivo_ler.clear();\par
57        {\cf19 return} 0;\par
58     \}\par
59 \par
60     {\cf19 if}(is_empty(arquivo_ler))\par
61     \{\par
62         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que remover."} << endl;\par
63         {\cf20 //system("PAUSE > null");}\par
64         {\cf19 return} 0;\par
65     \}\par
66     {\cf19 else}\par
67     \{\par
68 \par
69         {\cf19 while}(! arquivo_ler.eof())      {\cf20 //BUSCA SEQUENCIAL ITERATIVA DENTRO DO ARQUIVO PELO NOME - SE FOR IGUAL REMOVE SE N\'C3O, MANT\'C9M O ARQUIVO COMO O ORIGINAL}\par
70         \{\par
71 \par
72 \par
73                 arquivo_ler >> nome[i];\par
74                 {\cf20 /*cout << nome[i] << endl;}\par
75 {\cf20                 cout << nomes << endl;}\par
76 {\cf20                 cout << "cfscasmdksa" <<endl;}\par
77 {\cf20                 system("PAUSE > null");}\par
78 {\cf20                 */}\par
79 \par
80 \par
81                 {\cf19 if}(strcmp(nome[i], nomes) == 0)\par
82                 \{\par
83                     {\cf19 for}({\cf18 int} t = 0; t < 2; t++)\par
84                     \{\par
85                         {\cf20 /*}\par
86 {\cf20 }\par
87 {\cf20                         if(remove(nomes) == 0)}\par
88 {\cf20                         \{}\par
89 {\cf20                             cout << "Arquivo removido com sucesso." << endl;}\par
90 {\cf20                         \}}\par
91 {\cf20 }\par
92 {\cf20                         if(remove(strcat(nomes, "LogArq.txt")) == 0)}\par
93 {\cf20                         \{}\par
94 {\cf20                             cout << "swfeqmksd" << endl;}\par
95 {\cf20                         \}}\par
96 {\cf20                         if(remove(strcat(nomes, "LOGPAL.TXT")) == 0)}\par
97 {\cf20                         \{}\par
98 {\cf20                               cout << "tergeksd" << endl;}\par
99 {\cf20                         \}}\par
100 {\cf20                     */}\par
101                     \}\par
102 \par
103 \par
104 \par
105                     {\cf20 //Remove_Log_Palavra(nome_entrada);}\par
106                     {\cf20 //Remove_Log_Arquivo(nome_entrada);}\par
107                     confirma = 1;\par
108                 \}\par
109                 i++;\par
110 \par
111         \}\par
112     \}\par
113 \par
114 arquivo_ler.close();\par
115 \par
116 {\cf20 //cout << i <<endl;}\par
117 {\cf20 //system("PAUSE > null");}\par
118 \par
119 \par
120 {\cf19 if}(confirma == 1)\par
121     \{\par
122 \par
123         {\cf19 if}( i == 1)\par
124         \{\par
125             remove({\cf22 "Log_Controle.txt"});\par
126         \}\par
127         {\cf19 else}\par
128         \{\par
129             ofstream arquivo_escrever;\par
130             arquivo_escrever.open({\cf22 "Log_Controle.txt"});\par
131             {\cf19 if}(!arquivo_escrever.is_open())\par
132             \{\par
133                 cout << {\cf22 "N\'E3o foi encontrado o arquivo:"} << endl;\par
134                 arquivo_escrever.clear();\par
135                 {\cf19 return} 0;\par
136             \}\par
137             {\cf19 else}\par
138             \{\par
139                 {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
140                 \{\par
141                     {\cf19 if}(strcmp(nome[j], nomes) == 0)\par
142                     \{\par
143 \par
144                     \}\par
145                     {\cf19 else}\par
146                     \{\par
147                         arquivo_escrever << nome[j] << {\cf22 " "};\par
148                     \}\par
149 \par
150                 \}\par
151 \par
152             \}\par
153         arquivo_ler.close();\par
154         \}\par
155     \}\par
156     {\cf19 else}\par
157     \{\par
158     ifstream arquivo_ler_tentativa;\par
159     arquivo_ler_tentativa.open(nome_entrada);\par
160     {\cf19 if}(!arquivo_ler_tentativa.is_open())\par
161     \{\par
162        cout << {\cf22 "N\'E3o foi encontrado o arquivo: adicione-o a pasta atual e insira-o."} << endl;\par
163        arquivo_ler.clear();\par
164        {\cf19 return} 0;\par
165     \}\par
166     {\cf19 else}\par
167     \{\par
168         cout << {\cf22 "O arquivo est\'E1 na pasta mais ainda n\'E3o foi adicionado ao banco de arquivos."} << endl;\par
169         {\cf19 return} 0;\par
170     \}\par
171 \par
172 \par
173     \}\par
174 \par
175 \par
176 \par
177 \}\par
}
}
{\xe \v Remove_Log_Palavra\:apaga.cpp}
{\xe \v apaga.cpp\:Remove_Log_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Remove_Log_Palavra (char * nome_entrada)}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
16     strcpy(nome, nome_entrada);\par
17     strcat(nome, {\cf22 "LogPal.txt"});\par
18     cout << nome << endl;\par
19     remove({\cf22 "lista.txtlog_palavra.txt /0"});\par
20 \par
21 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.h}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Remove_Log_Palavra} (char *nome_entrada)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Remove_Log_Arquivo} (char *nome_entrada)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Remove_Log_Controle} (char *nome)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Remove_Log_Arquivo\:apaga.h}
{\xe \v apaga.h\:Remove_Log_Arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Remove_Log_Arquivo (char * nome_entrada)}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24 \{\par
25     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
26     strcpy(nome, nome_entrada);\par
27     strcat(nome, {\cf22 "LogPal.txt"});\par
28     cout << nome << endl;\par
29     remove({\cf22 "LISTA.TXTLog_Arquivo.txt"});\par
30 \par
31 \}\par
}
}
{\xe \v Remove_Log_Controle\:apaga.h}
{\xe \v apaga.h\:Remove_Log_Controle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Remove_Log_Controle (char * nome)}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 35 \{\par
36 \par
37 \par
38 \par
39     {\cf18 int} i =0; {\cf18 int} confirma = 0;\par
40 \par
41     {\cf18 char} nome[TAMANHO_DO_CONTROLE][TAMANHO_DA_PALAVRA];\par
42     {\cf19 for}( {\cf18 int} j = 0; j < TAMANHO_DO_CONTROLE; j++)\par
43     \{\par
44     strcpy(nome[j], {\cf22 " "});\par
45     \}\par
46 \par
47     {\cf18 char} nomes[TAMANHO_DA_PALAVRA];\par
48     strcpy(nomes, nome_entrada);\par
49     strupr(nomes);\par
50 \par
51     ifstream arquivo_ler;\par
52     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
53     {\cf19 if}(!arquivo_ler.is_open())\par
54     \{\par
55        cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que remover."} << endl;\par
56        arquivo_ler.clear();\par
57        {\cf19 return} 0;\par
58     \}\par
59 \par
60     {\cf19 if}(is_empty(arquivo_ler))\par
61     \{\par
62         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que remover."} << endl;\par
63         {\cf20 //system("PAUSE > null");}\par
64         {\cf19 return} 0;\par
65     \}\par
66     {\cf19 else}\par
67     \{\par
68 \par
69         {\cf19 while}(! arquivo_ler.eof())      {\cf20 //BUSCA SEQUENCIAL ITERATIVA DENTRO DO ARQUIVO PELO NOME - SE FOR IGUAL REMOVE SE N\'C3O, MANT\'C9M O ARQUIVO COMO O ORIGINAL}\par
70         \{\par
71 \par
72 \par
73                 arquivo_ler >> nome[i];\par
74                 {\cf20 /*cout << nome[i] << endl;}\par
75 {\cf20                 cout << nomes << endl;}\par
76 {\cf20                 cout << "cfscasmdksa" <<endl;}\par
77 {\cf20                 system("PAUSE > null");}\par
78 {\cf20                 */}\par
79 \par
80 \par
81                 {\cf19 if}(strcmp(nome[i], nomes) == 0)\par
82                 \{\par
83                     {\cf19 for}({\cf18 int} t = 0; t < 2; t++)\par
84                     \{\par
85                         {\cf20 /*}\par
86 {\cf20 }\par
87 {\cf20                         if(remove(nomes) == 0)}\par
88 {\cf20                         \{}\par
89 {\cf20                             cout << "Arquivo removido com sucesso." << endl;}\par
90 {\cf20                         \}}\par
91 {\cf20 }\par
92 {\cf20                         if(remove(strcat(nomes, "LogArq.txt")) == 0)}\par
93 {\cf20                         \{}\par
94 {\cf20                             cout << "swfeqmksd" << endl;}\par
95 {\cf20                         \}}\par
96 {\cf20                         if(remove(strcat(nomes, "LOGPAL.TXT")) == 0)}\par
97 {\cf20                         \{}\par
98 {\cf20                               cout << "tergeksd" << endl;}\par
99 {\cf20                         \}}\par
100 {\cf20                     */}\par
101                     \}\par
102 \par
103 \par
104 \par
105                     {\cf20 //Remove_Log_Palavra(nome_entrada);}\par
106                     {\cf20 //Remove_Log_Arquivo(nome_entrada);}\par
107                     confirma = 1;\par
108                 \}\par
109                 i++;\par
110 \par
111         \}\par
112     \}\par
113 \par
114 arquivo_ler.close();\par
115 \par
116 {\cf20 //cout << i <<endl;}\par
117 {\cf20 //system("PAUSE > null");}\par
118 \par
119 \par
120 {\cf19 if}(confirma == 1)\par
121     \{\par
122 \par
123         {\cf19 if}( i == 1)\par
124         \{\par
125             remove({\cf22 "Log_Controle.txt"});\par
126         \}\par
127         {\cf19 else}\par
128         \{\par
129             ofstream arquivo_escrever;\par
130             arquivo_escrever.open({\cf22 "Log_Controle.txt"});\par
131             {\cf19 if}(!arquivo_escrever.is_open())\par
132             \{\par
133                 cout << {\cf22 "N\'E3o foi encontrado o arquivo:"} << endl;\par
134                 arquivo_escrever.clear();\par
135                 {\cf19 return} 0;\par
136             \}\par
137             {\cf19 else}\par
138             \{\par
139                 {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
140                 \{\par
141                     {\cf19 if}(strcmp(nome[j], nomes) == 0)\par
142                     \{\par
143 \par
144                     \}\par
145                     {\cf19 else}\par
146                     \{\par
147                         arquivo_escrever << nome[j] << {\cf22 " "};\par
148                     \}\par
149 \par
150                 \}\par
151 \par
152             \}\par
153         arquivo_ler.close();\par
154         \}\par
155     \}\par
156     {\cf19 else}\par
157     \{\par
158     ifstream arquivo_ler_tentativa;\par
159     arquivo_ler_tentativa.open(nome_entrada);\par
160     {\cf19 if}(!arquivo_ler_tentativa.is_open())\par
161     \{\par
162        cout << {\cf22 "N\'E3o foi encontrado o arquivo: adicione-o a pasta atual e insira-o."} << endl;\par
163        arquivo_ler.clear();\par
164        {\cf19 return} 0;\par
165     \}\par
166     {\cf19 else}\par
167     \{\par
168         cout << {\cf22 "O arquivo est\'E1 na pasta mais ainda n\'E3o foi adicionado ao banco de arquivos."} << endl;\par
169         {\cf19 return} 0;\par
170     \}\par
171 \par
172 \par
173     \}\par
174 \par
175 \par
176 \par
177 \}\par
}
}
{\xe \v Remove_Log_Palavra\:apaga.h}
{\xe \v apaga.h\:Remove_Log_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Remove_Log_Palavra (char * nome_entrada)}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
16     strcpy(nome, nome_entrada);\par
17     strcat(nome, {\cf22 "LogPal.txt"});\par
18     cout << nome << endl;\par
19     remove({\cf22 "lista.txtlog_palavra.txt /0"});\par
20 \par
21 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
apaga.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/apaga.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef _APAGA_H_}\par
2 {\cf21 #define _APAGA_H_}\par
3 \par
4 {\cf18 void} Remove_Log_Palavra({\cf18 char} *nome_entrada);\par
5 {\cf18 void} Remove_Log_Arquivo({\cf18 char} *nome_entrada);\par
6 {\cf18 bool} Remove_Log_Controle({\cf18 char} *nome);\par
7 \par
8 \par
9 {\cf21 #endif}\par
10 \par
11 \par
12 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.cpp}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.cpp}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "teste.h"}\par
{\f2 #include "Consulta_Base_Arquivos.h"}\par
{\f2 #include "consulta_palavra.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b func}) ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Insercao} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Alfabetica} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Alfabetica} ({\b Hash} tabela, char *nome)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b recupera_numero_Palavras} ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Ordena_Vetor_Quantidade_Palavra} ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Apresenta_Vetor_Quantidade_Palavra} ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Quantidade_Palavras} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es dos tipos\par
\pard\plain 
{\xe \v func\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:func}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* func) ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Apresenta_Vetor_Quantidade_Palavra\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:Apresenta_Vetor_Quantidade_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apresenta_Vetor_Quantidade_Palavra ({\b Ordena_Quant_Palavra} * vetor, int Numero_Palavra_Arquivo_Log)}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 393 \{\par
394 \par
395 \par
396 \par
397     {\cf19 for}({\cf18 int} j = Numero_Palavra_Arquivo_Log - 1; j >= 0; j--)\par
398     \{\par
399         cout << {\cf22 "-"} << vetor[j].nome << {\cf22 " "} << vetor[j].quant << endl;\par
400 \par
401     \}\par
402 \par
403 \par
404 \par
405 \}\par
}
}
{\xe \v Consulta_Base_Alfabetica\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:Consulta_Base_Alfabetica}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Alfabetica ()}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 53 \{\par
54     {\cf18 char} nome[TAMANHO_DA_PALAVRA][TAMANHO_DO_CONTROLE];\par
55     {\cf18 int} i = 0;\par
56     ifstream arquivo_ler;\par
57     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
58     {\cf19 if}(!arquivo_ler.is_open())\par
59     \{\par
60        cout << {\cf22 "O banco de arquivo est\'E1 vazio, n\'E3o h\'E1 o que apresentar."} << endl;\par
61        {\cf20 //arquivo_ler.clear();}\par
62        {\cf19 return} 0;\par
63     \}\par
64     {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
65     \{\par
66         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 arquivos no banco de arquivos para ser apresentado."} << endl;\par
67         {\cf19 return} 0;\par
68         {\cf20 //system("PAUSE > null");}\par
69     \}\par
70     {\cf19 else}\par
71     \{\par
72         {\cf19 while}(! arquivo_ler.eof())\par
73         \{\par
74             arquivo_ler >> nome[i];\par
75             i++;\par
76         \}\par
77 \par
78         arquivo_ler.close();\par
79 \par
80         {\cf18 char} aux[TAMANHO_DA_PALAVRA];\par
81 \par
82         {\cf19 for}({\cf18 int} r = 0; r < i; r++)              {\cf20 // ordenando os arquivos tendo como base a ordem alfab\'E9tica}\par
83         \{\par
84             {\cf19 for}({\cf18 int} s = r+1; s < i; s++)\par
85             \{\par
86                 {\cf19 if} (strcmp(nome[r],nome[s])>0)\par
87                     \{\par
88                        strcpy(aux,nome[s]);\par
89                        strcpy(nome[s],nome[r]);\par
90                        strcpy(nome[r], aux);\par
91                     \}\par
92             \}\par
93 \par
94         \}\par
95 \par
96 \par
97         {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
98         \{\par
99                 cout << {\cf22 "-"} << nome[j] << endl;\par
100         \}\par
101 \par
102     \}\par
103 \par
104 \par
105 \}\par
}
}
{\xe \v Consulta_Base_Alfabetica\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:Consulta_Base_Alfabetica}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Alfabetica ({\b Hash} tabela, char * nome)}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 109 \{\par
110 \par
111 \par
112     {\cf18 int} contador_linhas = 0, linha_correta_atual = 0;\par
113 \par
114     {\cf18 char} nome_palavra[TAMANHO_DA_PALAVRA];\par
115     strcpy(nome_palavra, nome);\par
116     strupr(nome_palavra);\par
117 \par
118     {\cf18 int} pos = hash_funcao(nome_palavra);\par
119     {\cf18 char} linha[TAMANHO_DA_FRASE];\par
120     Dados *aux1, *aux2, *aux3, *aux4, *aux5, *aux6;\par
121     aux1 = tabela[pos];\par
122     aux2 = tabela[pos]->prox;\par
123 \par
124     cout << tabela[pos]->Arquivo << endl;\par
125     cout << tabela[pos]->prox->Arquivo << endl;\par
126     cout << tabela[pos]->prox->prox->Arquivo << endl <<endl;\par
127     cout << aux1->Arquivo << endl;\par
128     cout << aux2->Arquivo << endl <<endl;\par
129 \par
130     system({\cf22 "PAUSE > null"});\par
131     {\cf19 while}(aux1->prox != NULL)\par
132     \{\par
133 \par
134 \par
135         {\cf19 while}(aux2 != NULL)\par
136         \{\par
137 \par
138             cout << tabela[pos]->Arquivo << endl;\par
139             cout << tabela[pos]->prox->Arquivo << endl;\par
140             cout << tabela[pos]->prox->prox->Arquivo << endl <<endl;\par
141             cout << aux1->Arquivo << endl;\par
142             cout << aux2->Arquivo << endl <<endl;\par
143 \par
144 \par
145 \par
146             {\cf19 if}(strcmp(aux1->Arquivo, aux2->Arquivo) > 0)\par
147             \{\par
148 \par
149 \par
150                 {\cf19 if}(aux1->prox == aux2)\par
151                 \{\par
152                     {\cf19 if}(aux1->ant == NULL && aux2->prox == NULL)\par
153                     \{\par
154 \par
155                         cout<< {\cf22 "kl\'E7sda"} << endl;\par
156                         system({\cf22 "PAUSE > null"});\par
157                         aux3->prox = aux2;\par
158 \par
159 \par
160 \par
161 \par
162                     \}\par
163                     {\cf19 else} {\cf19 if}(aux1->ant == NULL && aux2->prox != NULL)\par
164                     \{\par
165 \par
166 \par
167 \par
168                         {\cf20 //aux3 = aux1->ant; = \'E9 NULL;}\par
169                         aux3 = aux2->prox;\par
170                         aux3->ant = aux1;\par
171                         aux1->prox  = aux3;\par
172                         aux2->prox = aux1;\par
173                         aux2->ant = NULL;\par
174 \par
175 \par
176                     \}\par
177                     {\cf19 else} {\cf19 if}(aux1->ant != NULL && aux2->prox == NULL)\par
178                     \{\par
179 \par
180 \par
181                         aux3 = aux1->prox;\par
182                         aux4 = aux1->ant;\par
183 \par
184                         aux5 = aux2->prox;     {\cf20 //NULL}\par
185                         aux6 = aux2->ant;\par
186 \par
187                         aux6->prox = aux1;\par
188                         aux1->prox = NULL;\par
189                         aux1->ant = aux6;\par
190 \par
191                         aux3->ant = aux2;\par
192                         aux4->prox = aux2;\par
193                         aux2->prox = aux3;\par
194                         aux2->ant = aux4;\par
195 \par
196                     \}\par
197                     {\cf19 else}\par
198                     \{\par
199 \par
200                         aux3 = aux1->prox;\par
201                         aux4 = aux1->ant;\par
202 \par
203                         aux5 = aux2->prox;     {\cf20 //NULL}\par
204                         aux6 = aux2->ant;\par
205 \par
206 \par
207                         aux6->prox = aux1;\par
208                         aux5->ant  = aux1;\par
209                         aux1->prox = aux5;\par
210                         aux2->ant  = aux6;\par
211 \par
212                         aux3->ant = aux2;\par
213                         aux4->prox = aux2;\par
214                         aux2->prox = aux3;\par
215                         aux2->ant = aux4;\par
216                     \}\par
217 \par
218                 \}\par
219                 {\cf19 else}\par
220                 \{\par
221                     {\cf19 if}(aux1->ant == NULL && aux2->prox == NULL)\par
222                     \{\par
223 \par
224                         cout<< {\cf22 "kl\'E7sda"} << endl;\par
225                         system({\cf22 "PAUSE > null"});\par
226 \par
227                         aux3 = aux1->prox;\par
228                         aux4 = aux1->ant;   {\cf20 //NULL}\par
229 \par
230                         aux5 = aux2->prox;  {\cf20 //NULL}\par
231                         aux6 = aux2->ant;\par
232 \par
233                         aux6->prox = aux1;\par
234                         aux1->ant = aux6;\par
235                         aux1->prox = NULL;\par
236 \par
237                         aux3->ant = aux2;\par
238                         aux2->prox = aux3;\par
239                         aux2->ant = NULL;\par
240                     \}\par
241                     {\cf19 else} {\cf19 if}(aux1->ant == NULL && aux2->prox != NULL)\par
242                     \{\par
243 \par
244 \par
245 \par
246                         aux3 = aux1->prox;\par
247                         aux4 = aux1->ant;   {\cf20 //NULL}\par
248 \par
249                         aux5 = aux2->prox;\par
250                         aux6 = aux2->ant;\par
251 \par
252                         aux3->ant = aux2;\par
253                         aux2->ant = NULL;\par
254                         aux2->prox = aux3;\par
255 \par
256 \par
257 \par
258 \par
259 \par
260                         aux1->prox = aux5;\par
261                         aux1->ant  = aux6;\par
262                         aux6->prox = aux1;\par
263                         aux5->ant  = aux1;\par
264 \par
265 \par
266                     \}\par
267                     {\cf19 else} {\cf19 if}(aux1->ant != NULL && aux2->prox == NULL)\par
268                     \{\par
269 \par
270 \par
271                         aux3 = aux1->prox;\par
272                         aux4 = aux1->ant;\par
273 \par
274                         aux5 = aux2->prox;     {\cf20 //NULL}\par
275                         aux6 = aux2->ant;\par
276 \par
277                         aux6->prox = aux1;\par
278                         aux1->prox = NULL;\par
279                         aux1->ant = aux6;\par
280 \par
281                         aux3->ant = aux2;\par
282                         aux4->prox = aux2;\par
283                         aux2->prox = aux3;\par
284                         aux2->ant = aux4;\par
285 \par
286                     \}\par
287                     {\cf19 else}\par
288                     \{\par
289 \par
290                         aux3 = aux1->prox;\par
291                         aux4 = aux1->ant;\par
292 \par
293                         aux5 = aux2->prox;     {\cf20 //NULL}\par
294                         aux6 = aux2->ant;\par
295 \par
296 \par
297                         aux6->prox = aux1;\par
298                         aux5->ant  = aux1;\par
299                         aux1->prox = aux5;\par
300                         aux2->ant  = aux6;\par
301 \par
302                         aux3->ant = aux2;\par
303                         aux4->prox = aux2;\par
304                         aux2->prox = aux3;\par
305                         aux2->ant = aux4;\par
306                     \}\par
307 \par
308             cout << tabela[pos]->Arquivo << endl;\par
309             cout << tabela[pos]->prox->Arquivo << endl;\par
310             cout << tabela[pos]->prox->prox->Arquivo << endl <<endl;\par
311             cout << aux1->Arquivo << endl;\par
312             cout << aux2->Arquivo << endl <<endl;\par
313 \par
314 \par
315                 \}\par
316 \par
317             \}\par
318 \par
319 \par
320             aux2 = aux2->prox;\par
321 \par
322         \}\par
323 \par
324         aux1 = aux1->prox;\par
325         aux2 = aux1->prox;\par
326 \par
327 \par
328     \}\par
329 \par
330 \}\par
}
}
{\xe \v Consulta_Base_Insercao\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:Consulta_Base_Insercao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Insercao ()}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16 \{\par
17     {\cf18 char} nome[TAMANHO_DA_PALAVRA][TAMANHO_DO_CONTROLE];\par
18     {\cf18 int} i = 0;\par
19     ifstream arquivo_ler;\par
20     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
21     {\cf19 if}(!arquivo_ler.is_open())\par
22     \{\par
23        cout << {\cf22 "O banco de arquivo est\'E1 vazio, n\'E3o h\'E1 o que apresentar."} << endl;\par
24        arquivo_ler.clear();\par
25        {\cf19 return} 0;\par
26     \}\par
27     {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
28     \{\par
29         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 arquivos no banco de arquivos para ser apresentado."} << endl;\par
30         {\cf19 return} 0;\par
31     \}\par
32     {\cf19 else}\par
33     \{\par
34         {\cf19 while}(! arquivo_ler.eof())\par
35         \{\par
36             arquivo_ler >> nome[i];\par
37             i++;\par
38         \}\par
39 \par
40     arquivo_ler.close();\par
41 \par
42     {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
43     \{\par
44         cout << {\cf22 "-"} << nome[j] << endl;\par
45     \}\par
46 \par
47     \}\par
48 \par
49 \par
50 \}\par
}
}
{\xe \v Consulta_Base_Quantidade_Palavras\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:Consulta_Base_Quantidade_Palavras}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Quantidade_Palavras ()}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 408 \{\par
409 \par
410 \par
411     Ordena_Quant_Palavra vetor[TAMANHO_DO_CONTROLE];\par
412     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
413 \par
414     {\cf18 int} i = 0;\par
415     ifstream arquivo_ler;\par
416     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
417     {\cf19 if}(!arquivo_ler.is_open())\par
418     \{\par
419         cout << {\cf22 "O banco de arquivo est\'E1 vazio, n\'E3o h\'E1 o que apresentar."} << endl;\par
420         arquivo_ler.clear();\par
421         {\cf19 return} 0;\par
422     \}\par
423     {\cf20 /*}\par
424 {\cf20     else if(is_empty(arquivo_ler))}\par
425 {\cf20     \{}\par
426 {\cf20         cout << "arquivo vazio, n\'E3o h\'E1 o que remover." << endl;}\par
427 {\cf20         system("PAUSE > null");}\par
428 {\cf20     \}}\par
429 {\cf20     */}\par
430     {\cf19 else}\par
431     \{\par
432 \par
433         {\cf19 while}(! arquivo_ler.eof())\par
434         \{\par
435             arquivo_ler >> nome;{\cf20 // abrindo arquivo  com dados do arquivo}\par
436             strcpy(vetor[i].nome, nome);\par
437             {\cf20 //cout << i << endl;}\par
438             i++;\par
439 \par
440         \}\par
441     \}\par
442 \par
443 \par
444 \par
445 arquivo_ler.close();\par
446 \par
447 \par
448 \par
449 \par
450 {\cf20 //cout << "nijlads" << endl;}\par
451 {\cf20 //system("PAUSE > null");}\par
452 \par
453 func funcoes;           {\cf20 // exemplo de ponteiro de fun\'E7\'E3o - usado para facilitar o manuseio das etapas necess\'E1rias a apresenta\'E7\'E3o dos arquivos ordenados por quantidade de palavras}\par
454 \par
455 funcoes = recupera_numero_Palavras;\par
456 funcoes(vetor, i);\par
457 \par
458 funcoes = Ordena_Vetor_Quantidade_Palavra;\par
459 funcoes(vetor, i);\par
460 \par
461 funcoes = Apresenta_Vetor_Quantidade_Palavra;\par
462 funcoes(vetor, i);\par
463 \par
464 \par
465 \par
466 \par
467 \par
468 \par
469 \par
470 \par
471 \par
472 \}\par
}
}
{\xe \v Ordena_Vetor_Quantidade_Palavra\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:Ordena_Vetor_Quantidade_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Ordena_Vetor_Quantidade_Palavra ({\b Ordena_Quant_Palavra} * vetor, int Numero_Palavra_Arquivo_Log)}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 371 \{\par
372     Ordena_Quant_Palavra aux[1];\par
373 \par
374     {\cf20 //cout << i<< "dasds" << endl;}\par
375     {\cf20 //system("PAUSE > null");}\par
376 \par
377     {\cf19 for}({\cf18 int} r = 0; r < Numero_Palavra_Arquivo_Log; r++)          {\cf20 //ordenando tendo como base a quantidade de  palavras (descescente}\par
378     \{\par
379         {\cf19 for}({\cf18 int} s = r+1; s < Numero_Palavra_Arquivo_Log; s++)\par
380         \{\par
381             {\cf19 if} (vetor[r].quant > vetor[s].quant)\par
382                 \{\par
383                     aux[0] = vetor[r];\par
384                     vetor[r]= vetor[s];\par
385                     vetor[s] = aux[0];\par
386                 \}\par
387         \}\par
388 \par
389     \}\par
390 \par
391 \}\par
}
}
{\xe \v recupera_numero_Palavras\:Consulta_Base_Arquivos.cpp}
{\xe \v Consulta_Base_Arquivos.cpp\:recupera_numero_Palavras}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void recupera_numero_Palavras ({\b Ordena_Quant_Palavra} * vetor, int Numero_Palavra_Arquivo_Log)}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 335 \{\par
336 \par
337     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
338     {\cf19 for}({\cf18 int} j = 0; j < Numero_Palavra_Arquivo_Log; j++)\par
339     \{\par
340 \par
341 \par
342 \par
343         ifstream arquivo_ler_log;\par
344         strcpy(nome, vetor[j].nome);\par
345 \par
346         strcat(nome, {\cf22 "LogArq.txt"});\par
347         strupr(nome);\par
348         arquivo_ler_log.open(nome);\par
349 \par
350 \par
351         {\cf19 if}(!arquivo_ler_log.is_open())\par
352         \{\par
353             cout << {\cf22 "N\'E3o foi encontrado o arquivo de log: a base est\'E1 vazia"} << endl;\par
354             arquivo_ler_log.clear();\par
355 \par
356         \}\par
357 \par
358         arquivo_ler_log >> vetor[j].quant;\par
359 \par
360         {\cf20 //cout << vetor[j].quant << endl;}\par
361         {\cf20 //cout << vetor[j].nome << endl;}\par
362         {\cf20 //system("PAUSE > null");}\par
363         arquivo_ler_log.close();\par
364     \}\par
365 \par
366 \par
367 \par
368 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.h}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Quantidade_Palavras}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b Quantidade_Palavras} {\b Ordena_Quant_Palavra}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Insercao} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Alfabetica} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Alfabetica} ({\b Hash} tabela, char *nome_palavra)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Consulta_Base_Quantidade_Palavras} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b recupera_numero_Palavras} ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Ordena_Vetor_Quantidade_Palavra} ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Apresenta_Vetor_Quantidade_Palavra} ({\b Ordena_Quant_Palavra} *vetor, int Numero_Palavra_Arquivo_Log)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es dos tipos\par
\pard\plain 
{\xe \v Ordena_Quant_Palavra\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:Ordena_Quant_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b Quantidade_Palavras} {\b Ordena_Quant_Palavra}}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Apresenta_Vetor_Quantidade_Palavra\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:Apresenta_Vetor_Quantidade_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apresenta_Vetor_Quantidade_Palavra ({\b Ordena_Quant_Palavra} * vetor, int Numero_Palavra_Arquivo_Log)}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 393 \{\par
394 \par
395 \par
396 \par
397     {\cf19 for}({\cf18 int} j = Numero_Palavra_Arquivo_Log - 1; j >= 0; j--)\par
398     \{\par
399         cout << {\cf22 "-"} << vetor[j].nome << {\cf22 " "} << vetor[j].quant << endl;\par
400 \par
401     \}\par
402 \par
403 \par
404 \par
405 \}\par
}
}
{\xe \v Consulta_Base_Alfabetica\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:Consulta_Base_Alfabetica}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Alfabetica ()}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 53 \{\par
54     {\cf18 char} nome[TAMANHO_DA_PALAVRA][TAMANHO_DO_CONTROLE];\par
55     {\cf18 int} i = 0;\par
56     ifstream arquivo_ler;\par
57     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
58     {\cf19 if}(!arquivo_ler.is_open())\par
59     \{\par
60        cout << {\cf22 "O banco de arquivo est\'E1 vazio, n\'E3o h\'E1 o que apresentar."} << endl;\par
61        {\cf20 //arquivo_ler.clear();}\par
62        {\cf19 return} 0;\par
63     \}\par
64     {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
65     \{\par
66         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 arquivos no banco de arquivos para ser apresentado."} << endl;\par
67         {\cf19 return} 0;\par
68         {\cf20 //system("PAUSE > null");}\par
69     \}\par
70     {\cf19 else}\par
71     \{\par
72         {\cf19 while}(! arquivo_ler.eof())\par
73         \{\par
74             arquivo_ler >> nome[i];\par
75             i++;\par
76         \}\par
77 \par
78         arquivo_ler.close();\par
79 \par
80         {\cf18 char} aux[TAMANHO_DA_PALAVRA];\par
81 \par
82         {\cf19 for}({\cf18 int} r = 0; r < i; r++)              {\cf20 // ordenando os arquivos tendo como base a ordem alfab\'E9tica}\par
83         \{\par
84             {\cf19 for}({\cf18 int} s = r+1; s < i; s++)\par
85             \{\par
86                 {\cf19 if} (strcmp(nome[r],nome[s])>0)\par
87                     \{\par
88                        strcpy(aux,nome[s]);\par
89                        strcpy(nome[s],nome[r]);\par
90                        strcpy(nome[r], aux);\par
91                     \}\par
92             \}\par
93 \par
94         \}\par
95 \par
96 \par
97         {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
98         \{\par
99                 cout << {\cf22 "-"} << nome[j] << endl;\par
100         \}\par
101 \par
102     \}\par
103 \par
104 \par
105 \}\par
}
}
{\xe \v Consulta_Base_Alfabetica\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:Consulta_Base_Alfabetica}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Alfabetica ({\b Hash} tabela, char * nome_palavra)}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 109 \{\par
110 \par
111 \par
112     {\cf18 int} contador_linhas = 0, linha_correta_atual = 0;\par
113 \par
114     {\cf18 char} nome_palavra[TAMANHO_DA_PALAVRA];\par
115     strcpy(nome_palavra, nome);\par
116     strupr(nome_palavra);\par
117 \par
118     {\cf18 int} pos = hash_funcao(nome_palavra);\par
119     {\cf18 char} linha[TAMANHO_DA_FRASE];\par
120     Dados *aux1, *aux2, *aux3, *aux4, *aux5, *aux6;\par
121     aux1 = tabela[pos];\par
122     aux2 = tabela[pos]->prox;\par
123 \par
124     cout << tabela[pos]->Arquivo << endl;\par
125     cout << tabela[pos]->prox->Arquivo << endl;\par
126     cout << tabela[pos]->prox->prox->Arquivo << endl <<endl;\par
127     cout << aux1->Arquivo << endl;\par
128     cout << aux2->Arquivo << endl <<endl;\par
129 \par
130     system({\cf22 "PAUSE > null"});\par
131     {\cf19 while}(aux1->prox != NULL)\par
132     \{\par
133 \par
134 \par
135         {\cf19 while}(aux2 != NULL)\par
136         \{\par
137 \par
138             cout << tabela[pos]->Arquivo << endl;\par
139             cout << tabela[pos]->prox->Arquivo << endl;\par
140             cout << tabela[pos]->prox->prox->Arquivo << endl <<endl;\par
141             cout << aux1->Arquivo << endl;\par
142             cout << aux2->Arquivo << endl <<endl;\par
143 \par
144 \par
145 \par
146             {\cf19 if}(strcmp(aux1->Arquivo, aux2->Arquivo) > 0)\par
147             \{\par
148 \par
149 \par
150                 {\cf19 if}(aux1->prox == aux2)\par
151                 \{\par
152                     {\cf19 if}(aux1->ant == NULL && aux2->prox == NULL)\par
153                     \{\par
154 \par
155                         cout<< {\cf22 "kl\'E7sda"} << endl;\par
156                         system({\cf22 "PAUSE > null"});\par
157                         aux3->prox = aux2;\par
158 \par
159 \par
160 \par
161 \par
162                     \}\par
163                     {\cf19 else} {\cf19 if}(aux1->ant == NULL && aux2->prox != NULL)\par
164                     \{\par
165 \par
166 \par
167 \par
168                         {\cf20 //aux3 = aux1->ant; = \'E9 NULL;}\par
169                         aux3 = aux2->prox;\par
170                         aux3->ant = aux1;\par
171                         aux1->prox  = aux3;\par
172                         aux2->prox = aux1;\par
173                         aux2->ant = NULL;\par
174 \par
175 \par
176                     \}\par
177                     {\cf19 else} {\cf19 if}(aux1->ant != NULL && aux2->prox == NULL)\par
178                     \{\par
179 \par
180 \par
181                         aux3 = aux1->prox;\par
182                         aux4 = aux1->ant;\par
183 \par
184                         aux5 = aux2->prox;     {\cf20 //NULL}\par
185                         aux6 = aux2->ant;\par
186 \par
187                         aux6->prox = aux1;\par
188                         aux1->prox = NULL;\par
189                         aux1->ant = aux6;\par
190 \par
191                         aux3->ant = aux2;\par
192                         aux4->prox = aux2;\par
193                         aux2->prox = aux3;\par
194                         aux2->ant = aux4;\par
195 \par
196                     \}\par
197                     {\cf19 else}\par
198                     \{\par
199 \par
200                         aux3 = aux1->prox;\par
201                         aux4 = aux1->ant;\par
202 \par
203                         aux5 = aux2->prox;     {\cf20 //NULL}\par
204                         aux6 = aux2->ant;\par
205 \par
206 \par
207                         aux6->prox = aux1;\par
208                         aux5->ant  = aux1;\par
209                         aux1->prox = aux5;\par
210                         aux2->ant  = aux6;\par
211 \par
212                         aux3->ant = aux2;\par
213                         aux4->prox = aux2;\par
214                         aux2->prox = aux3;\par
215                         aux2->ant = aux4;\par
216                     \}\par
217 \par
218                 \}\par
219                 {\cf19 else}\par
220                 \{\par
221                     {\cf19 if}(aux1->ant == NULL && aux2->prox == NULL)\par
222                     \{\par
223 \par
224                         cout<< {\cf22 "kl\'E7sda"} << endl;\par
225                         system({\cf22 "PAUSE > null"});\par
226 \par
227                         aux3 = aux1->prox;\par
228                         aux4 = aux1->ant;   {\cf20 //NULL}\par
229 \par
230                         aux5 = aux2->prox;  {\cf20 //NULL}\par
231                         aux6 = aux2->ant;\par
232 \par
233                         aux6->prox = aux1;\par
234                         aux1->ant = aux6;\par
235                         aux1->prox = NULL;\par
236 \par
237                         aux3->ant = aux2;\par
238                         aux2->prox = aux3;\par
239                         aux2->ant = NULL;\par
240                     \}\par
241                     {\cf19 else} {\cf19 if}(aux1->ant == NULL && aux2->prox != NULL)\par
242                     \{\par
243 \par
244 \par
245 \par
246                         aux3 = aux1->prox;\par
247                         aux4 = aux1->ant;   {\cf20 //NULL}\par
248 \par
249                         aux5 = aux2->prox;\par
250                         aux6 = aux2->ant;\par
251 \par
252                         aux3->ant = aux2;\par
253                         aux2->ant = NULL;\par
254                         aux2->prox = aux3;\par
255 \par
256 \par
257 \par
258 \par
259 \par
260                         aux1->prox = aux5;\par
261                         aux1->ant  = aux6;\par
262                         aux6->prox = aux1;\par
263                         aux5->ant  = aux1;\par
264 \par
265 \par
266                     \}\par
267                     {\cf19 else} {\cf19 if}(aux1->ant != NULL && aux2->prox == NULL)\par
268                     \{\par
269 \par
270 \par
271                         aux3 = aux1->prox;\par
272                         aux4 = aux1->ant;\par
273 \par
274                         aux5 = aux2->prox;     {\cf20 //NULL}\par
275                         aux6 = aux2->ant;\par
276 \par
277                         aux6->prox = aux1;\par
278                         aux1->prox = NULL;\par
279                         aux1->ant = aux6;\par
280 \par
281                         aux3->ant = aux2;\par
282                         aux4->prox = aux2;\par
283                         aux2->prox = aux3;\par
284                         aux2->ant = aux4;\par
285 \par
286                     \}\par
287                     {\cf19 else}\par
288                     \{\par
289 \par
290                         aux3 = aux1->prox;\par
291                         aux4 = aux1->ant;\par
292 \par
293                         aux5 = aux2->prox;     {\cf20 //NULL}\par
294                         aux6 = aux2->ant;\par
295 \par
296 \par
297                         aux6->prox = aux1;\par
298                         aux5->ant  = aux1;\par
299                         aux1->prox = aux5;\par
300                         aux2->ant  = aux6;\par
301 \par
302                         aux3->ant = aux2;\par
303                         aux4->prox = aux2;\par
304                         aux2->prox = aux3;\par
305                         aux2->ant = aux4;\par
306                     \}\par
307 \par
308             cout << tabela[pos]->Arquivo << endl;\par
309             cout << tabela[pos]->prox->Arquivo << endl;\par
310             cout << tabela[pos]->prox->prox->Arquivo << endl <<endl;\par
311             cout << aux1->Arquivo << endl;\par
312             cout << aux2->Arquivo << endl <<endl;\par
313 \par
314 \par
315                 \}\par
316 \par
317             \}\par
318 \par
319 \par
320             aux2 = aux2->prox;\par
321 \par
322         \}\par
323 \par
324         aux1 = aux1->prox;\par
325         aux2 = aux1->prox;\par
326 \par
327 \par
328     \}\par
329 \par
330 \}\par
}
}
{\xe \v Consulta_Base_Insercao\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:Consulta_Base_Insercao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Insercao ()}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16 \{\par
17     {\cf18 char} nome[TAMANHO_DA_PALAVRA][TAMANHO_DO_CONTROLE];\par
18     {\cf18 int} i = 0;\par
19     ifstream arquivo_ler;\par
20     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
21     {\cf19 if}(!arquivo_ler.is_open())\par
22     \{\par
23        cout << {\cf22 "O banco de arquivo est\'E1 vazio, n\'E3o h\'E1 o que apresentar."} << endl;\par
24        arquivo_ler.clear();\par
25        {\cf19 return} 0;\par
26     \}\par
27     {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
28     \{\par
29         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 arquivos no banco de arquivos para ser apresentado."} << endl;\par
30         {\cf19 return} 0;\par
31     \}\par
32     {\cf19 else}\par
33     \{\par
34         {\cf19 while}(! arquivo_ler.eof())\par
35         \{\par
36             arquivo_ler >> nome[i];\par
37             i++;\par
38         \}\par
39 \par
40     arquivo_ler.close();\par
41 \par
42     {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
43     \{\par
44         cout << {\cf22 "-"} << nome[j] << endl;\par
45     \}\par
46 \par
47     \}\par
48 \par
49 \par
50 \}\par
}
}
{\xe \v Consulta_Base_Quantidade_Palavras\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:Consulta_Base_Quantidade_Palavras}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Consulta_Base_Quantidade_Palavras ()}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 408 \{\par
409 \par
410 \par
411     Ordena_Quant_Palavra vetor[TAMANHO_DO_CONTROLE];\par
412     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
413 \par
414     {\cf18 int} i = 0;\par
415     ifstream arquivo_ler;\par
416     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
417     {\cf19 if}(!arquivo_ler.is_open())\par
418     \{\par
419         cout << {\cf22 "O banco de arquivo est\'E1 vazio, n\'E3o h\'E1 o que apresentar."} << endl;\par
420         arquivo_ler.clear();\par
421         {\cf19 return} 0;\par
422     \}\par
423     {\cf20 /*}\par
424 {\cf20     else if(is_empty(arquivo_ler))}\par
425 {\cf20     \{}\par
426 {\cf20         cout << "arquivo vazio, n\'E3o h\'E1 o que remover." << endl;}\par
427 {\cf20         system("PAUSE > null");}\par
428 {\cf20     \}}\par
429 {\cf20     */}\par
430     {\cf19 else}\par
431     \{\par
432 \par
433         {\cf19 while}(! arquivo_ler.eof())\par
434         \{\par
435             arquivo_ler >> nome;{\cf20 // abrindo arquivo  com dados do arquivo}\par
436             strcpy(vetor[i].nome, nome);\par
437             {\cf20 //cout << i << endl;}\par
438             i++;\par
439 \par
440         \}\par
441     \}\par
442 \par
443 \par
444 \par
445 arquivo_ler.close();\par
446 \par
447 \par
448 \par
449 \par
450 {\cf20 //cout << "nijlads" << endl;}\par
451 {\cf20 //system("PAUSE > null");}\par
452 \par
453 func funcoes;           {\cf20 // exemplo de ponteiro de fun\'E7\'E3o - usado para facilitar o manuseio das etapas necess\'E1rias a apresenta\'E7\'E3o dos arquivos ordenados por quantidade de palavras}\par
454 \par
455 funcoes = recupera_numero_Palavras;\par
456 funcoes(vetor, i);\par
457 \par
458 funcoes = Ordena_Vetor_Quantidade_Palavra;\par
459 funcoes(vetor, i);\par
460 \par
461 funcoes = Apresenta_Vetor_Quantidade_Palavra;\par
462 funcoes(vetor, i);\par
463 \par
464 \par
465 \par
466 \par
467 \par
468 \par
469 \par
470 \par
471 \par
472 \}\par
}
}
{\xe \v Ordena_Vetor_Quantidade_Palavra\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:Ordena_Vetor_Quantidade_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Ordena_Vetor_Quantidade_Palavra ({\b Ordena_Quant_Palavra} * vetor, int Numero_Palavra_Arquivo_Log)}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 371 \{\par
372     Ordena_Quant_Palavra aux[1];\par
373 \par
374     {\cf20 //cout << i<< "dasds" << endl;}\par
375     {\cf20 //system("PAUSE > null");}\par
376 \par
377     {\cf19 for}({\cf18 int} r = 0; r < Numero_Palavra_Arquivo_Log; r++)          {\cf20 //ordenando tendo como base a quantidade de  palavras (descescente}\par
378     \{\par
379         {\cf19 for}({\cf18 int} s = r+1; s < Numero_Palavra_Arquivo_Log; s++)\par
380         \{\par
381             {\cf19 if} (vetor[r].quant > vetor[s].quant)\par
382                 \{\par
383                     aux[0] = vetor[r];\par
384                     vetor[r]= vetor[s];\par
385                     vetor[s] = aux[0];\par
386                 \}\par
387         \}\par
388 \par
389     \}\par
390 \par
391 \}\par
}
}
{\xe \v recupera_numero_Palavras\:Consulta_Base_Arquivos.h}
{\xe \v Consulta_Base_Arquivos.h\:recupera_numero_Palavras}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void recupera_numero_Palavras ({\b Ordena_Quant_Palavra} * vetor, int Numero_Palavra_Arquivo_Log)}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 335 \{\par
336 \par
337     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
338     {\cf19 for}({\cf18 int} j = 0; j < Numero_Palavra_Arquivo_Log; j++)\par
339     \{\par
340 \par
341 \par
342 \par
343         ifstream arquivo_ler_log;\par
344         strcpy(nome, vetor[j].nome);\par
345 \par
346         strcat(nome, {\cf22 "LogArq.txt"});\par
347         strupr(nome);\par
348         arquivo_ler_log.open(nome);\par
349 \par
350 \par
351         {\cf19 if}(!arquivo_ler_log.is_open())\par
352         \{\par
353             cout << {\cf22 "N\'E3o foi encontrado o arquivo de log: a base est\'E1 vazia"} << endl;\par
354             arquivo_ler_log.clear();\par
355 \par
356         \}\par
357 \par
358         arquivo_ler_log >> vetor[j].quant;\par
359 \par
360         {\cf20 //cout << vetor[j].quant << endl;}\par
361         {\cf20 //cout << vetor[j].nome << endl;}\par
362         {\cf20 //system("PAUSE > null");}\par
363         arquivo_ler_log.close();\par
364     \}\par
365 \par
366 \par
367 \par
368 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Consulta_Base_Arquivos.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Consulta_Base_Arquivos.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef _CONSULTA_BASE_ARQUIVO_}\par
2 {\cf21 #define _CONSULTA_BASE_ARQUIVO_}\par
3 \par
4 {\cf17 typedef} {\cf17 struct }Quantidade_Palavras\par
5 \{\par
6     {\cf18 char} nome[TAMANHO_DA_PALAVRA];  {\cf20 // nome do arquivo}\par
7     {\cf18 int}  quant; {\cf20 // quantidade de palavras}\par
8 \par
9 \}Ordena_Quant_Palavra;\par
10 \par
11 {\cf18 bool} Consulta_Base_Insercao();\par
12 {\cf20 //void Consulta_Base_Insercao(); j\'E1 \'E9 o padr\'E3o}\par
13 \par
14 {\cf18 bool} Consulta_Base_Alfabetica();\par
15 {\cf18 bool} Consulta_Base_Alfabetica(Hash tabela,{\cf18 char} *nome_palavra );\par
16 {\cf18 bool} Consulta_Base_Quantidade_Palavras();\par
17 {\cf18 void} recupera_numero_Palavras(Ordena_Quant_Palavra *vetor, {\cf18 int} Numero_Palavra_Arquivo_Log);     {\cf20 // exemplo ponteiro de fun\'E7\'E3o}\par
18 {\cf18 void} Ordena_Vetor_Quantidade_Palavra(Ordena_Quant_Palavra *vetor, {\cf18 int} Numero_Palavra_Arquivo_Log);\par
19 {\cf18 void} Apresenta_Vetor_Quantidade_Palavra(Ordena_Quant_Palavra *vetor, {\cf18 int} Numero_Palavra_Arquivo_Log);\par
20 \par
21 \par
22 {\cf21 #endif }{\cf20 // _TESTE_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.cpp}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.cpp}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "teste.h"}\par
{\f2 #include "consulta_palavra.h"}\par
{\f2 #include "Consulta_Base_Arquivos.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Hash_Recupera} ({\b Hash} tab)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Apresentar_Lista_Frase} ({\b Hash} tabela, char *nome)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Apresentar_Lista_Frase} ({\b Hash} tabela, int pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inserir_Lista_Palavra} ({\b Hash} tabela, int pos, char nome[{\b TAMANHO_DA_PALAVRA}], char palavra[{\b TAMANHO_DA_PALAVRA}], int quant, int total_com_repeticao, int vetor[])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b recupera_palavras_arquivo} (char nome[{\b TAMANHO_DA_PALAVRA}], char palavra[{\b TAMANHO_DA_PALAVRA}], {\b Hash} tabela)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Consulta_Palavra} (char *nome_palavra, {\b Hash} tab)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Apresentar_Lista_Frase\:consulta_palavra.cpp}
{\xe \v consulta_palavra.cpp\:Apresentar_Lista_Frase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apresentar_Lista_Frase ({\b Hash} tabela, char * nome)}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28 \{\par
29 \par
30     {\cf18 int} contador_linhas = 0, linha_correta_atual = 0;\par
31 \par
32     {\cf18 char} nome_palavra[TAMANHO_DA_PALAVRA];\par
33     strcpy(nome_palavra, nome);\par
34     strupr(nome_palavra);\par
35 \par
36     {\cf18 int} pos = hash_funcao(nome_palavra);\par
37     {\cf18 char} linha[TAMANHO_DA_FRASE];\par
38     Dados *aux;\par
39     aux = tabela[pos];\par
40 \par
41 \par
42     {\cf20 /*}\par
43 {\cf20     cout << aux->prox->quantidade << endl;}\par
44 {\cf20     cout << aux->prox->prox->quantidade << endl;}\par
45 {\cf20     cout << aux->prox->prox->prox->quantidade << endl;}\par
46 {\cf20     */}\par
47     {\cf19 while}(aux != NULL)\par
48     \{\par
49 \par
50         ifstream arquivo_ler;\par
51         arquivo_ler.open(aux->Arquivo);\par
52         {\cf19 if}(!arquivo_ler.is_open())\par
53         \{\par
54            cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que consultar."} << endl;\par
55            arquivo_ler.clear();\par
56            {\cf20 //return 0;}\par
57         \}\par
58         {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
59         \{\par
60             cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que consulta."} << endl;\par
61             {\cf20 //system("PAUSE > null");}\par
62             {\cf20 //return 0;}\par
63         \}\par
64         {\cf19 else}\par
65         \{\par
66                 cout << {\cf22 "Foram encontrados "} << aux->quantidade << {\cf22 " linhas no arquivo "} << aux->Arquivo << endl;\par
67                 {\cf19 while}(! arquivo_ler.eof())\par
68                 \{\par
69                    arquivo_ler.getline(linha, TAMANHO_DA_FRASE);\par
70                     {\cf19 if}(contador_linhas == aux->linha[linha_correta_atual])\par
71                     \{\par
72 \par
73                         cout << {\cf22 "-"} << linha << endl;\par
74 \par
75                         linha_correta_atual++;\par
76 \par
77                     \}\par
78                     {\cf19 else} {\cf19 if}(linha_correta_atual == aux->quantidade)\par
79                     \{\par
80                     {\cf19 break};\par
81                     \}\par
82                     contador_linhas++;\par
83                     arquivo_ler.clear();\par
84                     {\cf20 //cout << linha_correta_atual << endl;}\par
85                     {\cf20 //cout << contador_linhas << endl;}\par
86                     {\cf20 //cout << aux[pos]->Arquivo << endl;}\par
87                     {\cf20 //cout << aux->quantidade << endl;}\par
88                     {\cf20 //system("PAUSE > null");}\par
89 \par
90 \par
91                 \}\par
92         \}\par
93 \par
94         contador_linhas = 0;\par
95         linha_correta_atual = 0;\par
96 \par
97         arquivo_ler.close();\par
98         aux = aux->prox;\par
99         cout << endl;\par
100     \}\par
101 \par
102 \par
103 \}\par
}
}
{\xe \v Apresentar_Lista_Frase\:consulta_palavra.cpp}
{\xe \v consulta_palavra.cpp\:Apresentar_Lista_Frase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apresentar_Lista_Frase ({\b Hash} tabela, int pos)}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 107 \{\par
108 \par
109     {\cf18 int} contador_linhas = 0, linha_correta_atual = 0;\par
110 \par
111     {\cf18 char} linha[TAMANHO_DA_FRASE];\par
112     Dados *aux;\par
113     aux = tabela[pos];\par
114 \par
115 cout << tabela[0]->quantidade << {\cf22 "kmsa\'E7"} << endl;\par
116 cout << tabela[0]->Arquivo << {\cf22 "kmsa\'E7"} << endl;\par
117 cout << tabela[0]->linha[tabela[0]->quantidade - 1] << {\cf22 "kmsa\'E7"} << endl;\par
118 \par
119     {\cf20 /*}\par
120 {\cf20     cout << aux->prox->quantidade << endl;}\par
121 {\cf20     cout << aux->prox->prox->quantidade << endl;}\par
122 {\cf20     cout << aux->prox->prox->prox->quantidade << endl;}\par
123 {\cf20     */}\par
124     {\cf19 while}(aux != NULL)\par
125     \{\par
126 \par
127         ifstream arquivo_ler;\par
128         arquivo_ler.open(aux->Arquivo);\par
129         {\cf19 if}(!arquivo_ler.is_open())\par
130         \{\par
131            cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que consultar."} << endl;\par
132            arquivo_ler.clear();\par
133            {\cf20 //return 0;}\par
134         \}\par
135         {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
136         \{\par
137             cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que consulta."} << endl;\par
138             {\cf20 //system("PAUSE > null");}\par
139             {\cf20 //return 0;}\par
140         \}\par
141         {\cf19 else}\par
142         \{\par
143                 cout << {\cf22 "Foram encontrados "} << aux->quantidade << {\cf22 " linhas no arquivo "} << aux->Arquivo << endl;\par
144                 {\cf19 while}(! arquivo_ler.eof())\par
145                 \{\par
146                    arquivo_ler.getline(linha, TAMANHO_DA_FRASE);\par
147                     {\cf19 if}(contador_linhas == aux->linha[linha_correta_atual])\par
148                     \{\par
149 \par
150                         cout << {\cf22 "-"} << linha << endl;\par
151 \par
152                         linha_correta_atual++;\par
153 \par
154                     \}\par
155                     {\cf19 else} {\cf19 if}(linha_correta_atual == aux->quantidade)\par
156                     \{\par
157                     {\cf19 break};\par
158                     \}\par
159                     contador_linhas++;\par
160                     arquivo_ler.clear();\par
161                     {\cf20 //cout << linha_correta_atual << endl;}\par
162                     {\cf20 //cout << contador_linhas << endl;}\par
163                     {\cf20 //cout << aux[pos]->Arquivo << endl;}\par
164                     {\cf20 //cout << aux->quantidade << endl;}\par
165                     {\cf20 //system("PAUSE > null");}\par
166 \par
167 \par
168                 \}\par
169         \}\par
170 \par
171         contador_linhas = 0;\par
172         linha_correta_atual = 0;\par
173 \par
174         arquivo_ler.close();\par
175         aux = aux->prox;\par
176         cout << endl;\par
177     \}\par
178 \par
179 \par
180 \}\par
}
}
{\xe \v Consulta_Palavra\:consulta_palavra.cpp}
{\xe \v consulta_palavra.cpp\:Consulta_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Consulta_Palavra (char * nome_palavra, {\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 352 \{\par
353     {\cf20 //Hash tab;}\par
354     {\cf18 int} i = 0;\par
355     {\cf18 char} nome[TAMANHO_DO_CONTROLE][TAMANHO_DA_PALAVRA];\par
356     {\cf18 char} nomeses[TAMANHO_DA_PALAVRA];\par
357     {\cf20 //Inicializar_Hash_Recupera(tab);}\par
358 \par
359     ifstream arquivo_ler;\par
360     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
361     {\cf19 if}(!arquivo_ler.is_open())\par
362     \{\par
363        cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que consultar."} << endl;\par
364        arquivo_ler.clear();\par
365        {\cf20 //return 0;}\par
366     \}\par
367 \par
368     {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
369     \{\par
370         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que consultar."} << endl;\par
371         {\cf20 //system("PAUSE > null");}\par
372         {\cf20 //return 0;}\par
373     \}\par
374     {\cf19 else}\par
375     \{\par
376 \par
377         {\cf19 while}(! arquivo_ler.eof())      {\cf20 //Armazena os nomes do arquivo num vetor tempor\'E1rio}\par
378         \{\par
379 \par
380 \par
381                 arquivo_ler >> nome[i];\par
382                 {\cf20 /*cout << nome[i] << endl;}\par
383 {\cf20                 cout << "cfscasmdksa" <<endl;}\par
384 {\cf20                 system("PAUSE > null");}\par
385 {\cf20                 */}\par
386                 i++;\par
387         \}\par
388         arquivo_ler.close();\par
389 \par
390         {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
391         \{\par
392 \par
393             recupera_palavras_arquivo(nome[j], nome_palavra, tab);\par
394             {\cf20 //cout << "cfscasmdksa" <<endl;}\par
395             {\cf20 //system("PAUSE > null");}\par
396         \}\par
397         strcpy(nomeses, nome_palavra);\par
398         {\cf18 int} pos = hash_funcao(nomeses);\par
399         {\cf20 //cout << tab[pos]->quantidade << endl;}\par
400         {\cf20 //Consulta_Base_Alfabetica(tab, nome_palavra);}\par
401         {\cf20 //Apresentar_Lista_Frase(tab, nome_palavra);}\par
402 \par
403 \par
404 \par
405 \par
406     \}\par
407 \par
408 \par
409 \par
410 \par
411 \par
412 \par
413 \par
414 \}\par
}
}
{\xe \v Inicializar_Hash_Recupera\:consulta_palavra.cpp}
{\xe \v consulta_palavra.cpp\:Inicializar_Hash_Recupera}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Hash_Recupera ({\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15 \{\par
16     {\cf20 //tab[40]->quantidade = 100;}\par
17     {\cf20 //cout << tab[40]->quantidade << endl;}\par
18 \par
19 {\cf18 int} i;\par
20 {\cf19 for}(i = 0; i < TAMANHO; i++)\par
21 \{\par
22 tab[i] = NULL;\par
23 \}\par
24 \par
25 \}\par
}
}
{\xe \v Inserir_Lista_Palavra\:consulta_palavra.cpp}
{\xe \v consulta_palavra.cpp\:Inserir_Lista_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inserir_Lista_Palavra ({\b Hash} tabela, int pos, char nome[TAMANHO_DA_PALAVRA], char palavra[TAMANHO_DA_PALAVRA], int quant, int total_com_repeticao, int vetor[])}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 183 \{\par
184 \par
185     {\cf20 //cout << "kls\'E7da" << quant << endl;}\par
186     Dados *novo = (Dados*) {\cf17 new} Dados;\par
187     Dados *aux2, *aux;\par
188 \par
189     {\cf19 if}(tabela[pos] == NULL)\par
190     \{\par
191     strcpy(novo->Arquivo, nome);\par
192     strcpy(novo->Palavra, palavra);\par
193     novo->quantidade = quant;\par
194     novo->prox = NULL;\par
195     novo->ant = NULL;\par
196     novo->quantidade = quant;\par
197     novo->total_de_vezes_palavra = total_com_repeticao;\par
198     {\cf19 for}({\cf18 int} i = 0; i < quant; i++)\par
199     \{\par
200         novo->linha[i] = vetor[i];\par
201     \}\par
202     tabela[pos] = novo;\par
203     \}\par
204     {\cf19 else}\par
205     \{\par
206     {\cf20 //cout << tabela[pos]->quantidade << endl;}\par
207     {\cf20 //system("PAUSE > null");}\par
208 \par
209 \par
210         aux = tabela[pos];\par
211         aux2 = NULL;\par
212         {\cf19 while}(aux != NULL)\par
213         \{\par
214             aux2 = aux;\par
215             aux = aux->prox;\par
216         \}\par
217 \par
218         novo->total_de_vezes_palavra = total_com_repeticao;\par
219         novo->quantidade = quant;\par
220         {\cf19 for}({\cf18 int} i = 0; i < quant; i++)\par
221         \{\par
222             novo->linha[i] = vetor[i];\par
223         \}\par
224         strcpy(novo->Arquivo, nome);\par
225         strcpy(novo->Palavra, palavra);\par
226 \par
227         aux2->prox = novo;\par
228         novo->ant = aux2;\par
229         novo->prox = NULL;\par
230     \}\par
231 \par
232 \}\par
}
}
{\xe \v recupera_palavras_arquivo\:consulta_palavra.cpp}
{\xe \v consulta_palavra.cpp\:recupera_palavras_arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool recupera_palavras_arquivo (char nome[TAMANHO_DA_PALAVRA], char palavra[TAMANHO_DA_PALAVRA], {\b Hash} tabela)}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 237 \{\par
238 \par
239 \par
240     {\cf18 char}  v[TAMANHO_VETOR_TEMPORARIO], ve[TAMANHO_DA_PALAVRA];      {\cf20 // ver se o arquivo est\'E1 no banco}\par
241     {\cf18 int} i =0, r = 0, j = 0;\par
242 \par
243     ifstream arquivo_ler_principal;\par
244 \par
245     arquivo_ler_principal.open(nome);\par
246 \par
247     {\cf19 if}(!arquivo_ler_principal.is_open())\par
248     \{\par
249         cout << {\cf22 "N\'E3o foi encontrado o arquivo: cjhgfcft"} << endl;\par
250         arquivo_ler_principal.clear();\par
251         {\cf19 return} 0;\par
252     \}\par
253 \par
254     arquivo_ler_principal.close();\par
255 \par
256 \par
257     {\cf18 char} nome_arquivo[TAMANHO_DA_PALAVRA];\par
258     strcpy(nome_arquivo, nome);\par
259     strcat(nome_arquivo,{\cf22 "LogPal.txt"});\par
260 \par
261     {\cf18 char} nome_palavra[TAMANHO_DA_PALAVRA];\par
262     strcpy(nome_palavra, palavra);\par
263     strupr(nome_palavra);\par
264 \par
265 \par
266     ifstream arquivo_ler;\par
267 \par
268     arquivo_ler.open(nome_arquivo);\par
269 \par
270 \par
271 \par
272     {\cf19 if}(!arquivo_ler.is_open())\par
273     \{\par
274         cout << {\cf22 "N\'E3o foi encontrado o arquivo:"} << endl;\par
275         arquivo_ler.clear();\par
276         {\cf19 return} 0;\par
277     \}\par
278     {\cf19 else}\par
279     \{\par
280         {\cf19 while}(! arquivo_ler.eof())\par
281         \{\par
282 \par
283             v[i]  = arquivo_ler.get();\par
284             ve[r] = v[i];\par
285             r++;\par
286 \par
287 \par
288 \par
289             {\cf19 if}(v[i] == {\cf23 ' '} || v[i] == {\cf23 '\\n'})\par
290             \{\par
291 \par
292 \par
293                 ve[r] = {\cf23 '\\0'};\par
294                 ve[r - 1] = {\cf23 '\\0'};\par
295                 {\cf18 int} j = 0;\par
296 \par
297 \par
298                 {\cf19 if}(strcmp(nome_palavra, ve) == 0)       {\cf20 //BUSCA SEQUENCIAL DENTRO DO ARQUIVO NA QUAL SE PROCURA  A PALAVRA. ENCONTRANDO ARMAZENA-SE OS VALORES DE QUANTIDADE DE LINHAS E POSI\'C7\'D5ES DA MESMA}\par
299                 \{\par
300 \par
301                 {\cf18 int} pos = hash_funcao(nome_palavra);\par
302                 {\cf20 /*if(strcmp(tabela[pos]->Palavra, palavra) != 0 && tabela[pos]->livre == false)}\par
303 {\cf20                 \{}\par
304 {\cf20                    //pos = colisao_funcao(tabela, pos);}\par
305 {\cf20                 \}}\par
306 {\cf20                 */}\par
307                 {\cf20 //cout << "palavra encontrada" <<endl;}\par
308                 {\cf18 int} c, d;\par
309 \par
310                 arquivo_ler >> c;\par
311                 d = c;\par
312                 {\cf18 int} vetor[c];\par
313 \par
314                 {\cf19 for}({\cf18 int} j = 0; j < c; j++)\par
315                 \{\par
316                     arquivo_ler >> vetor[j];\par
317                     {\cf19 if}(vetor[j] == vetor[j-1])\par
318                     \{\par
319                         j--;\par
320                         c--;\par
321 \par
322                     \}\par
323                 \}\par
324 \par
325                 Inserir_Lista_Palavra(tabela, pos, nome, palavra, c, d, vetor);\par
326                 arquivo_ler.close();\par
327                 {\cf20 //cout << c << "quantidade de linhas" << endl;}\par
328                 {\cf19 return} {\cf17 true};\par
329                 \}\par
330                 {\cf19 else} {\cf19 if} (strcmp(nome_palavra, ve) < 0)\par
331                 \{\par
332                 cout << {\cf22 "palavra n\'E3o encontrada no arquivo: "}<< nome << endl;\par
333                 arquivo_ler.close();\par
334                 {\cf19 return} {\cf17 false};\par
335                 \}\par
336 \par
337             r = 0;\par
338 \par
339             \}\par
340 \par
341     \}\par
342 \}\par
343 \par
344 \par
345 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.h}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Consulta_Palavra} (char *nome_palavra, {\b Hash} tab)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Hash_Recupera} ({\b Hash} tabela)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b recupera_palavras_arquivo} (char *nome, char *palavra, {\b Hash} tabela)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inserir_Lista_Palavra} ({\b Hash} tabela, int pos, char nome[{\b TAMANHO_DA_PALAVRA}], char palavra[{\b TAMANHO_DA_PALAVRA}], int quant, int total_com_repeticao, int vetor[])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Apresentar_Lista_Frase} ({\b Hash} tabela, char *nome)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Apresentar_Lista_Frase} ({\b Hash} tabela, int pos)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Apresentar_Lista_Frase\:consulta_palavra.h}
{\xe \v consulta_palavra.h\:Apresentar_Lista_Frase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apresentar_Lista_Frase ({\b Hash} tabela, char * nome)}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28 \{\par
29 \par
30     {\cf18 int} contador_linhas = 0, linha_correta_atual = 0;\par
31 \par
32     {\cf18 char} nome_palavra[TAMANHO_DA_PALAVRA];\par
33     strcpy(nome_palavra, nome);\par
34     strupr(nome_palavra);\par
35 \par
36     {\cf18 int} pos = hash_funcao(nome_palavra);\par
37     {\cf18 char} linha[TAMANHO_DA_FRASE];\par
38     Dados *aux;\par
39     aux = tabela[pos];\par
40 \par
41 \par
42     {\cf20 /*}\par
43 {\cf20     cout << aux->prox->quantidade << endl;}\par
44 {\cf20     cout << aux->prox->prox->quantidade << endl;}\par
45 {\cf20     cout << aux->prox->prox->prox->quantidade << endl;}\par
46 {\cf20     */}\par
47     {\cf19 while}(aux != NULL)\par
48     \{\par
49 \par
50         ifstream arquivo_ler;\par
51         arquivo_ler.open(aux->Arquivo);\par
52         {\cf19 if}(!arquivo_ler.is_open())\par
53         \{\par
54            cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que consultar."} << endl;\par
55            arquivo_ler.clear();\par
56            {\cf20 //return 0;}\par
57         \}\par
58         {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
59         \{\par
60             cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que consulta."} << endl;\par
61             {\cf20 //system("PAUSE > null");}\par
62             {\cf20 //return 0;}\par
63         \}\par
64         {\cf19 else}\par
65         \{\par
66                 cout << {\cf22 "Foram encontrados "} << aux->quantidade << {\cf22 " linhas no arquivo "} << aux->Arquivo << endl;\par
67                 {\cf19 while}(! arquivo_ler.eof())\par
68                 \{\par
69                    arquivo_ler.getline(linha, TAMANHO_DA_FRASE);\par
70                     {\cf19 if}(contador_linhas == aux->linha[linha_correta_atual])\par
71                     \{\par
72 \par
73                         cout << {\cf22 "-"} << linha << endl;\par
74 \par
75                         linha_correta_atual++;\par
76 \par
77                     \}\par
78                     {\cf19 else} {\cf19 if}(linha_correta_atual == aux->quantidade)\par
79                     \{\par
80                     {\cf19 break};\par
81                     \}\par
82                     contador_linhas++;\par
83                     arquivo_ler.clear();\par
84                     {\cf20 //cout << linha_correta_atual << endl;}\par
85                     {\cf20 //cout << contador_linhas << endl;}\par
86                     {\cf20 //cout << aux[pos]->Arquivo << endl;}\par
87                     {\cf20 //cout << aux->quantidade << endl;}\par
88                     {\cf20 //system("PAUSE > null");}\par
89 \par
90 \par
91                 \}\par
92         \}\par
93 \par
94         contador_linhas = 0;\par
95         linha_correta_atual = 0;\par
96 \par
97         arquivo_ler.close();\par
98         aux = aux->prox;\par
99         cout << endl;\par
100     \}\par
101 \par
102 \par
103 \}\par
}
}
{\xe \v Apresentar_Lista_Frase\:consulta_palavra.h}
{\xe \v consulta_palavra.h\:Apresentar_Lista_Frase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apresentar_Lista_Frase ({\b Hash} tabela, int pos)}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 107 \{\par
108 \par
109     {\cf18 int} contador_linhas = 0, linha_correta_atual = 0;\par
110 \par
111     {\cf18 char} linha[TAMANHO_DA_FRASE];\par
112     Dados *aux;\par
113     aux = tabela[pos];\par
114 \par
115 cout << tabela[0]->quantidade << {\cf22 "kmsa\'E7"} << endl;\par
116 cout << tabela[0]->Arquivo << {\cf22 "kmsa\'E7"} << endl;\par
117 cout << tabela[0]->linha[tabela[0]->quantidade - 1] << {\cf22 "kmsa\'E7"} << endl;\par
118 \par
119     {\cf20 /*}\par
120 {\cf20     cout << aux->prox->quantidade << endl;}\par
121 {\cf20     cout << aux->prox->prox->quantidade << endl;}\par
122 {\cf20     cout << aux->prox->prox->prox->quantidade << endl;}\par
123 {\cf20     */}\par
124     {\cf19 while}(aux != NULL)\par
125     \{\par
126 \par
127         ifstream arquivo_ler;\par
128         arquivo_ler.open(aux->Arquivo);\par
129         {\cf19 if}(!arquivo_ler.is_open())\par
130         \{\par
131            cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que consultar."} << endl;\par
132            arquivo_ler.clear();\par
133            {\cf20 //return 0;}\par
134         \}\par
135         {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
136         \{\par
137             cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que consulta."} << endl;\par
138             {\cf20 //system("PAUSE > null");}\par
139             {\cf20 //return 0;}\par
140         \}\par
141         {\cf19 else}\par
142         \{\par
143                 cout << {\cf22 "Foram encontrados "} << aux->quantidade << {\cf22 " linhas no arquivo "} << aux->Arquivo << endl;\par
144                 {\cf19 while}(! arquivo_ler.eof())\par
145                 \{\par
146                    arquivo_ler.getline(linha, TAMANHO_DA_FRASE);\par
147                     {\cf19 if}(contador_linhas == aux->linha[linha_correta_atual])\par
148                     \{\par
149 \par
150                         cout << {\cf22 "-"} << linha << endl;\par
151 \par
152                         linha_correta_atual++;\par
153 \par
154                     \}\par
155                     {\cf19 else} {\cf19 if}(linha_correta_atual == aux->quantidade)\par
156                     \{\par
157                     {\cf19 break};\par
158                     \}\par
159                     contador_linhas++;\par
160                     arquivo_ler.clear();\par
161                     {\cf20 //cout << linha_correta_atual << endl;}\par
162                     {\cf20 //cout << contador_linhas << endl;}\par
163                     {\cf20 //cout << aux[pos]->Arquivo << endl;}\par
164                     {\cf20 //cout << aux->quantidade << endl;}\par
165                     {\cf20 //system("PAUSE > null");}\par
166 \par
167 \par
168                 \}\par
169         \}\par
170 \par
171         contador_linhas = 0;\par
172         linha_correta_atual = 0;\par
173 \par
174         arquivo_ler.close();\par
175         aux = aux->prox;\par
176         cout << endl;\par
177     \}\par
178 \par
179 \par
180 \}\par
}
}
{\xe \v Consulta_Palavra\:consulta_palavra.h}
{\xe \v consulta_palavra.h\:Consulta_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Consulta_Palavra (char * nome_palavra, {\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 352 \{\par
353     {\cf20 //Hash tab;}\par
354     {\cf18 int} i = 0;\par
355     {\cf18 char} nome[TAMANHO_DO_CONTROLE][TAMANHO_DA_PALAVRA];\par
356     {\cf18 char} nomeses[TAMANHO_DA_PALAVRA];\par
357     {\cf20 //Inicializar_Hash_Recupera(tab);}\par
358 \par
359     ifstream arquivo_ler;\par
360     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
361     {\cf19 if}(!arquivo_ler.is_open())\par
362     \{\par
363        cout << {\cf22 "N\'E3o foi encontrado o log de arquivo: banco de arquivos est\'E1 vazio, portanto n\'E3o h\'E1 o que consultar."} << endl;\par
364        arquivo_ler.clear();\par
365        {\cf20 //return 0;}\par
366     \}\par
367 \par
368     {\cf19 else} {\cf19 if}(is_empty(arquivo_ler))\par
369     \{\par
370         cout << {\cf22 "arquivo vazio, n\'E3o h\'E1 o que consultar."} << endl;\par
371         {\cf20 //system("PAUSE > null");}\par
372         {\cf20 //return 0;}\par
373     \}\par
374     {\cf19 else}\par
375     \{\par
376 \par
377         {\cf19 while}(! arquivo_ler.eof())      {\cf20 //Armazena os nomes do arquivo num vetor tempor\'E1rio}\par
378         \{\par
379 \par
380 \par
381                 arquivo_ler >> nome[i];\par
382                 {\cf20 /*cout << nome[i] << endl;}\par
383 {\cf20                 cout << "cfscasmdksa" <<endl;}\par
384 {\cf20                 system("PAUSE > null");}\par
385 {\cf20                 */}\par
386                 i++;\par
387         \}\par
388         arquivo_ler.close();\par
389 \par
390         {\cf19 for}({\cf18 int} j = 0; j < i; j++)\par
391         \{\par
392 \par
393             recupera_palavras_arquivo(nome[j], nome_palavra, tab);\par
394             {\cf20 //cout << "cfscasmdksa" <<endl;}\par
395             {\cf20 //system("PAUSE > null");}\par
396         \}\par
397         strcpy(nomeses, nome_palavra);\par
398         {\cf18 int} pos = hash_funcao(nomeses);\par
399         {\cf20 //cout << tab[pos]->quantidade << endl;}\par
400         {\cf20 //Consulta_Base_Alfabetica(tab, nome_palavra);}\par
401         {\cf20 //Apresentar_Lista_Frase(tab, nome_palavra);}\par
402 \par
403 \par
404 \par
405 \par
406     \}\par
407 \par
408 \par
409 \par
410 \par
411 \par
412 \par
413 \par
414 \}\par
}
}
{\xe \v Inicializar_Hash_Recupera\:consulta_palavra.h}
{\xe \v consulta_palavra.h\:Inicializar_Hash_Recupera}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Hash_Recupera ({\b Hash} tabela)}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15 \{\par
16     {\cf20 //tab[40]->quantidade = 100;}\par
17     {\cf20 //cout << tab[40]->quantidade << endl;}\par
18 \par
19 {\cf18 int} i;\par
20 {\cf19 for}(i = 0; i < TAMANHO; i++)\par
21 \{\par
22 tab[i] = NULL;\par
23 \}\par
24 \par
25 \}\par
}
}
{\xe \v Inserir_Lista_Palavra\:consulta_palavra.h}
{\xe \v consulta_palavra.h\:Inserir_Lista_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inserir_Lista_Palavra ({\b Hash} tabela, int pos, char nome[TAMANHO_DA_PALAVRA], char palavra[TAMANHO_DA_PALAVRA], int quant, int total_com_repeticao, int vetor[])}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 183 \{\par
184 \par
185     {\cf20 //cout << "kls\'E7da" << quant << endl;}\par
186     Dados *novo = (Dados*) {\cf17 new} Dados;\par
187     Dados *aux2, *aux;\par
188 \par
189     {\cf19 if}(tabela[pos] == NULL)\par
190     \{\par
191     strcpy(novo->Arquivo, nome);\par
192     strcpy(novo->Palavra, palavra);\par
193     novo->quantidade = quant;\par
194     novo->prox = NULL;\par
195     novo->ant = NULL;\par
196     novo->quantidade = quant;\par
197     novo->total_de_vezes_palavra = total_com_repeticao;\par
198     {\cf19 for}({\cf18 int} i = 0; i < quant; i++)\par
199     \{\par
200         novo->linha[i] = vetor[i];\par
201     \}\par
202     tabela[pos] = novo;\par
203     \}\par
204     {\cf19 else}\par
205     \{\par
206     {\cf20 //cout << tabela[pos]->quantidade << endl;}\par
207     {\cf20 //system("PAUSE > null");}\par
208 \par
209 \par
210         aux = tabela[pos];\par
211         aux2 = NULL;\par
212         {\cf19 while}(aux != NULL)\par
213         \{\par
214             aux2 = aux;\par
215             aux = aux->prox;\par
216         \}\par
217 \par
218         novo->total_de_vezes_palavra = total_com_repeticao;\par
219         novo->quantidade = quant;\par
220         {\cf19 for}({\cf18 int} i = 0; i < quant; i++)\par
221         \{\par
222             novo->linha[i] = vetor[i];\par
223         \}\par
224         strcpy(novo->Arquivo, nome);\par
225         strcpy(novo->Palavra, palavra);\par
226 \par
227         aux2->prox = novo;\par
228         novo->ant = aux2;\par
229         novo->prox = NULL;\par
230     \}\par
231 \par
232 \}\par
}
}
{\xe \v recupera_palavras_arquivo\:consulta_palavra.h}
{\xe \v consulta_palavra.h\:recupera_palavras_arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool recupera_palavras_arquivo (char * nome, char * palavra, {\b Hash} tabela)}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
consulta_palavra.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/consulta_palavra.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef _CONSULTA_PALAVRA_H}\par
2 {\cf21 #define _CONSULTA_PALAVRA_H}\par
3 \par
4 {\cf18 void} Consulta_Palavra({\cf18 char} *nome_palavra, Hash tab);\par
5 {\cf18 void} Inicializar_Hash_Recupera(Hash tabela);                                          {\cf20 // procedimento para consultar se determinada palavra faz parte de um arquivo}\par
6 {\cf18 bool} recupera_palavras_arquivo({\cf18 char} *nome, {\cf18 char} *palavra, Hash tabela);             {\cf20 //varre o arquivo para ver se encontra a pa\'E7avra (true se sim e false se n\'E3o)}\par
7 {\cf18 void} Inserir_Lista_Palavra(Hash tabela, {\cf18 int} pos, {\cf18 char} nome[TAMANHO_DA_PALAVRA], {\cf18 char} palavra[TAMANHO_DA_PALAVRA], {\cf18 int} quant, {\cf18 int} total_com_repeticao, {\cf18 int} vetor[]);\par
8     {\cf20 //caso encontre coloca valores na lista usando a fun\'E7\'E3o como base}\par
9 \par
10 {\cf18 void}  Apresentar_Lista_Frase(Hash tabela,{\cf18 char} *nome );\par
11 {\cf18 void}  Apresentar_Lista_Frase(Hash tabela, {\cf18 int} pos);\par
12 \par
13 \par
14 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.cpp}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.cpp}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "teste.h"}\par
{\f2 #include "escreve.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Escreve_No_Log_Controle} ({\b ARQUIVO} *arquivo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Escreve_No_Log_Arquivo} ({\b ARQUIVO} *arquivo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Escreve_No_Log_Palavra} ({\b ARQUIVO} *arquivo, {\b Tabela_Hash} tabela)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Escreve_No_Log_Arquivo\:escreve.cpp}
{\xe \v escreve.cpp\:Escreve_No_Log_Arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Escreve_No_Log_Arquivo ({\b ARQUIVO} * arquivo)}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 103 \{\par
104     {\cf20 //cout << "scmdksa" <<endl;}\par
105     {\cf20 //system("PAUSE > null");}\par
106 \par
107     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
108 \par
109     strcpy(nome, arquivo->nome_arquivo);\par
110     strcat(nome, {\cf22 "LogArq.txt"});\par
111     strupr(nome);\par
112 \par
113     ofstream arquivo_escrever;\par
114     arquivo_escrever.open(nome);\par
115 \par
116     {\cf19 if}(!arquivo_escrever.is_open())\par
117     \{\par
118         cout << {\cf22 "N\'E3o foi encontrado o arquivo:  novo log de palavra ('nome do arquivo'LogArq.txt) para esse arquivo ser\'E1 criado."} << endl;\par
119         arquivo_escrever.clear();\par
120     \}\par
121     arquivo_escrever << arquivo->quantidade_palavras <<  {\cf22 " "};\par
122     arquivo_escrever << arquivo->quantidade_palavras_nao_repetidas <<  {\cf22 " "};\par
123     arquivo_escrever << arquivo->numero_do_arquivo <<  {\cf22 " "};\par
124     {\cf20 //cout << arquivo->quantidade_palavras << endl;}\par
125     {\cf20 //cout << "scmdksa" <<endl;}\par
126     {\cf20 //system("PAUSE > null");}\par
127 \}\par
}
}
{\xe \v Escreve_No_Log_Controle\:escreve.cpp}
{\xe \v escreve.cpp\:Escreve_No_Log_Controle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Escreve_No_Log_Controle ({\b ARQUIVO} * arquivo)}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12 \{\par
13     {\cf18 char} nome[TAMANHO_DO_CONTROLE][TAMANHO_DA_PALAVRA];\par
14     {\cf18 int} i = 0;\par
15 \par
16 \par
17     {\cf19 for}( {\cf18 int} j = 0; j < TAMANHO_DO_CONTROLE; j++)\par
18     \{\par
19     strcpy(nome[j], {\cf22 " "});\par
20     \}\par
21 \par
22     {\cf20 /*}\par
23 {\cf20     ofstream arquivo_es;}\par
24 {\cf20     arquivo_es.open("Log_Controle.txt");}\par
25 {\cf20 }\par
26 {\cf20     if(!arquivo_es.is_open())}\par
27 {\cf20     \{}\par
28 {\cf20         cout << "N\'E3o foi encontrado o arquivo:" << endl;}\par
29 {\cf20         arquivo_es.clear();}\par
30 {\cf20         arquivo_es.open("Log_Controle.txt");}\par
31 {\cf20         arquivo_es << "       uihul " << endl;}\par
32 {\cf20     //arquivo_es.close();}\par
33 {\cf20     //return 0;}\par
34 {\cf20     \}}\par
35 {\cf20     */}\par
36 \par
37     {\cf20 //system("PAUSE > null");}\par
38     ifstream arquivo_ler;\par
39     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
40     {\cf19 if}(!arquivo_ler.is_open())\par
41     \{\par
42         cout << {\cf22 "N\'E3o foi encontrado o arquivo de controle: novo arquivo 'Log_controle.txt' ser\'E1 criado e primeiro nome de arquivo armazenado."} << endl;\par
43         arquivo_ler.close();\par
44     \}\par
45     {\cf19 if}(is_empty(arquivo_ler))\par
46     \{\par
47         arquivo_ler.close();\par
48         ofstream arquivo_escrever;\par
49         arquivo_escrever.open({\cf22 "Log_Controle.txt"});\par
50         arquivo_escrever << strupr(arquivo->nome_arquivo);\par
51 \par
52         cout << {\cf22 "arquivo inserido ao banco de arquivos com sucesso."} << endl;\par
53         {\cf20 //system("PAUSE > null");}\par
54         {\cf19 return} 0;\par
55     \}\par
56     {\cf19 else}\par
57     \{\par
58         {\cf19 while}(! arquivo_ler.eof())\par
59         \{\par
60                 arquivo_ler >> nome[i];\par
61                 {\cf20 //cout << nome[i] << endl;}\par
62                 {\cf20 //cout << arquivo->nome_arquivo<< endl;}\par
63                 {\cf20 //cout << "ljk\'E7wmafk\'E7l" << endl;}\par
64                 {\cf20 //system("PAUSE > null");}\par
65 \par
66                 {\cf19 if}(strcmp(nome[i], strupr(arquivo->nome_arquivo)) == 0)\par
67                 \{\par
68                     cout << {\cf22 "Existe um arquivo com mesmo nome no banco. Renomeie para inser\'E7\'E3o."} << endl;\par
69                     {\cf19 return} 0;\par
70                 \}\par
71                 i++;\par
72         \}\par
73     \}\par
74 \par
75     arquivo_ler.close();\par
76 \par
77     strcpy(nome[i],arquivo->nome_arquivo);\par
78     i++;\par
79     ofstream arquivo_escrever;\par
80     arquivo_escrever.open({\cf22 "Log_Controle.txt"});\par
81 \par
82     {\cf19 for}( {\cf18 int} j = 0; j < i; j++)\par
83     \{\par
84     {\cf19 if}( j == i - 1)\par
85     \{\par
86         arquivo_escrever << strupr(nome[j]) << {\cf23 '\\0'};\par
87     \}\par
88     {\cf19 else}\par
89     \{\par
90     {\cf20 //cout << nome[i] << endl;}\par
91     arquivo_escrever << strupr(nome[j]) << {\cf22 " "};\par
92     \}\par
93     \}\par
94 \par
95     cout << {\cf22 "arquivo inserido ao banco de arquivos com sucesso."} << endl;\par
96     {\cf20 //cout << "scmdksa" <<endl;}\par
97     {\cf20 //system("PAUSE > null");}\par
98 {\cf19 return} 0;\par
99 \par
100 \}\par
}
}
{\xe \v Escreve_No_Log_Palavra\:escreve.cpp}
{\xe \v escreve.cpp\:Escreve_No_Log_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Escreve_No_Log_Palavra ({\b ARQUIVO} * arquivo, {\b Tabela_Hash} tabela)}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 130 \{\par
131 \par
132     {\cf20 //system("PAUSE > null");}\par
133 \par
134     {\cf18 char} nome[30];\par
135     ofstream arquivo_escrever;\par
136     strcpy(nome, arquivo->nome_arquivo);\par
137     strcat(nome, {\cf22 "LogPal.txt"});\par
138     strupr(nome);\par
139     {\cf20 //cout << arquivo->nome_arquivo << endl;}\par
140     {\cf20 //cout << nome << endl;}\par
141 \par
142     arquivo_escrever.open(nome);\par
143 \par
144     {\cf19 if}(!arquivo_escrever.is_open())\par
145     \{\par
146         cout << {\cf22 "N\'E3o foi encontrado o arquivo: novo log de palavra ('nome do arquivo'LogPal.txt) para esse arquivo ser\'E1 criado."} << endl;\par
147         arquivo_escrever.clear();\par
148     \}\par
149 \par
150 \par
151     {\cf19 for}({\cf18 int} i = 0; i < arquivo->quantidade_palavras_nao_repetidas; i++)\par
152     \{\par
153         {\cf18 int} pos = hash_funcao(arquivo->Palavras_organizadas[i]);\par
154         {\cf19 if}(pos < 0)\par
155         \{\par
156             pos = pos * (-1);\par
157         \}\par
158         arquivo_escrever << tabela[pos].Palavra <<  {\cf22 " "};\par
159         arquivo_escrever << tabela[pos].quantidade << {\cf22 " "};\par
160         {\cf19 for}({\cf18 int}  j = 0; j < tabela[pos].quantidade; j++)\par
161         \{\par
162         {\cf19 if}(j == 0)\par
163         \{\par
164         arquivo_escrever <<  tabela[pos].linha[j];\par
165         \}\par
166         {\cf19 else}\par
167         \{\par
168         arquivo_escrever << {\cf22 " "} <<  tabela[pos].linha[j];\par
169         \}\par
170 \par
171         \}\par
172         arquivo_escrever << endl;\par
173 \par
174     \}\par
175 \par
176 arquivo_escrever.close();\par
177 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.h}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Escreve_No_Log_Arquivo} ({\b ARQUIVO} *arquivo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Escreve_No_Log_Palavra} ({\b ARQUIVO} *arquivo, {\b Tabela_Hash} tabela)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Escreve_No_Log_Controle} ({\b ARQUIVO} *arquivo)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Escreve_No_Log_Arquivo\:escreve.h}
{\xe \v escreve.h\:Escreve_No_Log_Arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Escreve_No_Log_Arquivo ({\b ARQUIVO} * arquivo)}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 103 \{\par
104     {\cf20 //cout << "scmdksa" <<endl;}\par
105     {\cf20 //system("PAUSE > null");}\par
106 \par
107     {\cf18 char} nome[TAMANHO_DA_PALAVRA];\par
108 \par
109     strcpy(nome, arquivo->nome_arquivo);\par
110     strcat(nome, {\cf22 "LogArq.txt"});\par
111     strupr(nome);\par
112 \par
113     ofstream arquivo_escrever;\par
114     arquivo_escrever.open(nome);\par
115 \par
116     {\cf19 if}(!arquivo_escrever.is_open())\par
117     \{\par
118         cout << {\cf22 "N\'E3o foi encontrado o arquivo:  novo log de palavra ('nome do arquivo'LogArq.txt) para esse arquivo ser\'E1 criado."} << endl;\par
119         arquivo_escrever.clear();\par
120     \}\par
121     arquivo_escrever << arquivo->quantidade_palavras <<  {\cf22 " "};\par
122     arquivo_escrever << arquivo->quantidade_palavras_nao_repetidas <<  {\cf22 " "};\par
123     arquivo_escrever << arquivo->numero_do_arquivo <<  {\cf22 " "};\par
124     {\cf20 //cout << arquivo->quantidade_palavras << endl;}\par
125     {\cf20 //cout << "scmdksa" <<endl;}\par
126     {\cf20 //system("PAUSE > null");}\par
127 \}\par
}
}
{\xe \v Escreve_No_Log_Controle\:escreve.h}
{\xe \v escreve.h\:Escreve_No_Log_Controle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Escreve_No_Log_Controle ({\b ARQUIVO} * arquivo)}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12 \{\par
13     {\cf18 char} nome[TAMANHO_DO_CONTROLE][TAMANHO_DA_PALAVRA];\par
14     {\cf18 int} i = 0;\par
15 \par
16 \par
17     {\cf19 for}( {\cf18 int} j = 0; j < TAMANHO_DO_CONTROLE; j++)\par
18     \{\par
19     strcpy(nome[j], {\cf22 " "});\par
20     \}\par
21 \par
22     {\cf20 /*}\par
23 {\cf20     ofstream arquivo_es;}\par
24 {\cf20     arquivo_es.open("Log_Controle.txt");}\par
25 {\cf20 }\par
26 {\cf20     if(!arquivo_es.is_open())}\par
27 {\cf20     \{}\par
28 {\cf20         cout << "N\'E3o foi encontrado o arquivo:" << endl;}\par
29 {\cf20         arquivo_es.clear();}\par
30 {\cf20         arquivo_es.open("Log_Controle.txt");}\par
31 {\cf20         arquivo_es << "       uihul " << endl;}\par
32 {\cf20     //arquivo_es.close();}\par
33 {\cf20     //return 0;}\par
34 {\cf20     \}}\par
35 {\cf20     */}\par
36 \par
37     {\cf20 //system("PAUSE > null");}\par
38     ifstream arquivo_ler;\par
39     arquivo_ler.open({\cf22 "Log_Controle.txt"});\par
40     {\cf19 if}(!arquivo_ler.is_open())\par
41     \{\par
42         cout << {\cf22 "N\'E3o foi encontrado o arquivo de controle: novo arquivo 'Log_controle.txt' ser\'E1 criado e primeiro nome de arquivo armazenado."} << endl;\par
43         arquivo_ler.close();\par
44     \}\par
45     {\cf19 if}(is_empty(arquivo_ler))\par
46     \{\par
47         arquivo_ler.close();\par
48         ofstream arquivo_escrever;\par
49         arquivo_escrever.open({\cf22 "Log_Controle.txt"});\par
50         arquivo_escrever << strupr(arquivo->nome_arquivo);\par
51 \par
52         cout << {\cf22 "arquivo inserido ao banco de arquivos com sucesso."} << endl;\par
53         {\cf20 //system("PAUSE > null");}\par
54         {\cf19 return} 0;\par
55     \}\par
56     {\cf19 else}\par
57     \{\par
58         {\cf19 while}(! arquivo_ler.eof())\par
59         \{\par
60                 arquivo_ler >> nome[i];\par
61                 {\cf20 //cout << nome[i] << endl;}\par
62                 {\cf20 //cout << arquivo->nome_arquivo<< endl;}\par
63                 {\cf20 //cout << "ljk\'E7wmafk\'E7l" << endl;}\par
64                 {\cf20 //system("PAUSE > null");}\par
65 \par
66                 {\cf19 if}(strcmp(nome[i], strupr(arquivo->nome_arquivo)) == 0)\par
67                 \{\par
68                     cout << {\cf22 "Existe um arquivo com mesmo nome no banco. Renomeie para inser\'E7\'E3o."} << endl;\par
69                     {\cf19 return} 0;\par
70                 \}\par
71                 i++;\par
72         \}\par
73     \}\par
74 \par
75     arquivo_ler.close();\par
76 \par
77     strcpy(nome[i],arquivo->nome_arquivo);\par
78     i++;\par
79     ofstream arquivo_escrever;\par
80     arquivo_escrever.open({\cf22 "Log_Controle.txt"});\par
81 \par
82     {\cf19 for}( {\cf18 int} j = 0; j < i; j++)\par
83     \{\par
84     {\cf19 if}( j == i - 1)\par
85     \{\par
86         arquivo_escrever << strupr(nome[j]) << {\cf23 '\\0'};\par
87     \}\par
88     {\cf19 else}\par
89     \{\par
90     {\cf20 //cout << nome[i] << endl;}\par
91     arquivo_escrever << strupr(nome[j]) << {\cf22 " "};\par
92     \}\par
93     \}\par
94 \par
95     cout << {\cf22 "arquivo inserido ao banco de arquivos com sucesso."} << endl;\par
96     {\cf20 //cout << "scmdksa" <<endl;}\par
97     {\cf20 //system("PAUSE > null");}\par
98 {\cf19 return} 0;\par
99 \par
100 \}\par
}
}
{\xe \v Escreve_No_Log_Palavra\:escreve.h}
{\xe \v escreve.h\:Escreve_No_Log_Palavra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Escreve_No_Log_Palavra ({\b ARQUIVO} * arquivo, {\b Tabela_Hash} tabela)}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 130 \{\par
131 \par
132     {\cf20 //system("PAUSE > null");}\par
133 \par
134     {\cf18 char} nome[30];\par
135     ofstream arquivo_escrever;\par
136     strcpy(nome, arquivo->nome_arquivo);\par
137     strcat(nome, {\cf22 "LogPal.txt"});\par
138     strupr(nome);\par
139     {\cf20 //cout << arquivo->nome_arquivo << endl;}\par
140     {\cf20 //cout << nome << endl;}\par
141 \par
142     arquivo_escrever.open(nome);\par
143 \par
144     {\cf19 if}(!arquivo_escrever.is_open())\par
145     \{\par
146         cout << {\cf22 "N\'E3o foi encontrado o arquivo: novo log de palavra ('nome do arquivo'LogPal.txt) para esse arquivo ser\'E1 criado."} << endl;\par
147         arquivo_escrever.clear();\par
148     \}\par
149 \par
150 \par
151     {\cf19 for}({\cf18 int} i = 0; i < arquivo->quantidade_palavras_nao_repetidas; i++)\par
152     \{\par
153         {\cf18 int} pos = hash_funcao(arquivo->Palavras_organizadas[i]);\par
154         {\cf19 if}(pos < 0)\par
155         \{\par
156             pos = pos * (-1);\par
157         \}\par
158         arquivo_escrever << tabela[pos].Palavra <<  {\cf22 " "};\par
159         arquivo_escrever << tabela[pos].quantidade << {\cf22 " "};\par
160         {\cf19 for}({\cf18 int}  j = 0; j < tabela[pos].quantidade; j++)\par
161         \{\par
162         {\cf19 if}(j == 0)\par
163         \{\par
164         arquivo_escrever <<  tabela[pos].linha[j];\par
165         \}\par
166         {\cf19 else}\par
167         \{\par
168         arquivo_escrever << {\cf22 " "} <<  tabela[pos].linha[j];\par
169         \}\par
170 \par
171         \}\par
172         arquivo_escrever << endl;\par
173 \par
174     \}\par
175 \par
176 arquivo_escrever.close();\par
177 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
escreve.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/escreve.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef _ESCREVE_H_}\par
2 {\cf21 #define _ESCREVE_H_}\par
3 \par
4 {\cf18 void} Escreve_No_Log_Arquivo(ARQUIVO *arquivo);\par
5 {\cf18 void} Escreve_No_Log_Palavra(ARQUIVO *arquivo, Tabela_Hash tabela);\par
6 {\cf18 bool} Escreve_No_Log_Controle(ARQUIVO *arquivo);\par
7 \par
8 \par
9 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.cpp}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.cpp}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "teste.h"}\par
{\f2 #include "consulta_palavra.h"}\par
{\f2 #include "Forma_da_Busca.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bor} (int pos, int pos1, {\b Hash} tab)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b band} (int pos, int pos1, {\b Hash} tab)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v band\:Forma_da_Busca.cpp}
{\xe \v Forma_da_Busca.cpp\:band}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void band (int pos, int pos1, {\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 104 \{\par
105     Hash tabela;\par
106     Dados *novo = (Dados*) {\cf17 new} Dados;\par
107     novo = tabela[0];\par
108     Dados *aux1, *aux2, *aux3, *aux4;\par
109     aux1 = tab[pos];\par
110     aux2 = tab[pos1];\par
111     aux3 = tabela[0];\par
112     aux4 = NULL;\par
113 \par
114 \par
115 \par
116     {\cf19 while}(aux1 != NULL)\par
117     \{\par
118         {\cf19 while}(aux2 != NULL)\par
119         \{\par
120             {\cf19 if}(strcmp(aux1->Arquivo, aux2->Arquivo) == 0)\par
121             \{\par
122                 Dados *novo = (Dados*) {\cf17 new} Dados;\par
123                 novo->quantidade = 0;\par
124                 cout << aux1->Arquivo << endl;\par
125                 {\cf19 for}( {\cf18 int} i = 0; i < aux1->quantidade; i++)\par
126                 \{\par
127 \par
128                     {\cf19 for}( {\cf18 int} j = 0; j < aux2->quantidade; j++)\par
129                     \{\par
130                         {\cf19 if}(aux1->linha[i] == aux2->linha[j])\par
131                         \{\par
132                              cout << aux1->linha[i] << {\cf22 "dk\'E7wa"} << endl;\par
133 \par
134                                 strcpy(novo->Arquivo, aux1->Arquivo);\par
135                                 strcpy(novo->Palavra, aux1->Palavra);\par
136                                 novo->linha[novo->quantidade] = aux1->linha[i];\par
137                                 novo->quantidade++;\par
138 \par
139                         \}\par
140 \par
141 \par
142 \par
143                     \}\par
144 \par
145                 \}\par
146 \par
147                 {\cf19 if}(novo->quantidade != 0 && tabela[0] == NULL)\par
148                 \{\par
149                     novo->ant = NULL;\par
150                     novo->prox = NULL;\par
151                     cout << novo->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
152                     tabela[0] = novo;\par
153                      cout << tabela[0]->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
154 \par
155 \par
156                 \}\par
157                 {\cf19 else} {\cf19 if} (novo->quantidade != 0 && tabela[0] != NULL)\par
158                 \{\par
159 \par
160                     {\cf19 while}(aux3 != NULL)\par
161                     \{\par
162                         aux4 = aux3;\par
163                         aux3 = aux3->prox;\par
164                     \}\par
165                     aux4->prox = novo;\par
166                     novo->ant = aux4;\par
167                     novo->prox = NULL;\par
168                 \}\par
169 \par
170                 aux3 = tabela[0];\par
171                 aux4 = NULL;\par
172             \}\par
173         aux2 = aux2->prox;\par
174         \}\par
175     aux1 = aux1->prox;\par
176     aux2 = tab[pos1];\par
177     \}\par
178 \par
179 \par
180 cout << tabela[0]->quantidade << {\cf22 "kmsa\'E7"} << endl;\par
181 cout << tabela[0]->Arquivo << {\cf22 "kmsa\'E7"} << endl;\par
182 cout << tabela[0]->linha[tabela[0]->quantidade - 1] << {\cf22 "kmsa\'E7"} << endl;\par
183 \par
184 \par
185 {\cf20 //Apresentar_Lista_Frase(tab, 0);     // faze sobreposi\'E7\'E3o de fun\'E7\'E3o!!}\par
186 \par
187 \par
188 \}\par
}
}
{\xe \v bor\:Forma_da_Busca.cpp}
{\xe \v Forma_da_Busca.cpp\:bor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void bor (int pos, int pos1, {\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15     Hash tabela;\par
16     Dados *novo = (Dados*) {\cf17 new} Dados;\par
17     novo = tabela[0];\par
18     Dados *aux1, *aux2, *aux3, *aux4;\par
19     aux1 = tab[pos];\par
20     aux2 = tab[pos1];\par
21     aux3 = tabela[0];\par
22     aux4 = NULL;\par
23 \par
24 \par
25 \par
26     {\cf19 while}(aux1 != NULL)\par
27     \{\par
28         {\cf19 while}(aux2 != NULL)\par
29         \{\par
30             {\cf19 if}(strcmp(aux1->Arquivo, aux2->Arquivo) == 0)\par
31             \{\par
32                 Dados *novo = (Dados*) {\cf17 new} Dados;\par
33                 novo->quantidade = 0;\par
34                 cout << aux1->Arquivo << endl;\par
35                 {\cf19 for}( {\cf18 int} i = 0; i < aux1->quantidade; i++)\par
36                 \{\par
37                     cout << aux1->linha[i] << {\cf22 "dk\'E7wa"} << endl;\par
38                     strcpy(novo->Arquivo, aux1->Arquivo);\par
39                     {\cf20 //strcpy(novo->Palavra, aux1->Palavra);}\par
40                     novo->linha[novo->quantidade] = aux1->linha[i];\par
41                     novo->quantidade++;\par
42                 \}\par
43                 {\cf19 for}( {\cf18 int} j = 0; j < aux2->quantidade; j++)\par
44                 \{\par
45                              cout << {\cf22 "hblj"} << aux2->linha[j] << {\cf22 "dk\'E7wa"} << endl;\par
46                           {\cf19 for}( {\cf18 int} k = 0; k < novo->quantidade; k++)\par
47                         \{\par
48                             {\cf19 if}(novo->linha[k] != aux2->linha[j])\par
49                             \{\par
50                                 novo->linha[novo->quantidade] = aux2->linha[j];\par
51                                 novo->quantidade++;\par
52 \par
53                             \}\par
54                         \}\par
55 \par
56 \par
57                     \}\par
58 \par
59 \par
60                 {\cf19 if}(novo->quantidade != 0 && tabela[0] == NULL)\par
61                 \{\par
62                     novo->ant = NULL;\par
63                     novo->prox = NULL;\par
64                     cout << novo->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
65                     tabela[0] = novo;\par
66                      cout << tabela[0]->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
67 \par
68 \par
69                 \}\par
70                 {\cf19 else} {\cf19 if} (novo->quantidade != 0 && tabela[0] != NULL)\par
71                 \{\par
72 \par
73                     {\cf19 while}(aux3 != NULL)\par
74                     \{\par
75                         aux4 = aux3;\par
76                         aux3 = aux3->prox;\par
77                     \}\par
78                     aux4->prox = novo;\par
79                     novo->ant = aux4;\par
80                     novo->prox = NULL;\par
81                 \}\par
82 \par
83                 aux3 = tabela[0];\par
84                 aux4 = NULL;\par
85             \}\par
86         aux2 = aux2->prox;\par
87         \}\par
88     aux1 = aux1->prox;\par
89     aux2 = tab[pos1];\par
90     \}\par
91 \par
92 \par
93 cout << tabela[0]->prox->quantidade << {\cf22 "kmsa\'E7"} << endl;\par
94 cout << tabela[0]->prox->Arquivo << {\cf22 "kmsa\'E7"} << endl;\par
95 cout << tabela[0]->prox->linha[tabela[0]->quantidade - 1] << {\cf22 "kmsa\'E7"} << endl;\par
96 \par
97 \par
98 \par
99 \par
100 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.h}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bor} (int pos, int pos1, {\b Hash} tab)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b band} (int pos, int pos1, {\b Hash} tab)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v band\:Forma_da_Busca.h}
{\xe \v Forma_da_Busca.h\:band}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void band (int pos, int pos1, {\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 104 \{\par
105     Hash tabela;\par
106     Dados *novo = (Dados*) {\cf17 new} Dados;\par
107     novo = tabela[0];\par
108     Dados *aux1, *aux2, *aux3, *aux4;\par
109     aux1 = tab[pos];\par
110     aux2 = tab[pos1];\par
111     aux3 = tabela[0];\par
112     aux4 = NULL;\par
113 \par
114 \par
115 \par
116     {\cf19 while}(aux1 != NULL)\par
117     \{\par
118         {\cf19 while}(aux2 != NULL)\par
119         \{\par
120             {\cf19 if}(strcmp(aux1->Arquivo, aux2->Arquivo) == 0)\par
121             \{\par
122                 Dados *novo = (Dados*) {\cf17 new} Dados;\par
123                 novo->quantidade = 0;\par
124                 cout << aux1->Arquivo << endl;\par
125                 {\cf19 for}( {\cf18 int} i = 0; i < aux1->quantidade; i++)\par
126                 \{\par
127 \par
128                     {\cf19 for}( {\cf18 int} j = 0; j < aux2->quantidade; j++)\par
129                     \{\par
130                         {\cf19 if}(aux1->linha[i] == aux2->linha[j])\par
131                         \{\par
132                              cout << aux1->linha[i] << {\cf22 "dk\'E7wa"} << endl;\par
133 \par
134                                 strcpy(novo->Arquivo, aux1->Arquivo);\par
135                                 strcpy(novo->Palavra, aux1->Palavra);\par
136                                 novo->linha[novo->quantidade] = aux1->linha[i];\par
137                                 novo->quantidade++;\par
138 \par
139                         \}\par
140 \par
141 \par
142 \par
143                     \}\par
144 \par
145                 \}\par
146 \par
147                 {\cf19 if}(novo->quantidade != 0 && tabela[0] == NULL)\par
148                 \{\par
149                     novo->ant = NULL;\par
150                     novo->prox = NULL;\par
151                     cout << novo->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
152                     tabela[0] = novo;\par
153                      cout << tabela[0]->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
154 \par
155 \par
156                 \}\par
157                 {\cf19 else} {\cf19 if} (novo->quantidade != 0 && tabela[0] != NULL)\par
158                 \{\par
159 \par
160                     {\cf19 while}(aux3 != NULL)\par
161                     \{\par
162                         aux4 = aux3;\par
163                         aux3 = aux3->prox;\par
164                     \}\par
165                     aux4->prox = novo;\par
166                     novo->ant = aux4;\par
167                     novo->prox = NULL;\par
168                 \}\par
169 \par
170                 aux3 = tabela[0];\par
171                 aux4 = NULL;\par
172             \}\par
173         aux2 = aux2->prox;\par
174         \}\par
175     aux1 = aux1->prox;\par
176     aux2 = tab[pos1];\par
177     \}\par
178 \par
179 \par
180 cout << tabela[0]->quantidade << {\cf22 "kmsa\'E7"} << endl;\par
181 cout << tabela[0]->Arquivo << {\cf22 "kmsa\'E7"} << endl;\par
182 cout << tabela[0]->linha[tabela[0]->quantidade - 1] << {\cf22 "kmsa\'E7"} << endl;\par
183 \par
184 \par
185 {\cf20 //Apresentar_Lista_Frase(tab, 0);     // faze sobreposi\'E7\'E3o de fun\'E7\'E3o!!}\par
186 \par
187 \par
188 \}\par
}
}
{\xe \v bor\:Forma_da_Busca.h}
{\xe \v Forma_da_Busca.h\:bor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void bor (int pos, int pos1, {\b Hash} tab)}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15     Hash tabela;\par
16     Dados *novo = (Dados*) {\cf17 new} Dados;\par
17     novo = tabela[0];\par
18     Dados *aux1, *aux2, *aux3, *aux4;\par
19     aux1 = tab[pos];\par
20     aux2 = tab[pos1];\par
21     aux3 = tabela[0];\par
22     aux4 = NULL;\par
23 \par
24 \par
25 \par
26     {\cf19 while}(aux1 != NULL)\par
27     \{\par
28         {\cf19 while}(aux2 != NULL)\par
29         \{\par
30             {\cf19 if}(strcmp(aux1->Arquivo, aux2->Arquivo) == 0)\par
31             \{\par
32                 Dados *novo = (Dados*) {\cf17 new} Dados;\par
33                 novo->quantidade = 0;\par
34                 cout << aux1->Arquivo << endl;\par
35                 {\cf19 for}( {\cf18 int} i = 0; i < aux1->quantidade; i++)\par
36                 \{\par
37                     cout << aux1->linha[i] << {\cf22 "dk\'E7wa"} << endl;\par
38                     strcpy(novo->Arquivo, aux1->Arquivo);\par
39                     {\cf20 //strcpy(novo->Palavra, aux1->Palavra);}\par
40                     novo->linha[novo->quantidade] = aux1->linha[i];\par
41                     novo->quantidade++;\par
42                 \}\par
43                 {\cf19 for}( {\cf18 int} j = 0; j < aux2->quantidade; j++)\par
44                 \{\par
45                              cout << {\cf22 "hblj"} << aux2->linha[j] << {\cf22 "dk\'E7wa"} << endl;\par
46                           {\cf19 for}( {\cf18 int} k = 0; k < novo->quantidade; k++)\par
47                         \{\par
48                             {\cf19 if}(novo->linha[k] != aux2->linha[j])\par
49                             \{\par
50                                 novo->linha[novo->quantidade] = aux2->linha[j];\par
51                                 novo->quantidade++;\par
52 \par
53                             \}\par
54                         \}\par
55 \par
56 \par
57                     \}\par
58 \par
59 \par
60                 {\cf19 if}(novo->quantidade != 0 && tabela[0] == NULL)\par
61                 \{\par
62                     novo->ant = NULL;\par
63                     novo->prox = NULL;\par
64                     cout << novo->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
65                     tabela[0] = novo;\par
66                      cout << tabela[0]->linha[0] << {\cf22 "ek\'E7wa"}<< endl;\par
67 \par
68 \par
69                 \}\par
70                 {\cf19 else} {\cf19 if} (novo->quantidade != 0 && tabela[0] != NULL)\par
71                 \{\par
72 \par
73                     {\cf19 while}(aux3 != NULL)\par
74                     \{\par
75                         aux4 = aux3;\par
76                         aux3 = aux3->prox;\par
77                     \}\par
78                     aux4->prox = novo;\par
79                     novo->ant = aux4;\par
80                     novo->prox = NULL;\par
81                 \}\par
82 \par
83                 aux3 = tabela[0];\par
84                 aux4 = NULL;\par
85             \}\par
86         aux2 = aux2->prox;\par
87         \}\par
88     aux1 = aux1->prox;\par
89     aux2 = tab[pos1];\par
90     \}\par
91 \par
92 \par
93 cout << tabela[0]->prox->quantidade << {\cf22 "kmsa\'E7"} << endl;\par
94 cout << tabela[0]->prox->Arquivo << {\cf22 "kmsa\'E7"} << endl;\par
95 cout << tabela[0]->prox->linha[tabela[0]->quantidade - 1] << {\cf22 "kmsa\'E7"} << endl;\par
96 \par
97 \par
98 \par
99 \par
100 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Forma_da_Busca.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/Forma_da_Busca.h}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef _FORMA_DA_BUSCA_H}\par
2 {\cf21 #define _FORMA_DA_BUSCA_H}\par
3 \par
4 {\cf18 void} bor({\cf18 int} pos, {\cf18 int} pos1, Hash tab);\par
5 {\cf18 void} band({\cf18 int} pos, {\cf18 int} pos1, Hash tab);\par
6 \par
7 {\cf21 #endif}\par
8 \par
9 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/main.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/main.cpp}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/main.cpp}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <fstream>}\par
{\f2 #include <string.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include "Apaga.h"}\par
{\f2 #include "teste.h"}\par
{\f2 #include "escreve.h"}\par
{\f2 #include "consulta_palavra.h"}\par
{\f2 #include "Consulta_Base_Arquivos.h"}\par
{\f2 #include "Forma_da_Busca.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VERSION}\~ "scs_1.0"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b no_argument}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b required_argument}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b optional_argument}\~ 2\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e macros\par
\pard\plain 
{\xe \v no_argument\:main.cpp}
{\xe \v main.cpp\:no_argument}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define no_argument\~ 0}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v optional_argument\:main.cpp}
{\xe \v main.cpp\:optional_argument}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define optional_argument\~ 2}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v required_argument\:main.cpp}
{\xe \v main.cpp\:required_argument}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define required_argument\~ 1}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VERSION\:main.cpp}
{\xe \v main.cpp\:VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VERSION\~ "scs_1.0"}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v main\:main.cpp}
{\xe \v main.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int argc, char * argv[])}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22                                   \{\par
23     \par
24     Tabela_Hash Tabela_controle_Hash;           {\cf20 //Nomes Claros e Significativos}\par
25     Hash tab;\par
26     ARQUIVO *arquivo = (ARQUIVO*) {\cf17 new} ARQUIVO;\par
27     LISTA *lista_de_arquivos = (LISTA*) {\cf17 new} LISTA;\par
28     lista_de_arquivos->ini->arquivo = (ARQUIVO*) {\cf17 new} ARQUIVO; \par
29 \par
30     Inicializar_Hash(Tabela_controle_Hash);\par
31     Inicializar_Vetor_arquivo(arquivo);\par
32     Inicializar_Lista(lista_de_arquivos);\par
33     \par
34     {\cf18 bool} timer = {\cf17 false};                 \par
35     clock_t tempoInicial, tempoFinal;\par
36     {\cf18 double} tempo_gasto;\par
37     \par
38     {\cf18 int} index;\par
39     {\cf18 int} Controle_do_Menu=0;\par
40     {\cf18 bool} Ajuda_Flag = {\cf17 false};\par
41     \par
42     {\cf17 const} {\cf17 struct }option longopts[] = \{\par
43     \par
44     \{{\cf22 "Exibir_Menu_Ajuda"},       no_argument,        0, {\cf23 'h'}\},\par
45 \par
46     \{{\cf22 "Inserir_Arquivo"},     required_argument,  0, {\cf23 'i'}\},                {\cf20 //modo de gerencialmente}\par
47     \{{\cf22 "Remover_Arquivo"},      required_argument,  0, {\cf23 'r'}\},\par
48     \{{\cf22 "Listar_Base_Arquivo_por_Insercao"},      no_argument,        0, {\cf23 'e'}\},\par
49     \{{\cf22 "Listar_Base_Arquivo_por_Ordem_Alfabetica"},      no_argument,        0, {\cf23 'a'}\},\par
50     \{{\cf22 "Listar_Base_Arquivo_por_Quantidade_Palavras"},    no_argument,  0, {\cf23 'p'}\},\par
51 \par
52     \{{\cf22 "Pesquisa_AND"},      required_argument,        0, {\cf23 'd'}\},          {\cf20 //modo de busca}\par
53     \{{\cf22 "Pesquisa_OR"},       required_argument,        0, {\cf23 'o'}\},\par
54     \{{\cf22 "Exibir_resultados_Por_Ordem_Alfabetica"},      no_argument,        0, {\cf23 'b'}\},\par
55     \{{\cf22 "Exibir_resultados_Por_Quantidade_Palavras"},       no_argument,        0, {\cf23 'q'}\},\par
56     \{{\cf22 "Exibir_resultados_Por_Ordem_Insercao"},    no_argument,  0, {\cf23 'c'}\},\par
57 \par
58     \{{\cf22 "Apresentar_Tempo_De_Busca"},     no_argument,  0, {\cf23 's'}\},\par
59     \{{\cf22 "Nao_Apresentar_Tempo_De_Busca"},      no_argument,  0, {\cf23 'n'}\},\par
60     \{0,0,0,0\},\par
61     \};\par
62 \par
63       {\cf19 if}( argc < 2) \{\par
64             Imprimir_Ajuda();\par
65         \}\par
66 \par
67   {\cf20 //desativa as mensagens de erro do getopt}\par
68     opterr=0;\par
69 \par
70     {\cf19 while}(Controle_do_Menu != -1) \{\par
71       \par
72         Controle_do_Menu = getopt_long(argc, argv, {\cf22 "hi:r:eapd:o:bqcsn"}, longopts, &index);\par
73 \par
74         {\cf19 switch} (Controle_do_Menu) \{\par
75 \par
76             {\cf19 case} {\cf23 '?'}:      {\cf20 // erro - opcao desconhecida}\par
77                 std::cout << {\cf22 "Opcao "} << (char) optopt << {\cf22 " eh invalida."} << std::endl;\par
78                 {\cf19 break};\par
79             \par
80             {\cf19 case} -1:      {\cf20 // erro - opcao desconhecida}\par
81                 std::cout << {\cf22 "Fim da linha de comando."} << std::endl;\par
82                 tempoFinal = clock();\par
83                 {\cf19 break};\par
84 \par
85             {\cf19 case} {\cf23 'h'}:        \par
86                 {\cf19 if} (Ajuda_Flag) \{\par
87                     std::cout << {\cf22 "Flag 'h' repetida"} << std::endl;\par
88                     {\cf19 break};\par
89                 \}\par
90         \par
91                 Ajuda_Flag = {\cf17 true};\par
92                 Imprimir_Ajuda();\par
93                 {\cf19 break};\par
94 \par
95             {\cf19 case} {\cf23 'i'}:     {\cf20 //inserir arquivo}\par
96                 std::cout << {\cf22 "Tentando inserir arquivo no banco de arquivos. "}  << std::endl;\par
97 \par
98                 {\cf19 if}(Dados_Arquivo(Tabela_controle_Hash,arquivo, optarg) != 0) \{\par
99                     \par
100                     cout << {\cf22 "Tentando inserir o arquivo: "} << optarg << endl;\par
101                     \par
102                     Escreve_No_Log_Palavra(arquivo, Tabela_controle_Hash);\par
103                     Escreve_No_Log_Arquivo(arquivo);\par
104                     Escreve_No_Log_Controle(arquivo);\par
105                 \}\par
106               \par
107                 cout << endl;\par
108                 index = optind;\par
109 \par
110                 {\cf19 if} (argv[index] != NULL  && argv[index][0]!={\cf23 '-'}) \{\par
111                     \par
112                     {\cf19 while}(index < argc && argv[index][0]!={\cf23 '-'}) \{\par
113                         \par
114                         cout << {\cf22 "Tentando inserir o arquivo "} << argv[index] << endl;\par
115                         \par
116                         {\cf19 if}(Dados_Arquivo(Tabela_controle_Hash,arquivo, argv[index]) != 0) \{\par
117                             \par
118                               Escreve_No_Log_Palavra(arquivo, Tabela_controle_Hash);\par
119                               Escreve_No_Log_Arquivo(arquivo);\par
120                               Escreve_No_Log_Controle(arquivo);\par
121                         \}\par
122                               \par
123                         cout << endl;\par
124                         index++;\par
125                     \}\par
126                     optind = index-1;\par
127                 \}\par
128                 {\cf19 break};\par
129 \par
130              {\cf19 case} {\cf23 'r'}:       {\cf20 // remover arquivo}\par
131                 cout << {\cf22 "Tentando remover o arquivo "} << optarg << endl;\par
132             \par
133                 Remove_Log_Controle(optarg);\par
134             \par
135                 index = optind;\par
136                 cout << endl;\par
137             \par
138                 {\cf19 if} (argv[index] != NULL  && argv[index][0]!={\cf23 '-'}) \{\par
139         \par
140                     {\cf19 while}(index < argc && argv[index][0]!={\cf23 '-'}) \{\par
141                         \par
142                         cout << {\cf22 "Tentando remover o arquivo "} << argv[index] << endl;\par
143                         Remove_Log_Controle(argv[index]);\par
144                         index++;\par
145                         cout << endl;\par
146                     \}\par
147                     optind = index-1;\par
148                     cout << endl;\par
149                 \}\par
150                 {\cf19 break};\par
151     \par
152             {\cf19 case} {\cf23 'e'}:                                                                           {\cf20 //EVITE COMENT\'C1RIOS DESNECESS\'C1RIOS }\par
153                 std::cout << {\cf22 "Listar banco de arquivos por ordem de insercao: "} << std::endl;\par
154                 Consulta_Base_Insercao();\par
155     \par
156             {\cf19 case} {\cf23 'a'}:         \par
157                 std::cout << {\cf22 "Listar banco de arquivos por ordem alfab\'E9tica"} << std::endl;\par
158                 Consulta_Base_Alfabetica();\par
159                 {\cf19 break};\par
160     \par
161             {\cf19 case} {\cf23 'p'}:         \par
162                 std::cout << {\cf22 "Listar banco de arquivos por ordem de palavras: "} << std::endl;\par
163                 Consulta_Base_Quantidade_Palavras();\par
164                 {\cf19 break};\par
165 \par
166             {\cf19 case} {\cf23 'd'}:         {\cf20 // busca feita com and}\par
167                 std::cout << {\cf22 "Argumento and: "}  << std::endl;\par
168                 \par
169                 Consulta_Palavra(optarg, tab);\par
170                 Apresentar_Lista_Frase(tab, optarg);\par
171                 \par
172                 index = optind;\par
173                 \par
174                 {\cf19 if} (argv[index] != NULL  && argv[index][0]!={\cf23 '-'}) \{\par
175                     {\cf19 while}(index < argc && argv[index][0]!={\cf23 '-'}) \{\par
176             \par
177                         index++;\par
178                     \}\par
179                     optind = index-1;\par
180                 \}\par
181                 {\cf19 break};\par
182 \par
183             {\cf19 case} {\cf23 'o'}:             {\cf20 // busca feita com or}\par
184                 std::cout << {\cf22 "Argumento or"} << std::endl;\par
185                 \par
186                 Consulta_Palavra(optarg, tab);\par
187                 Apresentar_Lista_Frase(tab, optarg);\par
188                 \par
189                 index = optind;\par
190                 \par
191                 {\cf19 if} (argv[index] != NULL  && argv[index][0]!={\cf23 '-'}) \{\par
192                     {\cf19 while}(index < argc && argv[index][0]!={\cf23 '-'}) \{\par
193                         index++;\par
194                     \}\par
195                     optind = index-1;\par
196                 \}\par
197                 {\cf19 break};\par
198 \par
199             {\cf19 case} {\cf23 'b'}:            \par
200                 std::cout << {\cf22 "Imprimir ordem alfabetico: "} << std::endl;\par
201                 {\cf19 break};\par
202             \par
203             {\cf19 case} {\cf23 'q'}:         \par
204                 std::cout << {\cf22 "Imprimir decrescente de vezes que a palavra aparece: "} << std::endl;\par
205                 {\cf19 break};\par
206         \par
207             {\cf19 case} {\cf23 'c'}:         \par
208                 std::cout << {\cf22 "Imprirmir na ordem de inser\'E7\'E3o: "}  << std::endl;\par
209                 {\cf19 break};\par
210         \par
211             {\cf19 case} {\cf23 's'}:           \par
212                 std::cout << {\cf22 "Registra o tempo: "} << std::endl;\par
213                 tempoInicial = clock();\par
214                 timer = {\cf17 true};\par
215                 {\cf19 break};\par
216         \par
217             {\cf19 case} {\cf23 'n'}:           \par
218                 std::cout << {\cf22 " N\'E3o Registra o tempo "} << std::endl;\par
219                 timer = {\cf17 false};\par
220                 {\cf19 break};\par
221         \}   \par
222    \}\par
223 \par
224     {\cf19 if}(timer == {\cf17 true}) \{\par
225     \par
226     tempo_gasto = double (tempoFinal - tempoInicial) /CLOCKS_PER_SEC;\par
227     cout << {\cf22 "O tempo gasto foi de:"} << tempo_gasto  << endl;\par
228     \}\par
229 \par
230   {\cf19 return} 0;\par
231 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.cpp}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.cpp}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "teste.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Imprimir_Ajuda} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Hash} ({\b Tabela_Hash} tabela)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Vetor_arquivo} ({\b ARQUIVO} *arquivo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Lista} ({\b LISTA} *lista)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b colisao_funcao} ({\b Tabela_Hash} tabela, int cont)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hash_funcao} (char *palavra)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_empty} (std::ifstream &pFile)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Atualiza_buffer} ({\b Tabela_Hash} tabela, int pos, int linha, char palavra[])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Dados_Arquivo} ({\b Tabela_Hash} tabela, {\b ARQUIVO} *arquivo, char *nome)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Atualiza_buffer\:teste.cpp}
{\xe \v teste.cpp\:Atualiza_buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Atualiza_buffer ({\b Tabela_Hash} tabela, int pos, int linha, char palavra[])}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 114 \{\par
115 \par
116     strcpy(tabela[pos].Palavra, palavra);\par
117     {\cf20 //tabela[pos].Documento = "lista.txt";}\par
118     tabela[pos].linha[tabela[pos].quantidade] = linha;\par
119     tabela[pos].quantidade++;\par
120     tabela[pos].livre = {\cf17 false};\par
121     {\cf20 //tabela[pos].prox = NULL;}\par
122     {\cf20 //tabela[pos].ant = NULL;}\par
123 \par
124 \}\par
}
}
{\xe \v colisao_funcao\:teste.cpp}
{\xe \v teste.cpp\:colisao_funcao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int colisao_funcao ({\b Tabela_Hash} tabela, int cont)}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 75 \{\par
76 \par
77 \par
78  {\cf19 while}( tabela[cont].livre == {\cf17 false} )\par
79         \{\par
80             cont = cont + 1;\par
81         \}\par
82         {\cf19 return} cont;\par
83 \}\par
}
}
{\xe \v Dados_Arquivo\:teste.cpp}
{\xe \v teste.cpp\:Dados_Arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Dados_Arquivo ({\b Tabela_Hash} tabela, {\b ARQUIVO} * arquivo, char * nome)}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 128 \{\par
129 \par
130         {\cf20 //Tabela_Hash tabela;}\par
131     {\cf18 char} a[TAMANHO_DA_PALAVRA], palavra[TAMANHO_DA_PALAVRA], **vetor_pra_ordenamento;\par
132     {\cf18 int} i  = 0, pos = 0, linha = 0, u = 0;\par
133 \par
134     vetor_pra_ordenamento = {\cf17 new} {\cf18 char}*[TAMANHO_VETOR_TEMPORARIO];\par
135     {\cf19 for}({\cf18 int} i = 0; i < TAMANHO_VETOR_TEMPORARIO; i++)\par
136     \{\par
137     vetor_pra_ordenamento[i] = {\cf17 new} {\cf18 char}[TAMANHO_DA_PALAVRA];\par
138     \}\par
139 \par
140     ifstream arquivoentrada;\par
141     {\cf20 //abre_arquivo(ifstream arquivoentrada);}\par
142 \par
143         arquivoentrada.open(nome);\par
144 \par
145     {\cf19 if}(!arquivoentrada.is_open())\par
146     \{\par
147         cout << {\cf22 "N\'E3o foi encontrado o arquivo: Insera-no na pasta atual."} << endl;\par
148         arquivoentrada.clear();\par
149         {\cf19 return} {\cf17 false};\par
150     \}\par
151 \par
152 \par
153 \par
154 \par
155     {\cf19 while}(arquivoentrada.eof() != 1)\par
156     \{\par
157         a[i] = arquivoentrada.get();\par
158 \par
159         {\cf19 if}((a[i] >= 32 && a[i] <= 64) || (a[i] > 90 && a[i] < 97)  || (a[i] > 122 && a[i] < 128) || a[i] == {\cf23 '\\n'})\par
160         \{\par
161         {\cf19 if}(a[i] == {\cf23 '\\n'})\par
162         \{\par
163             linha++;\par
164         \}\par
165 \par
166         {\cf19 if}((a[0] >= 32 && a[0] <= 64) || (a[0] > 90 && a[0] < 97)  || (a[0] > 122 && a[0] < 128) || a[0] == {\cf23 '\\n'})\par
167         \{\par
168 \par
169         \}\par
170         {\cf19 else}\par
171         \{\par
172 \par
173             a[i] = {\cf23 '\\0'};\par
174             strcpy(palavra, a);\par
175             strcpy(vetor_pra_ordenamento[u], strupr(palavra));\par
176             u++;\par
177 \par
178             {\cf18 int} pos = hash_funcao(a);\par
179 \par
180             {\cf20 //cout << tabela[pos].livre << endl;}\par
181             {\cf19 if}(strcmp(tabela[pos].Palavra, palavra) != 0 && tabela[pos].livre == {\cf17 false})\par
182             \{\par
183                pos = colisao_funcao(tabela, pos);\par
184             \}\par
185 \par
186             Atualiza_buffer(tabela, pos, linha, palavra);\par
187 \par
188 \par
189             {\cf19 for}({\cf18 int} j = 0; j <= i; j++ )\par
190             \{\par
191                {\cf20 //cout << a[j];}\par
192                 a[j] = {\cf23 ' '};\par
193             \}\par
194             i = 0;\par
195            {\cf20 //cout <<endl;}\par
196             \}\par
197         \}\par
198         {\cf19 else}\par
199         \{\par
200          i++;\par
201         \}\par
202 \par
203 \par
204     \}\par
205 \par
206 \par
207 \par
208     {\cf20 //ordenamento das palavras do arquivo}\par
209 {\cf18 int} total = u;\par
210 {\cf20 //system("PAUSE > null");}\par
211 \par
212 \par
213 {\cf18 char} *aux = ({\cf18 char}*) {\cf17 new} {\cf18 char};\par
214 \par
215 {\cf19 for}({\cf18 int} r = 0; r < u; r++)\par
216 \{\par
217     {\cf19 for}({\cf18 int} s = r+1; s < u; s++)\par
218     \{\par
219         {\cf19 if} (strcmp(vetor_pra_ordenamento[r],vetor_pra_ordenamento[s])>0)\par
220             \{\par
221                strcpy(aux,vetor_pra_ordenamento[s]);\par
222                strcpy(vetor_pra_ordenamento[s],vetor_pra_ordenamento[r]);\par
223                strcpy(vetor_pra_ordenamento[r], aux);\par
224             \}\par
225     \}\par
226 \par
227 \}\par
228 \par
229 \par
230 {\cf19 for}({\cf18 int} q = 0; q < u; q++)\par
231 \{\par
232   {\cf20 //   cout << vetor_pra_ordenamento[q] << endl;}\par
233 \par
234 \}\par
235 \par
236 \par
237 \par
238 {\cf19 for}({\cf18 int} p = 0; p < u - 1; p++)\par
239 \{\par
240 \par
241 \par
242     {\cf19 if}(strcmp(vetor_pra_ordenamento[p], vetor_pra_ordenamento[p+1]) == 0)\par
243     \{\par
244     {\cf20 //cout << strcmp(vetor_pra_ordenamento[p], vetor_pra_ordenamento[p+1]) << endl;}\par
245     {\cf20 //cout << u << endl;}\par
246     {\cf20 //cout << vetor_pra_ordenamento[p] << "||" << vetor_pra_ordenamento[p+ 1] << endl;}\par
247 \par
248         {\cf19 for}(i= p ; i < u - 1; i++)\par
249         \{\par
250             {\cf20 //cout << vetor_pra_ordenamento[i] << "||" << vetor_pra_ordenamento[i+ 1] << "SDXSZ" << endl ;}\par
251             strcpy(vetor_pra_ordenamento[i],vetor_pra_ordenamento[i+1]);\par
252             {\cf20 //cout << vetor_pra_ordenamento[i] << "||" << vetor_pra_ordenamento[i+ 1] << endl;}\par
253            {\cf20 // system("PAUSE > null");}\par
254         \}\par
255           u--;\par
256           p--;\par
257 \par
258     \}\par
259 \par
260 \}\par
261 \par
262 {\cf20 /*}\par
263 {\cf20 for(int q = 0; q < u; q++)}\par
264 {\cf20 \{}\par
265 {\cf20     cout << vetor_pra_ordenamento[q] << endl;}\par
266 {\cf20 }\par
267 {\cf20 \}}\par
268 {\cf20 */}\par
269 \par
270   arquivoentrada.close();\par
271 \par
272   {\cf20 //ARQUIVO *arquivo = (ARQUIVO*) new ARQUIVO;}\par
273   strcpy(arquivo->nome_arquivo, nome);\par
274   arquivo->quantidade_palavras = total;\par
275   arquivo->quantidade_palavras_nao_repetidas = u;\par
276   arquivo->Palavras_organizadas = vetor_pra_ordenamento;\par
277   arquivo->numero_do_arquivo++;\par
278 \par
279 \par
280 {\cf19 return} {\cf17 true};\par
281 \par
282 {\cf20 /*}\par
283 {\cf20 cout << tabela[152].Palavra << endl;}\par
284 {\cf20 cout << tabela[152].quantidade << endl << endl;}\par
285 {\cf20 for(int k = 0; k < tabela[152].quantidade; k++)}\par
286 {\cf20 \{}\par
287 {\cf20     cout << tabela[152].linha[k] << endl;}\par
288 {\cf20 }\par
289 {\cf20 \}}\par
290 {\cf20 */}\par
291 \}\par
}
}
{\xe \v hash_funcao\:teste.cpp}
{\xe \v teste.cpp\:hash_funcao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int hash_funcao (char * palavra)}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 86 \{\par
87    {\cf20 // system("PAUSE > null");}\par
88     palavra = strupr(palavra);\par
89     {\cf18 int} cont = 0, r = 0;\par
90     {\cf19 while}(palavra[r] != {\cf23 '\\0'})\par
91     \{\par
92         r++;\par
93     \}\par
94     {\cf19 for}({\cf18 int} j = 0; j < r; j++)\par
95     \{\par
96         cont = cont + palavra[j];\par
97     \}\par
98     {\cf19 if}(cont < 0)\par
99     \{\par
100     cont = (-1) * cont;\par
101     \}\par
102     {\cf20 //cout<< cont<< endl;}\par
103     {\cf19 return} ({\cf18 unsigned} {\cf18 int})  cont;\par
104 \par
105 \}\par
}
}
{\xe \v Imprimir_Ajuda\:teste.cpp}
{\xe \v teste.cpp\:Imprimir_Ajuda}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Imprimir_Ajuda ()}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12 \{\par
13 \par
14     cout << {\cf22 "op\'E7\'F5es:"} << endl;\par
15     cout << {\cf22 " ##Modo de Gerenciamento de Busca:"} << endl << endl;\par
16     cout <<{\cf22 "-h ou --ajuda: mostra essa tela e sai."} << endl\par
17      << {\cf22 "-i ou --Inserir: Inserir novo arquivo na base de dados."} << endl\par
18      << {\cf22 "-r ou --Remover: Remover arquivo na base de dados."} << endl << endl;\par
19 \par
20      cout << {\cf22 "Exibi\'E7\'E3o da base de arquivo:"} << endl << endl\par
21      << {\cf22 "-e ou --List_Insercao: Listar todos os arquivos da base tendo como base a ordem de Insercao."} << endl\par
22      << {\cf22 "-a ou --List_Alfabetico: Listar todos os arquivos da base tendo como base a ordem alfab\'E9tica."} << endl\par
23      << {\cf22 "-p ou --List_Quant_Palavras: Listar todos os arquivos da base tendo como base A ordem decrescente da quantidade de palavras do arquivo."} << endl << endl;\par
24 \par
25     cout << {\cf22 " ##Modo de Buscas:"} << endl << endl;\par
26 \par
27     cout << {\cf22 "Argumento de Busca:"} << endl << endl\par
28     << {\cf22 "-d ou --bAND _And:A busca \'E9 feita por linhas dos arquivos texto que cont\'E9m todas as palavras chave passadas como argumento de entrada."} << endl\par
29     << {\cf22 "-o ou --bOR : A busca \'E9 feita por linhas dos arquivos texto que cont\'E9m ao menos uma das palavras chave passadas como argumento de entrada."} << endl;\par
30 \par
31     cout << {\cf22 "Exibi\'E7\'E3o do resultado da busca:"} << endl << endl\par
32     << {\cf22 "-b ou --Impress_Alfabetica: A impress\'E3o \'E9 feita exibindo os resultados em ordem alfab\'E9tica do nome do arquivo."} << endl\par
33     << {\cf22 "-q ou --Impress_Quant_Palavras: A impress\'E3o \'E9 feita exibindo os resultados em ordem decrescente do n\'FAmero de vezes que as palavraschave ocorreram em cada arquivo."} << endl\par
34     << {\cf22 "-c ou --Impress_Insercao: A impress\'E3o \'E9 feita exibindo os resultados na ordem em que cada arquivo foi inserido na base."} << endl;\par
35 \par
36     cout << {\cf22 "Contabiliza\'E7\'E3o do tempo:"} << endl << endl\par
37     << {\cf22 "-s ou --Temp_S: O programa deve registrar e exibir o tempo total de execu\'E7\'E3o de da busca."} << endl\par
38     << {\cf22 "-n ou --Temp_N: O programa n\'E3o deve registrar nem exibir o tempo total de execu\'E7\'E3o da busca."} << endl;\par
39 \}\par
}
}
{\xe \v Inicializar_Hash\:teste.cpp}
{\xe \v teste.cpp\:Inicializar_Hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Hash ({\b Tabela_Hash} tabela)}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 42 \{\par
43 \par
44 \par
45     {\cf19 for}({\cf18 int} i = 0; i < TAMANHO; i++)\par
46       \{\par
47        tabela[i].quantidade = 0;\par
48        tabela[i].livre = {\cf17 true};\par
49        tabela[i].prox = NULL;\par
50        tabela[i].ant = NULL;\par
51        {\cf19 for}({\cf18 int} j = 0; j < QUANTIDADE_DE_LINHAS; j++)\par
52        \{\par
53            tabela[i].linha[j] = 0;\par
54        \}\par
55        \}\par
56 \par
57 \}\par
}
}
{\xe \v Inicializar_Lista\:teste.cpp}
{\xe \v teste.cpp\:Inicializar_Lista}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Lista ({\b LISTA} * lista)}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 69 \{\par
70     lista->ini = NULL;\par
71     lista->fim = NULL;\par
72     lista->Quantidade_de_Arquivos = 0;\par
73 \}\par
}
}
{\xe \v Inicializar_Vetor_arquivo\:teste.cpp}
{\xe \v teste.cpp\:Inicializar_Vetor_arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Vetor_arquivo ({\b ARQUIVO} * arquivo)}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 60 \{\par
61 \par
62     arquivo->numero_do_arquivo = 0;\par
63     arquivo->quantidade_palavras = 0;\par
64     arquivo->quantidade_palavras_nao_repetidas = 0;\par
65 \}\par
}
}
{\xe \v is_empty\:teste.cpp}
{\xe \v teste.cpp\:is_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool is_empty (std::ifstream & pFile)}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 108 \{\par
109 {\cf19 return} pFile.peek() == std::ifstream::traits_type::eof();\par
110 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.h}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nos}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dado}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b no}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b LISTA}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TESTE_H_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TAMANHO}\~ 2000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b QUANTIDADE_DE_LINHAS}\~ 200\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TAMANHO_DA_PALAVRA}\~ 35\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TAMANHO_DO_CONTROLE}\~ 100\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TAMANHO_VETOR_TEMPORARIO}\~ 500\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TAMANHO_DA_FRASE}\~ 200\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b nos} {\b Dados}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b Dados} {\b Tabela_Hash}[{\b TAMANHO}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b Dados} * {\b Hash}[{\b TAMANHO}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b dado} {\b ARQUIVO}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b no} {\b NoLISTA}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Imprimir_Ajuda} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Hash} ({\b Tabela_Hash} tabela)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Vetor_arquivo} ({\b ARQUIVO} *arquivo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Inicializar_Lista} ({\b LISTA} *lista)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_empty} (std::ifstream &pFile)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Dados_Arquivo} ({\b Tabela_Hash} tabela, {\b ARQUIVO} *arquivo, char *nome)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Atualiza_buffer} ({\b Tabela_Hash} tabela, int pos, int linha, char palavra[], char *nome)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hash_funcao} (char *palavra)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b colisao_funcao} ({\b Tabela_Hash} tabela, int cont)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e macros\par
\pard\plain 
{\xe \v QUANTIDADE_DE_LINHAS\:teste.h}
{\xe \v teste.h\:QUANTIDADE_DE_LINHAS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define QUANTIDADE_DE_LINHAS\~ 200}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TAMANHO\:teste.h}
{\xe \v teste.h\:TAMANHO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TAMANHO\~ 2000}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TAMANHO_DA_FRASE\:teste.h}
{\xe \v teste.h\:TAMANHO_DA_FRASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TAMANHO_DA_FRASE\~ 200}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TAMANHO_DA_PALAVRA\:teste.h}
{\xe \v teste.h\:TAMANHO_DA_PALAVRA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TAMANHO_DA_PALAVRA\~ 35}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TAMANHO_DO_CONTROLE\:teste.h}
{\xe \v teste.h\:TAMANHO_DO_CONTROLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TAMANHO_DO_CONTROLE\~ 100}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TAMANHO_VETOR_TEMPORARIO\:teste.h}
{\xe \v teste.h\:TAMANHO_VETOR_TEMPORARIO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TAMANHO_VETOR_TEMPORARIO\~ 500}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TESTE_H_\:teste.h}
{\xe \v teste.h\:TESTE_H_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TESTE_H_}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es dos tipos\par
\pard\plain 
{\xe \v ARQUIVO\:teste.h}
{\xe \v teste.h\:ARQUIVO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b dado} {\b ARQUIVO}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Dados\:teste.h}
{\xe \v teste.h\:Dados}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b nos} {\b Dados}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Hash\:teste.h}
{\xe \v teste.h\:Hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b Dados}* Hash[{\b TAMANHO}]}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v NoLISTA\:teste.h}
{\xe \v teste.h\:NoLISTA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b no} {\b NoLISTA}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Tabela_Hash\:teste.h}
{\xe \v teste.h\:Tabela_Hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b Dados} Tabela_Hash[{\b TAMANHO}]}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Atualiza_buffer\:teste.h}
{\xe \v teste.h\:Atualiza_buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Atualiza_buffer ({\b Tabela_Hash} tabela, int pos, int linha, char palavra[], char * nome)}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v colisao_funcao\:teste.h}
{\xe \v teste.h\:colisao_funcao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int colisao_funcao ({\b Tabela_Hash} tabela, int cont)}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 75 \{\par
76 \par
77 \par
78  {\cf19 while}( tabela[cont].livre == {\cf17 false} )\par
79         \{\par
80             cont = cont + 1;\par
81         \}\par
82         {\cf19 return} cont;\par
83 \}\par
}
}
{\xe \v Dados_Arquivo\:teste.h}
{\xe \v teste.h\:Dados_Arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Dados_Arquivo ({\b Tabela_Hash} tabela, {\b ARQUIVO} * arquivo, char * nome)}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 128 \{\par
129 \par
130         {\cf20 //Tabela_Hash tabela;}\par
131     {\cf18 char} a[TAMANHO_DA_PALAVRA], palavra[TAMANHO_DA_PALAVRA], **vetor_pra_ordenamento;\par
132     {\cf18 int} i  = 0, pos = 0, linha = 0, u = 0;\par
133 \par
134     vetor_pra_ordenamento = {\cf17 new} {\cf18 char}*[TAMANHO_VETOR_TEMPORARIO];\par
135     {\cf19 for}({\cf18 int} i = 0; i < TAMANHO_VETOR_TEMPORARIO; i++)\par
136     \{\par
137     vetor_pra_ordenamento[i] = {\cf17 new} {\cf18 char}[TAMANHO_DA_PALAVRA];\par
138     \}\par
139 \par
140     ifstream arquivoentrada;\par
141     {\cf20 //abre_arquivo(ifstream arquivoentrada);}\par
142 \par
143         arquivoentrada.open(nome);\par
144 \par
145     {\cf19 if}(!arquivoentrada.is_open())\par
146     \{\par
147         cout << {\cf22 "N\'E3o foi encontrado o arquivo: Insera-no na pasta atual."} << endl;\par
148         arquivoentrada.clear();\par
149         {\cf19 return} {\cf17 false};\par
150     \}\par
151 \par
152 \par
153 \par
154 \par
155     {\cf19 while}(arquivoentrada.eof() != 1)\par
156     \{\par
157         a[i] = arquivoentrada.get();\par
158 \par
159         {\cf19 if}((a[i] >= 32 && a[i] <= 64) || (a[i] > 90 && a[i] < 97)  || (a[i] > 122 && a[i] < 128) || a[i] == {\cf23 '\\n'})\par
160         \{\par
161         {\cf19 if}(a[i] == {\cf23 '\\n'})\par
162         \{\par
163             linha++;\par
164         \}\par
165 \par
166         {\cf19 if}((a[0] >= 32 && a[0] <= 64) || (a[0] > 90 && a[0] < 97)  || (a[0] > 122 && a[0] < 128) || a[0] == {\cf23 '\\n'})\par
167         \{\par
168 \par
169         \}\par
170         {\cf19 else}\par
171         \{\par
172 \par
173             a[i] = {\cf23 '\\0'};\par
174             strcpy(palavra, a);\par
175             strcpy(vetor_pra_ordenamento[u], strupr(palavra));\par
176             u++;\par
177 \par
178             {\cf18 int} pos = hash_funcao(a);\par
179 \par
180             {\cf20 //cout << tabela[pos].livre << endl;}\par
181             {\cf19 if}(strcmp(tabela[pos].Palavra, palavra) != 0 && tabela[pos].livre == {\cf17 false})\par
182             \{\par
183                pos = colisao_funcao(tabela, pos);\par
184             \}\par
185 \par
186             Atualiza_buffer(tabela, pos, linha, palavra);\par
187 \par
188 \par
189             {\cf19 for}({\cf18 int} j = 0; j <= i; j++ )\par
190             \{\par
191                {\cf20 //cout << a[j];}\par
192                 a[j] = {\cf23 ' '};\par
193             \}\par
194             i = 0;\par
195            {\cf20 //cout <<endl;}\par
196             \}\par
197         \}\par
198         {\cf19 else}\par
199         \{\par
200          i++;\par
201         \}\par
202 \par
203 \par
204     \}\par
205 \par
206 \par
207 \par
208     {\cf20 //ordenamento das palavras do arquivo}\par
209 {\cf18 int} total = u;\par
210 {\cf20 //system("PAUSE > null");}\par
211 \par
212 \par
213 {\cf18 char} *aux = ({\cf18 char}*) {\cf17 new} {\cf18 char};\par
214 \par
215 {\cf19 for}({\cf18 int} r = 0; r < u; r++)\par
216 \{\par
217     {\cf19 for}({\cf18 int} s = r+1; s < u; s++)\par
218     \{\par
219         {\cf19 if} (strcmp(vetor_pra_ordenamento[r],vetor_pra_ordenamento[s])>0)\par
220             \{\par
221                strcpy(aux,vetor_pra_ordenamento[s]);\par
222                strcpy(vetor_pra_ordenamento[s],vetor_pra_ordenamento[r]);\par
223                strcpy(vetor_pra_ordenamento[r], aux);\par
224             \}\par
225     \}\par
226 \par
227 \}\par
228 \par
229 \par
230 {\cf19 for}({\cf18 int} q = 0; q < u; q++)\par
231 \{\par
232   {\cf20 //   cout << vetor_pra_ordenamento[q] << endl;}\par
233 \par
234 \}\par
235 \par
236 \par
237 \par
238 {\cf19 for}({\cf18 int} p = 0; p < u - 1; p++)\par
239 \{\par
240 \par
241 \par
242     {\cf19 if}(strcmp(vetor_pra_ordenamento[p], vetor_pra_ordenamento[p+1]) == 0)\par
243     \{\par
244     {\cf20 //cout << strcmp(vetor_pra_ordenamento[p], vetor_pra_ordenamento[p+1]) << endl;}\par
245     {\cf20 //cout << u << endl;}\par
246     {\cf20 //cout << vetor_pra_ordenamento[p] << "||" << vetor_pra_ordenamento[p+ 1] << endl;}\par
247 \par
248         {\cf19 for}(i= p ; i < u - 1; i++)\par
249         \{\par
250             {\cf20 //cout << vetor_pra_ordenamento[i] << "||" << vetor_pra_ordenamento[i+ 1] << "SDXSZ" << endl ;}\par
251             strcpy(vetor_pra_ordenamento[i],vetor_pra_ordenamento[i+1]);\par
252             {\cf20 //cout << vetor_pra_ordenamento[i] << "||" << vetor_pra_ordenamento[i+ 1] << endl;}\par
253            {\cf20 // system("PAUSE > null");}\par
254         \}\par
255           u--;\par
256           p--;\par
257 \par
258     \}\par
259 \par
260 \}\par
261 \par
262 {\cf20 /*}\par
263 {\cf20 for(int q = 0; q < u; q++)}\par
264 {\cf20 \{}\par
265 {\cf20     cout << vetor_pra_ordenamento[q] << endl;}\par
266 {\cf20 }\par
267 {\cf20 \}}\par
268 {\cf20 */}\par
269 \par
270   arquivoentrada.close();\par
271 \par
272   {\cf20 //ARQUIVO *arquivo = (ARQUIVO*) new ARQUIVO;}\par
273   strcpy(arquivo->nome_arquivo, nome);\par
274   arquivo->quantidade_palavras = total;\par
275   arquivo->quantidade_palavras_nao_repetidas = u;\par
276   arquivo->Palavras_organizadas = vetor_pra_ordenamento;\par
277   arquivo->numero_do_arquivo++;\par
278 \par
279 \par
280 {\cf19 return} {\cf17 true};\par
281 \par
282 {\cf20 /*}\par
283 {\cf20 cout << tabela[152].Palavra << endl;}\par
284 {\cf20 cout << tabela[152].quantidade << endl << endl;}\par
285 {\cf20 for(int k = 0; k < tabela[152].quantidade; k++)}\par
286 {\cf20 \{}\par
287 {\cf20     cout << tabela[152].linha[k] << endl;}\par
288 {\cf20 }\par
289 {\cf20 \}}\par
290 {\cf20 */}\par
291 \}\par
}
}
{\xe \v hash_funcao\:teste.h}
{\xe \v teste.h\:hash_funcao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int hash_funcao (char * palavra)}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 86 \{\par
87    {\cf20 // system("PAUSE > null");}\par
88     palavra = strupr(palavra);\par
89     {\cf18 int} cont = 0, r = 0;\par
90     {\cf19 while}(palavra[r] != {\cf23 '\\0'})\par
91     \{\par
92         r++;\par
93     \}\par
94     {\cf19 for}({\cf18 int} j = 0; j < r; j++)\par
95     \{\par
96         cont = cont + palavra[j];\par
97     \}\par
98     {\cf19 if}(cont < 0)\par
99     \{\par
100     cont = (-1) * cont;\par
101     \}\par
102     {\cf20 //cout<< cont<< endl;}\par
103     {\cf19 return} ({\cf18 unsigned} {\cf18 int})  cont;\par
104 \par
105 \}\par
}
}
{\xe \v Imprimir_Ajuda\:teste.h}
{\xe \v teste.h\:Imprimir_Ajuda}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Imprimir_Ajuda ()}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12 \{\par
13 \par
14     cout << {\cf22 "op\'E7\'F5es:"} << endl;\par
15     cout << {\cf22 " ##Modo de Gerenciamento de Busca:"} << endl << endl;\par
16     cout <<{\cf22 "-h ou --ajuda: mostra essa tela e sai."} << endl\par
17      << {\cf22 "-i ou --Inserir: Inserir novo arquivo na base de dados."} << endl\par
18      << {\cf22 "-r ou --Remover: Remover arquivo na base de dados."} << endl << endl;\par
19 \par
20      cout << {\cf22 "Exibi\'E7\'E3o da base de arquivo:"} << endl << endl\par
21      << {\cf22 "-e ou --List_Insercao: Listar todos os arquivos da base tendo como base a ordem de Insercao."} << endl\par
22      << {\cf22 "-a ou --List_Alfabetico: Listar todos os arquivos da base tendo como base a ordem alfab\'E9tica."} << endl\par
23      << {\cf22 "-p ou --List_Quant_Palavras: Listar todos os arquivos da base tendo como base A ordem decrescente da quantidade de palavras do arquivo."} << endl << endl;\par
24 \par
25     cout << {\cf22 " ##Modo de Buscas:"} << endl << endl;\par
26 \par
27     cout << {\cf22 "Argumento de Busca:"} << endl << endl\par
28     << {\cf22 "-d ou --bAND _And:A busca \'E9 feita por linhas dos arquivos texto que cont\'E9m todas as palavras chave passadas como argumento de entrada."} << endl\par
29     << {\cf22 "-o ou --bOR : A busca \'E9 feita por linhas dos arquivos texto que cont\'E9m ao menos uma das palavras chave passadas como argumento de entrada."} << endl;\par
30 \par
31     cout << {\cf22 "Exibi\'E7\'E3o do resultado da busca:"} << endl << endl\par
32     << {\cf22 "-b ou --Impress_Alfabetica: A impress\'E3o \'E9 feita exibindo os resultados em ordem alfab\'E9tica do nome do arquivo."} << endl\par
33     << {\cf22 "-q ou --Impress_Quant_Palavras: A impress\'E3o \'E9 feita exibindo os resultados em ordem decrescente do n\'FAmero de vezes que as palavraschave ocorreram em cada arquivo."} << endl\par
34     << {\cf22 "-c ou --Impress_Insercao: A impress\'E3o \'E9 feita exibindo os resultados na ordem em que cada arquivo foi inserido na base."} << endl;\par
35 \par
36     cout << {\cf22 "Contabiliza\'E7\'E3o do tempo:"} << endl << endl\par
37     << {\cf22 "-s ou --Temp_S: O programa deve registrar e exibir o tempo total de execu\'E7\'E3o de da busca."} << endl\par
38     << {\cf22 "-n ou --Temp_N: O programa n\'E3o deve registrar nem exibir o tempo total de execu\'E7\'E3o da busca."} << endl;\par
39 \}\par
}
}
{\xe \v Inicializar_Hash\:teste.h}
{\xe \v teste.h\:Inicializar_Hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Hash ({\b Tabela_Hash} tabela)}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 42 \{\par
43 \par
44 \par
45     {\cf19 for}({\cf18 int} i = 0; i < TAMANHO; i++)\par
46       \{\par
47        tabela[i].quantidade = 0;\par
48        tabela[i].livre = {\cf17 true};\par
49        tabela[i].prox = NULL;\par
50        tabela[i].ant = NULL;\par
51        {\cf19 for}({\cf18 int} j = 0; j < QUANTIDADE_DE_LINHAS; j++)\par
52        \{\par
53            tabela[i].linha[j] = 0;\par
54        \}\par
55        \}\par
56 \par
57 \}\par
}
}
{\xe \v Inicializar_Lista\:teste.h}
{\xe \v teste.h\:Inicializar_Lista}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Lista ({\b LISTA} * lista)}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 69 \{\par
70     lista->ini = NULL;\par
71     lista->fim = NULL;\par
72     lista->Quantidade_de_Arquivos = 0;\par
73 \}\par
}
}
{\xe \v Inicializar_Vetor_arquivo\:teste.h}
{\xe \v teste.h\:Inicializar_Vetor_arquivo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Inicializar_Vetor_arquivo ({\b ARQUIVO} * arquivo)}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 60 \{\par
61 \par
62     arquivo->numero_do_arquivo = 0;\par
63     arquivo->quantidade_palavras = 0;\par
64     arquivo->quantidade_palavras_nao_repetidas = 0;\par
65 \}\par
}
}
{\xe \v is_empty\:teste.h}
{\xe \v teste.h\:is_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool is_empty (std::ifstream & pFile)}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 108 \{\par
109 {\cf19 return} pFile.peek() == std::ifstream::traits_type::eof();\par
110 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
teste.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.h}
{\xe \v C:/Users/Cliente Lider/Documents/Faculdade/Projeto Arquivo (2024)/teste.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef _TESTE_H_}\par
2 {\cf21 #define TESTE_H_}\par
3 {\cf21 #define TAMANHO 2000                }{\cf20 // TABELA HASH INICIAL - PARA PR\'C9-PROCESSAMENTO}\par
4 {\cf21 #define QUANTIDADE_DE_LINHAS 200    }{\cf20 // POR ARQUIVO}\par
5 {\cf21 #define TAMANHO_DA_PALAVRA 35}\par
6 {\cf21 #define TAMANHO_DO_CONTROLE 100}\par
7 {\cf21 #define TAMANHO_VETOR_TEMPORARIO  500}\par
8 {\cf21 #define TAMANHO_DA_FRASE    200}\par
9 \par
10 \par
11 {\cf17 typedef} {\cf17 struct }nos\par
12 \{\par
13     {\cf18 char} Palavra[TAMANHO_DA_PALAVRA];\par
14     {\cf18 char} Arquivo[TAMANHO_DA_PALAVRA];\par
15     {\cf18 int}  quantidade;\par
16     {\cf18 int} linha[QUANTIDADE_DE_LINHAS];\par
17     {\cf18 int} total_de_vezes_palavra;            {\cf20 //quant \'E9 sem repeti\'E7\'E3o e total \'E9 com repeti\'E7\'E3o;}\par
18     {\cf18 bool} livre;\par
19     nos *prox;\par
20     nos *ant;\par
21 \par
22 \}Dados;\par
23 \par
24 {\cf17 typedef} Dados Tabela_Hash[TAMANHO];\par
25 {\cf17 typedef} Dados *Hash[TAMANHO];\par
26 \par
27 \par
28 {\cf17 typedef} {\cf17 struct }dado\par
29 \{\par
30     {\cf18 char} *nome_arquivo;\par
31     {\cf18 int} quantidade_palavras;\par
32     {\cf18 int} quantidade_palavras_nao_repetidas;\par
33     {\cf18 char} **Palavras_organizadas;\par
34     {\cf18 int} numero_do_arquivo;\par
35     {\cf20 //int numero_de_arquivos;}\par
36     {\cf20 //Dados *dados;}\par
37 \par
38 \}ARQUIVO;\par
39 \par
40 {\cf17 typedef} {\cf17 struct }no\par
41 \{\par
42     no *prox;\par
43     no *ant;\par
44     ARQUIVO *arquivo;\par
45 \}NoLISTA;\par
46 \par
47 {\cf17 typedef} {\cf17 struct}\par
48 \{\par
49     no *ini;\par
50     no *fim;\par
51     {\cf18 int} Quantidade_de_Arquivos;\par
52 \}LISTA;\par
53 \par
54 {\cf20 /*}\par
55 {\cf20 typedef struct no}\par
56 {\cf20 \{}\par
57 {\cf20 }\par
58 {\cf20     int quantidade_palavras}\par
59 {\cf20     Dados *palavra;}\par
60 {\cf20     no *prox;}\par
61 {\cf20     no *ant;}\par
62 {\cf20 \}PALAVRAS;}\par
63 {\cf20 }\par
64 {\cf20 */}\par
65 \par
66 {\cf18 void} Imprimir_Ajuda();\par
67 \par
68 {\cf18 void} Inicializar_Hash(Tabela_Hash tabela);\par
69 {\cf18 void} Inicializar_Vetor_arquivo(ARQUIVO *arquivo);\par
70 {\cf18 void} Inicializar_Lista(LISTA * lista);\par
71 \par
72 {\cf18 bool} is_empty(std::ifstream& pFile);\par
73 \par
74 {\cf20 //procedimento de pre processamento de um arquivo na entrada:  como saida temos as struturas tabela e arquivo atualizadas e prontas para serem impressas}\par
75 {\cf18 bool} Dados_Arquivo(Tabela_Hash tabela, ARQUIVO *arquivo, {\cf18 char} *nome);\par
76 {\cf18 void} Atualiza_buffer(Tabela_Hash tabela, {\cf18 int} pos, {\cf18 int} linha, {\cf18 char} palavra[], {\cf18 char} *nome );\par
77 \par
78 \par
79 {\cf20 // tabela hash}\par
80 {\cf18 int} hash_funcao({\cf18 char} *palavra);\par
81 {\cf18 int} colisao_funcao(Tabela_Hash tabela, {\cf18 int} cont);\par
82 \par
83 \par
84 \par
85 {\cf20 //void Remover_Arquivo(char *nome, LISTA *lista);}\par
86 \par
87 {\cf21 #endif }{\cf20 // _TESTE_H_}\par
88 \par
89 \par
90 \par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Sum\'E1rio\par 
\pard\plain 
{\tc \v Sum\'E1rio}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
